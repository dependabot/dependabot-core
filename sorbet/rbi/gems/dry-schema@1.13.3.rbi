# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dry-schema` gem.
# Please instead update this file by running `bin/tapioca gem dry-schema`.

# source://dry-schema//lib/dry/schema.rb#10
module Dry
  class << self
    # source://dry-configurable/1.1.0/lib/dry/configurable.rb#11
    def Configurable(**options); end

    # source://dry-core/1.0.1/lib/dry/core.rb#52
    def Equalizer(*keys, **options); end

    # source://dry-types/1.7.1/lib/dry/types.rb#253
    def Types(*namespaces, default: T.unsafe(nil), **aliases); end
  end
end

# Main interface
#
# @api public
#
# source://dry-schema//lib/dry/schema.rb#14
module Dry::Schema
  include ::Dry::Core::Constants
  extend ::Dry::Core::Extensions

  class << self
    # source://dry-schema//lib/dry/schema.rb#85
    def Form(**options, &block); end

    # Define a schema suitable for JSON data
    #
    # This schema type uses `Types::JSON` for coercion by default
    #
    # @api public
    # @example
    #   Dry::Schema.JSON do
    #   required(:name).filled(:string)
    #   required(:age).value(:integer, gt?: 0)
    #   end
    # @return [Params]
    # @see Schema#define
    #
    # source://dry-schema//lib/dry/schema.rb#105
    def JSON(**options, &block); end

    # Define a schema suitable for HTTP params
    #
    # This schema type uses `Types::Params` for coercion by default
    #
    # @api public
    # @example
    #   Dry::Schema.Params do
    #   required(:name).filled(:string)
    #   required(:age).value(:integer, gt?: 0)
    #   end
    # @return [Params]
    # @see Schema#define
    #
    # source://dry-schema//lib/dry/schema.rb#85
    def Params(**options, &block); end

    # Configuration
    #
    # @api public
    # @example
    #   Dry::Schema.config.messages.backend = :i18n
    # @return [Config]
    #
    # source://dry-schema//lib/dry/schema.rb#47
    def config; end

    # Define a schema
    #
    # @api public
    # @example
    #   Dry::Schema.define do
    #   required(:name).filled(:string)
    #   required(:age).value(:integer, gt?: 0)
    #   end
    # @param options [Hash]
    # @return [Processor]
    # @see DSL.new
    #
    # source://dry-schema//lib/dry/schema.rb#66
    def define(**options, &block); end

    # @api private
    #
    # source://dry-schema//lib/dry/schema.rb#18
    def loader; end
  end
end

# Extended rule compiler used internally by the DSL
#
# @api private
#
# source://dry-schema//lib/dry/schema/compiler.rb#13
class Dry::Schema::Compiler < ::Dry::Logic::RuleCompiler
  # Return true if a given predicate is supported by this compiler
  #
  # @api private
  # @param predicate [Symbol]
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/compiler.rb#46
  def support?(predicate); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/compiler.rb#19
  def visit_and(node); end

  # Build a special rule that will produce namespaced failures
  #
  # This is needed for schemas that are namespaced and they are
  # used as nested schemas
  #
  # @api private
  # @param node [Array]
  # @param _opts [Hash] Unused
  # @return [NamespacedRule]
  #
  # source://dry-schema//lib/dry/schema/compiler.rb#34
  def visit_namespace(node, _opts = T.unsafe(nil)); end

  class << self
    # Builds a default compiler instance with custom predicate registry
    #
    # @api private
    # @return [Compiler]
    #
    # source://dry-schema//lib/dry/schema/compiler.rb#14
    def new(predicates = T.unsafe(nil)); end
  end
end

# Schema definition configuration class
#
# @api public
# @see DSL#configure
#
# source://dry-schema//lib/dry/schema/config.rb#14
class Dry::Schema::Config
  include ::Dry::Configurable::Initializer
  include ::Dry::Core::Constants
  include ::Dry::Configurable
  include ::Dry::Configurable::Methods
  include ::Dry::Configurable::InstanceMethods
  include ::Dry::Core::Equalizer::Methods
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods

  # @api private
  #
  # source://dry-schema//lib/dry/schema/config.rb#68
  def inspect; end

  private

  # Forward to the underlying config object
  #
  # @api private
  #
  # source://dry-schema//lib/dry/schema/config.rb#77
  def method_missing(meth, *args, &block); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/config.rb#63
  def respond_to_missing?(meth, include_private = T.unsafe(nil)); end
end

# Path to the default set of localized messages bundled within the gem
#
# @api public
#
# source://dry-schema//lib/dry/schema/constants.rb#27
Dry::Schema::DEFAULT_MESSAGES_PATH = T.let(T.unsafe(nil), Pathname)

# Default namespace used for localized messages in YAML files
#
# @api public
#
# source://dry-schema//lib/dry/schema/constants.rb#30
Dry::Schema::DEFAULT_MESSAGES_ROOT = T.let(T.unsafe(nil), String)

# @api public
#
# source://dry-schema//lib/dry/schema/constants.rb#15
Dry::Schema::DOT = T.let(T.unsafe(nil), String)

# The schema definition DSL class
#
# The DSL is exposed by:
#   - `Schema.define`
#   - `Schema.Params`
#   - `Schema.JSON`
#   - `Schema::Params.define` - use with sub-classes
#   - `Schema::JSON.define` - use with sub-classes
#
# @api public
# @example class-based definition
#   class UserSchema < Dry::Schema::Params
#   define do
#   required(:name).filled
#   required(:age).filled(:integer, gt: 18)
#   end
#   end
#
#   user_schema = UserSchema.new
#   user_schema.(name: 'Jame', age: 21)
# @example instance-based definition shortcut
#   UserSchema = Dry::Schema.Params do
#   required(:name).filled
#   required(:age).filled(:integer, gt: 18)
#   end
#
#   UserSchema.(name: 'Jame', age: 21)
#
# source://dry-schema//lib/dry/schema/dsl.rb#37
class Dry::Schema::DSL
  include ::Dry::Initializer::Mixin::Root
  extend ::Dry::Initializer

  # Return a macro with the provided name
  #
  # @api public
  # @param name [Symbol]
  # @return [Macros::Core]
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#124
  def [](name); end

  # Method allows steps injection to the processor
  #
  # @api public
  # @example
  #   after(:rule_applier) do |input|
  #   input.compact
  #   end
  # @return [DSL]
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#267
  def after(key, &block); end

  # A shortcut for defining an array type with a member
  #
  # @api public
  # @example
  #   required(:tags).filled(array[:string])
  # @return [Dry::Types::Array::Member]
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#238
  def array; end

  # Method allows steps injection to the processor
  #
  # @api public
  # @example
  #   before(:rule_applier) do |input|
  #   input.compact
  #   end
  # @return [DSL]
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#252
  def before(key, &block); end

  # Build a processor based on DSL's definitions
  #
  # @api private
  # @return [Processor, Params, JSON]
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#195
  def call; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#108
  def compiler; end

  # Provide customized configuration for your schema
  #
  # @api public
  # @example
  #   Dry::Schema.define do
  #   configure do |config|
  #   config.messages.backend = :i18n
  #   end
  #   end
  # @return [DSL]
  # @see Config
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#102
  def configure(&block); end

  # Check if a custom type was set under provided key name
  #
  # @api private
  # @return [Bool]
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#328
  def custom_type?(name); end

  # Check if any filter rules were defined
  #
  # @api private
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#365
  def filter_rules?; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#349
  def filter_schema; end

  # Build an input schema DSL used by `filter` API
  #
  # @api private
  # @see Macros::Value#filter
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#358
  def filter_schema_dsl; end

  # A generic method for defining keys
  #
  # @api public
  # @param name [Symbol] The key name
  # @param macro [Class] The macro sub-class (ie `Macros::Required` or
  #   any other `Macros::Key` subclass)
  # @raise [ArgumentError]
  # @return [Macros::Key]
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#173
  def key(name, macro:, &block); end

  # Merge with another dsl
  #
  # @api private
  # @return [DSL]
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#214
  def merge(other); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#381
  def merge_types(op_class, lhs, rhs); end

  # Return a new DSL instance using the same processor type
  #
  # @api private
  # @return [Dry::Types::Safe]
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#304
  def new(klass: T.unsafe(nil), **options, &block); end

  # Define an optional key
  #
  # This works exactly the same as `required` except that if a key is not present
  # rules will not be applied
  #
  # @api public
  # @param name [Symbol] The key name
  # @return [Macros::Optional]
  # @see DSL#required
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#160
  def optional(name, &block); end

  # The parent (last from parents) which is used for copying non mergeable configuration
  #
  # @api public
  # @return DSL
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#277
  def parent; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#113
  def predicates; end

  # Define a required key
  #
  # @api public
  # @example
  #   required(:name).filled
  #
  #   required(:age).value(:integer)
  #
  #   required(:user_limit).value(:integer, gt?: 0)
  #
  #   required(:tags).filled { array? | str? }
  # @param name [Symbol] The key name
  # @return [Macros::Required]
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#144
  def required(name, &block); end

  # Resolve type object from the provided spec
  #
  # @api private
  # @param spec [Symbol, Array<Symbol>, Dry::Types::Type]
  # @return [Dry::Types::Type]
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#339
  def resolve_type(spec); end

  # Set a type for the given key name
  #
  # @api private
  # @param name [Symbol] The key name
  # @param spec [Symbol, Array<Symbol>, Dry::Types::Type] The type spec or a type object
  # @return [Dry::Types::Safe]
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#316
  def set_type(name, spec); end

  # Return type schema used when composing subschemas
  #
  # @api private
  # @return [Dry::Types::Schema]
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#295
  def strict_type_schema; end

  # Cast this DSL into a rule object
  #
  # @api public
  # @return [RuleApplier]
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#226
  def to_rule; end

  # Return type schema used by the value coercer
  #
  # @api private
  # @return [Dry::Types::Lax]
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#286
  def type_schema; end

  # This DSL's type map merged with any parent type maps
  #
  # @api private
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#376
  def types; end

  protected

  # Build a key map from defined types
  #
  # @api protected
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#408
  def key_map(types = T.unsafe(nil)); end

  # Build a rule applier
  #
  # @api protected
  # @return [RuleApplier]
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#392
  def rule_applier; end

  # Build rules from defined macros
  #
  # @api protected
  # @see #rule_applier
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#401
  def rules; end

  private

  # @api private
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#501
  def default_config; end

  # Build a key coercer
  #
  # @api private
  # @return [KeyCoercer]
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#440
  def key_coercer; end

  # Return key map type configured by the processor type
  #
  # @api private
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#466
  def key_map_type; end

  # Build a key spec needed by the key map
  #
  # TODO: we need a key-map compiler using Types AST
  #
  # @api private
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#475
  def key_spec(name, type); end

  # Build a key validator
  #
  # @api private
  # @return [KeyValidator]
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#431
  def key_validator; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#422
  def parent_filter_schemas; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#496
  def parent_key_map; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#491
  def parent_rules; end

  # Return type registry configured by the processor type
  #
  # @api private
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#456
  def type_registry; end

  # @api public
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#512
  def types_merger; end

  # Build a value coercer
  #
  # @api private
  # @return [ValueCoercer]
  #
  # source://dry-schema//lib/dry/schema/dsl.rb#449
  def value_coercer; end

  class << self
    # Build a new DSL object and evaluate provided block
    #
    # @api public
    # @option options
    # @option options
    # @option options
    # @option options
    # @param options [Hash]
    # @return [DSL]
    # @see Schema.define
    # @see Schema.Params
    # @see Schema.JSON
    # @see Processor.define
    #
    # source://dry-schema//lib/dry/schema/dsl.rb#81
    def new(**options, &block); end
  end
end

# @api public
#
# source://dry-schema//lib/dry/schema/dsl.rb#38
Dry::Schema::DSL::Types = Dry::Schema::Types

# Info extension
#
# @api public
#
# source://dry-schema//lib/dry/schema/extensions/info/schema_compiler.rb#8
module Dry::Schema::Info; end

# @api private
#
# source://dry-schema//lib/dry/schema/extensions/info/schema_compiler.rb#10
class Dry::Schema::Info::SchemaCompiler
  # @api private
  # @return [SchemaCompiler] a new instance of SchemaCompiler
  #
  # source://dry-schema//lib/dry/schema/extensions/info/schema_compiler.rb#29
  def initialize; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/extensions/info/schema_compiler.rb#104
  def assign_type(key, type); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/extensions/info/schema_compiler.rb#39
  def call(ast); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/extensions/info/schema_compiler.rb#26
  def keys; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/extensions/info/schema_compiler.rb#34
  def to_h; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/extensions/info/schema_compiler.rb#44
  def visit(node, opts = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/extensions/info/schema_compiler.rb#64
  def visit_and(node, opts = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/extensions/info/schema_compiler.rb#79
  def visit_each(node, opts = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/extensions/info/schema_compiler.rb#72
  def visit_implication(node, opts = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/extensions/info/schema_compiler.rb#84
  def visit_key(node, opts = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/extensions/info/schema_compiler.rb#90
  def visit_predicate(node, opts = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/extensions/info/schema_compiler.rb#50
  def visit_set(node, opts = T.unsafe(nil)); end
end

# @api private
#
# source://dry-schema//lib/dry/schema/extensions/info/schema_compiler.rb#11
Dry::Schema::Info::SchemaCompiler::PREDICATE_TO_TYPE = T.let(T.unsafe(nil), Hash)

# @api public
#
# source://dry-schema//lib/dry/schema/extensions/info.rb#11
module Dry::Schema::Info::SchemaMethods
  # Return information about keys and types
  #
  # @api public
  # @return [Hash<Symbol=>Hash>]
  #
  # source://dry-schema//lib/dry/schema/extensions/info.rb#17
  def info; end
end

# An error raised when DSL is used in an incorrect way
#
# @api public
#
# source://dry-schema//lib/dry/schema/constants.rb#33
class Dry::Schema::InvalidSchemaError < ::StandardError; end

# JSON schema type
#
# @api public
# @see Processor
# @see Schema#JSON
#
# source://dry-schema//lib/dry/schema/json.rb#11
class Dry::Schema::JSON < ::Dry::Schema::Processor; end

# Key objects used by key maps
#
# @api public
#
# source://dry-schema//lib/dry/schema/key.rb#8
class Dry::Schema::Key
  include ::Dry::Core::Cache::Methods
  include ::Dry::Core::Equalizer::Methods
  extend ::Dry::Core::Cache

  # @api private
  # @return [Key] a new instance of Key
  #
  # source://dry-schema//lib/dry/schema/key.rb#35
  def initialize(id, name: T.unsafe(nil), coercer: T.unsafe(nil)); end

  # @api public
  # @return [Proc, #call] A key name coercer function
  #
  # source://dry-schema//lib/dry/schema/key.rb#22
  def coercer; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key.rb#58
  def coercible(&coercer); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key.rb#78
  def dump; end

  # @api public
  # @return [Symbol] The key identifier
  #
  # source://dry-schema//lib/dry/schema/key.rb#16
  def id; end

  # @api public
  # @return [Symbol, String, Object] The actual key name expected in an input hash
  #
  # source://dry-schema//lib/dry/schema/key.rb#19
  def name; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key.rb#73
  def new(**new_opts); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key.rb#42
  def read(source); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key.rb#63
  def stringified; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key.rb#68
  def to_dot_notation; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key.rb#53
  def write(source, target); end

  private

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key.rb#85
  def coerced_name; end

  class << self
    # @api private
    #
    # source://dry-schema//lib/dry/schema/key.rb#25
    def [](name, **opts); end

    # @api private
    #
    # source://dry-schema//lib/dry/schema/key.rb#30
    def new(*args, **kwargs); end
  end
end

# A specialized key type which handles nested arrays
#
# @api private
#
# source://dry-schema//lib/dry/schema/key.rb#139
class Dry::Schema::Key::Array < ::Dry::Schema::Key
  # @api private
  # @return [Array] a new instance of Array
  #
  # source://dry-schema//lib/dry/schema/key.rb#145
  def initialize(id, member:, **opts); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key.rb#163
  def coercible(&coercer); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key.rb#178
  def dump; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key.rb#142
  def member; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key.rb#168
  def stringified; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key.rb#173
  def to_dot_notation; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key.rb#151
  def write(source, target); end
end

# @api public
#
# source://dry-schema//lib/dry/schema/key.rb#11
Dry::Schema::Key::DEFAULT_COERCER = T.let(T.unsafe(nil), Proc)

# A specialized key type which handles nested hashes
#
# @api private
#
# source://dry-schema//lib/dry/schema/key.rb#92
class Dry::Schema::Key::Hash < ::Dry::Schema::Key
  # @api private
  # @return [Hash] a new instance of Hash
  #
  # source://dry-schema//lib/dry/schema/key.rb#99
  def initialize(id, members:, **opts); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key.rb#116
  def coercible(&coercer); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key.rb#131
  def dump; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key.rb#96
  def members; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key.rb#105
  def read(source); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key.rb#121
  def stringified; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key.rb#126
  def to_dot_notation; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key.rb#109
  def write(source, target); end
end

# Coerces keys in a hash using provided coercer function
#
# @api private
#
# source://dry-schema//lib/dry/schema/key_coercer.rb#11
class Dry::Schema::KeyCoercer
  include ::Dry::Core::Cache::Methods
  include ::Dry::Core::Equalizer::Methods
  extend ::Dry::Core::Cache

  # @api private
  # @return [KeyCoercer] a new instance of KeyCoercer
  #
  # source://dry-schema//lib/dry/schema/key_coercer.rb#30
  def initialize(key_map, &coercer); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key_coercer.rb#35
  def [](result); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key_coercer.rb#35
  def call(result); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key_coercer.rb#17
  def coercer; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key_coercer.rb#17
  def key_map; end

  class << self
    # @api private
    #
    # source://dry-schema//lib/dry/schema/key_coercer.rb#20
    def new(*args); end

    # @api private
    #
    # source://dry-schema//lib/dry/schema/key_coercer.rb#25
    def symbolized(*args); end
  end
end

# @api private
#
# source://dry-schema//lib/dry/schema/key_coercer.rb#15
Dry::Schema::KeyCoercer::TO_SYM = T.let(T.unsafe(nil), Proc)

# Represents a list of keys defined by the DSL
#
# KeyMap objects expose an API for introspecting schema keys and the ability
# to rebuild an input hash using configured coercer function.
#
# Instances of this class are used as the very first step by the schema processors.
#
# @api public
#
# source://dry-schema//lib/dry/schema/key_map.rb#15
class Dry::Schema::KeyMap
  include ::Dry::Core::Cache::Methods
  include ::Dry::Core::Equalizer::Methods
  include ::Enumerable
  extend ::Dry::Core::Cache

  # Set key objects
  #
  # @api private
  # @return [KeyMap] a new instance of KeyMap
  #
  # source://dry-schema//lib/dry/schema/key_map.rb#50
  def initialize(keys); end

  # Return a new key map merged with the provided one
  #
  # @api public
  # @param other [KeyMap, Array] Either a key map or an array with key specs
  # @return [KeyMap]
  #
  # source://dry-schema//lib/dry/schema/key_map.rb#117
  def +(other); end

  # Return a new key map that is configured to coerce keys using provided coercer function
  #
  # @api public
  # @return [KeyMap]
  #
  # source://dry-schema//lib/dry/schema/key_map.rb#85
  def coercible(&coercer); end

  # Dump keys to their spec format
  #
  # @api public
  # @return [Array]
  #
  # source://dry-schema//lib/dry/schema/key_map.rb#131
  def dump; end

  # Iterate over keys
  #
  # @api public
  #
  # source://dry-schema//lib/dry/schema/key_map.rb#108
  def each(&block); end

  # Return a string representation of a key map
  #
  # @api public
  # @return [String]
  #
  # source://dry-schema//lib/dry/schema/key_map.rb#124
  def inspect; end

  # @api public
  # @return [Array<Key>] A list of defined key objects
  #
  # source://dry-schema//lib/dry/schema/key_map.rb#22
  def keys; end

  # Return a new key map with stringified keys
  #
  # A stringified key map is suitable for reading hashes with string keys
  #
  # @api public
  # @return [KeyMap]
  #
  # source://dry-schema//lib/dry/schema/key_map.rb#96
  def stringified; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key_map.rb#101
  def to_dot_notation; end

  # Write a new hash based on the source hash
  #
  # @api public
  # @param source [Hash] The source hash
  # @param target [Hash] The target hash
  # @return [Hash]
  #
  # source://dry-schema//lib/dry/schema/key_map.rb#75
  def write(source, target = T.unsafe(nil)); end

  class << self
    # Coerce a list of key specs into a key map
    #
    # @api public
    # @example
    #   KeyMap[:id, :name]
    #   KeyMap[:title, :artist, tags: [:name]]
    #   KeyMap[:title, :artist, [:tags]]
    # @return [KeyMap]
    #
    # source://dry-schema//lib/dry/schema/key_map.rb#34
    def [](*keys); end

    # Build new, or returned a cached instance of a key map
    #
    # @api public
    # @param args [Array<Symbol>, Array, Hash<Symbol=>Array>]
    # @return [KeyMap]
    #
    # source://dry-schema//lib/dry/schema/key_map.rb#43
    def new(*args); end
  end
end

# @api private
#
# source://dry-schema//lib/dry/schema/key_validator.rb#9
class Dry::Schema::KeyValidator
  include ::Dry::Initializer::Mixin::Root
  extend ::Dry::Initializer

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key_validator.rb#20
  def call(result); end

  private

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key_validator.rb#86
  def hashes_or_arrays(xs); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key_validator.rb#60
  def key_paths(hash); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/key_validator.rb#54
  def paths_match?(input_path, key_path); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/key_validator.rb#40
  def validate_path(key_paths, path); end
end

# @api private
#
# source://dry-schema//lib/dry/schema/key_validator.rb#14
Dry::Schema::KeyValidator::BRACKETS = T.let(T.unsafe(nil), String)

# @api private
#
# source://dry-schema//lib/dry/schema/key_validator.rb#13
Dry::Schema::KeyValidator::DIGIT_REGEX = T.let(T.unsafe(nil), Regexp)

# @api private
#
# source://dry-schema//lib/dry/schema/key_validator.rb#12
Dry::Schema::KeyValidator::INDEX_REGEX = T.let(T.unsafe(nil), Regexp)

# @api public
#
# source://dry-schema//lib/dry/schema/constants.rb#13
Dry::Schema::LIST_SEPARATOR = T.let(T.unsafe(nil), String)

# @api public
#
# source://dry-schema//lib/dry/schema/macros/optional.rb#5
module Dry::Schema::Macros; end

# Macro used to specify predicates for each element of an array
#
# @api private
#
# source://dry-schema//lib/dry/schema/macros/array.rb#12
class Dry::Schema::Macros::Array < ::Dry::Schema::Macros::DSL
  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/array.rb#47
  def ast(*_arg0); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/array.rb#47
  def to_ast(*_arg0); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/array.rb#13
  def value(*args, **opts, &block); end
end

# Abstract macro class
#
# @api private
#
# source://dry-schema//lib/dry/schema/macros/core.rb#12
class Dry::Schema::Macros::Core
  include ::Dry::Initializer::Mixin::Root
  extend ::Dry::Initializer

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/core.rb#43
  def ast(*_arg0); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/core.rb#28
  def new(**options); end

  # @api private
  # @raise [NotImplementedError]
  #
  # source://dry-schema//lib/dry/schema/macros/core.rb#49
  def operation; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/core.rb#33
  def path; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/core.rb#43
  def to_ast(*_arg0); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/core.rb#38
  def to_rule; end
end

# Macro specialization used within the DSL
#
# @api public
#
# source://dry-schema//lib/dry/schema/macros/dsl.rb#9
class Dry::Schema::Macros::DSL < ::Dry::Schema::Macros::Core
  include ::Dry::Logic::Operators

  # Like `each` but sets `array?` type-check
  #
  # @api public
  # @example a list of strings
  #   required(:tags).array(:str?)
  # @example a list of hashes
  #   required(:tags).array(:hash) do
  #   required(:name).filled(:string)
  #   end
  # @return [Macros::Core]
  #
  # source://dry-schema//lib/dry/schema/macros/dsl.rb#176
  def array(*_arg0, **_arg1, &_arg2); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/macros/dsl.rb#198
  def custom_type?; end

  # Specify predicates that should be applied to each element of an array
  #
  # This is a simpler building block than `array` macro, use it
  # when you want to provide `array?` type-check with other rules
  # manually.
  #
  # @api public
  # @example a list of strings
  #   required(:tags).value(:array, min_size?: 2).each(:str?)
  # @example a list of hashes
  #   required(:tags).value(:array, min_size?: 2).each(:hash) do
  #   required(:name).filled(:string)
  #   end
  # @return [Macros::Core]
  #
  # source://dry-schema//lib/dry/schema/macros/dsl.rb#157
  def each(*_arg0, **_arg1, &_arg2); end

  # Prepends `:filled?` predicate
  #
  # @api public
  # @example with a type spec
  #   required(:name).filled(:string)
  # @example with a type spec and a predicate
  #   required(:name).filled(:string, format?: /\w+/)
  # @return [Macros::Core]
  #
  # source://dry-schema//lib/dry/schema/macros/dsl.rb#80
  def filled(*args, **opts, &block); end

  # Specify a nested hash with enforced `hash?` type-check
  #
  # @api public
  # @example
  #   required(:tags).hash do
  #   required(:name).value(:string)
  #   end
  #
  # source://dry-schema//lib/dry/schema/macros/dsl.rb#134
  def hash(*_arg0, **_arg1, &_arg2); end

  # Set type specification and predicates for a maybe value
  #
  # @api public
  # @example
  #   required(:name).maybe(:string)
  # @return [Macros::Key]
  # @see Macros::Key#value
  #
  # source://dry-schema//lib/dry/schema/macros/dsl.rb#98
  def maybe(*args, **opts, &block); end

  # Specify a nested hash without enforced `hash?` type-check
  #
  # This is a simpler building block than `hash` macro, use it
  # when you want to provide `hash?` type-check with other rules
  # manually.
  #
  # @api public
  # @example
  #   required(:tags).value(:hash, min_size?: 1).schema do
  #   required(:name).value(:string)
  #   end
  # @return [Macros::Core]
  #
  # source://dry-schema//lib/dry/schema/macros/dsl.rb#120
  def schema(*_arg0, **_arg1, &_arg2); end

  # Set type spec
  #
  # @api public
  # @example
  #   required(:name).type(:string).value(min_size?: 2)
  # @param spec [Symbol, Array, Dry::Types::Type]
  # @return [Macros::Key]
  #
  # source://dry-schema//lib/dry/schema/macros/dsl.rb#192
  def type(spec); end

  # @api public
  # @overload value
  # @return [Macros::Core]
  #
  # source://dry-schema//lib/dry/schema/macros/dsl.rb#55
  def value(*args, **opts, &block); end

  private

  # @api private
  # @yield [macro]
  #
  # source://dry-schema//lib/dry/schema/macros/dsl.rb#205
  def append_macro(macro_type); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/dsl.rb#222
  def extract_type_spec(args, nullable: T.unsafe(nil), set_type: T.unsafe(nil)); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/dsl.rb#259
  def resolve_type(type_spec, nullable); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/macros/dsl.rb#270
  def schema_or_predicate?(arg); end
end

# Macro used to specify predicates for each element of an array
#
# @api private
#
# source://dry-schema//lib/dry/schema/macros/each.rb#10
class Dry::Schema::Macros::Each < ::Dry::Schema::Macros::DSL
  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/each.rb#24
  def ast(*_arg0); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/each.rb#24
  def to_ast(*_arg0); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/each.rb#11
  def value(*args, **opts, &block); end
end

# Macro used to prepend `:filled?` predicate
#
# @api private
#
# source://dry-schema//lib/dry/schema/macros/filled.rb#10
class Dry::Schema::Macros::Filled < ::Dry::Schema::Macros::Value
  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/filled.rb#11
  def call(*predicates, **opts, &block); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/filled.rb#27
  def ensure_valid_predicates(predicates); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/filled.rb#48
  def expected_primitives; end

  # @api private
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/macros/filled.rb#38
  def filter_empty_string?; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/filled.rb#43
  def processor_config; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/filled.rb#53
  def schema_type; end
end

# Macro used to specify a nested schema
#
# @api private
#
# source://dry-schema//lib/dry/schema/macros/hash.rb#10
class Dry::Schema::Macros::Hash < ::Dry::Schema::Macros::Schema
  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/hash.rb#11
  def call(*args, &block); end
end

# Base macro for specifying rules applied to a value found under a key
#
# @api public
#
# source://dry-schema//lib/dry/schema/macros/key.rb#12
class Dry::Schema::Macros::Key < ::Dry::Schema::Macros::DSL
  # Specify predicates that should be applied before coercion
  #
  # @api public
  # @example check format before coercing to a date
  #   required(:publish_date).filter(format?: /\d{4}-\d{2}-\d{2}).value(:date)
  # @return [Macros::Key]
  # @see Macros::Key#value
  #
  # source://dry-schema//lib/dry/schema/macros/key.rb#25
  def filter(*_arg0, **_arg1, &_arg2); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/key.rb#44
  def to_ast; end

  # Coerce macro to a rule
  #
  # @api private
  # @return [Dry::Logic::Rule]
  #
  # source://dry-schema//lib/dry/schema/macros/key.rb#35
  def to_rule; end
end

# Macro used to specify predicates for a value that can be `nil`
#
# @api private
#
# source://dry-schema//lib/dry/schema/macros/maybe.rb#10
class Dry::Schema::Macros::Maybe < ::Dry::Schema::Macros::DSL
  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/maybe.rb#11
  def call(*args, **opts, &block); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/maybe.rb#28
  def to_ast; end
end

# A Key specialization used for keys that can be skipped
#
# @api private
#
# source://dry-schema//lib/dry/schema/macros/optional.rb#10
class Dry::Schema::Macros::Optional < ::Dry::Schema::Macros::Key
  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/optional.rb#11
  def operation; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/optional.rb#16
  def to_rule; end
end

# A Key specialization used for keys that must be present
#
# @api private
#
# source://dry-schema//lib/dry/schema/macros/required.rb#10
class Dry::Schema::Macros::Required < ::Dry::Schema::Macros::Key
  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/required.rb#11
  def operation; end
end

# Macro used to specify a nested schema
#
# @api private
#
# source://dry-schema//lib/dry/schema/macros/schema.rb#10
class Dry::Schema::Macros::Schema < ::Dry::Schema::Macros::Value
  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/schema.rb#11
  def call(*args, &block); end

  private

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/schema.rb#58
  def define(*args, &block); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/schema.rb#35
  def hash_type; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/schema.rb#40
  def merge_operation_types(op); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/macros/schema.rb#87
  def optional?; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/schema.rb#82
  def parent_type; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/schema.rb#30
  def process_operation(op); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/macros/schema.rb#97
  def redefined_schema?(args); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/macros/schema.rb#92
  def schema?; end
end

# A macro used for specifying predicates to be applied to values from a hash
#
# @api private
#
# source://dry-schema//lib/dry/schema/macros/value.rb#14
class Dry::Schema::Macros::Value < ::Dry::Schema::Macros::DSL
  # @api private
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/macros/value.rb#74
  def array_type?(type); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/value.rb#89
  def build_array_type(array_type, member); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/value.rb#15
  def call(*args, **opts, &block); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/macros/value.rb#79
  def hash_type?(type); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/value.rb#103
  def import_steps(schema); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/macros/value.rb#84
  def maybe_type?(type); end

  private

  # @api private
  #
  # source://dry-schema//lib/dry/schema/macros/value.rb#115
  def method_missing(meth, *args, &block); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/macros/value.rb#108
  def respond_to_missing?(meth, include_private = T.unsafe(nil)); end
end

# Message objects used by message sets
#
# @api public
#
# source://dry-schema//lib/dry/schema/message.rb#10
class Dry::Schema::Message
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Initializer::Mixin::Root
  extend ::Dry::Initializer

  # See which message is higher in the hierarchy
  #
  # @api private
  #
  # source://dry-schema//lib/dry/schema/message.rb#92
  def <=>(other); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message.rb#104
  def _path; end

  # Dump the message to a representation suitable for the message set hash
  #
  # @api public
  # @return [String, Hash]
  #
  # source://dry-schema//lib/dry/schema/message.rb#50
  def dump; end

  # See if another message is the same
  #
  # If a string is passed, it will be compared with the text
  #
  # @api private
  # @param other [Message, String]
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/message.rb#77
  def eql?(other); end

  # Dump the message into a hash
  #
  # The hash will be deeply nested if the path's size is greater than 1
  #
  # @api public
  # @return [Hash]
  # @see Message#to_h
  #
  # source://dry-schema//lib/dry/schema/message.rb#64
  def to_h; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message.rb#82
  def to_or(root); end

  # Dump the message to a representation suitable for the message set hash
  #
  # @api public
  # @return [String, Hash]
  #
  # source://dry-schema//lib/dry/schema/message.rb#50
  def to_s; end
end

# Hints extension for Or messages
#
# @api public
# @see Message::Or
#
# source://dry-schema//lib/dry/schema/message/or.rb#9
module Dry::Schema::Message::Or
  class << self
    # @api private
    #
    # source://dry-schema//lib/dry/schema/message/or.rb#11
    def [](left, right, messages); end
  end
end

# A message type used by OR operations
#
# @abstract
# @api private
#
# source://dry-schema//lib/dry/schema/message/or/abstract.rb#12
class Dry::Schema::Message::Or::Abstract
  # @api private
  # @return [Abstract] a new instance of Abstract
  #
  # source://dry-schema//lib/dry/schema/message/or/abstract.rb#20
  def initialize(left, right); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message/or/abstract.rb#14
  def left; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message/or/abstract.rb#17
  def right; end
end

# A message type used by OR operations with different paths
#
# @api public
#
# source://dry-schema//lib/dry/schema/message/or/multi_path.rb#11
class Dry::Schema::Message::Or::MultiPath < ::Dry::Schema::Message::Or::Abstract
  # @api private
  #
  # source://dry-schema//lib/dry/schema/message/or/multi_path.rb#67
  def _path; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message/or/multi_path.rb#72
  def _paths; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message/or/multi_path.rb#52
  def messages; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message/or/multi_path.rb#62
  def path; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message/or/multi_path.rb#57
  def root; end

  # @api public
  #
  # source://dry-schema//lib/dry/schema/message/or/multi_path.rb#47
  def to_h; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message/or/multi_path.rb#77
  def to_or(root); end

  private

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message/or/multi_path.rb#84
  def _messages; end

  class << self
    # @api private
    #
    # source://dry-schema//lib/dry/schema/message/or/multi_path.rb#37
    def handler(message); end
  end
end

# @api public
#
# source://dry-schema//lib/dry/schema/message/or/multi_path.rb#34
Dry::Schema::Message::Or::MultiPath::MESSAGE_ARRAY_HANDLER = T.let(T.unsafe(nil), Proc)

# @api private
#
# source://dry-schema//lib/dry/schema/message/or/multi_path.rb#12
class Dry::Schema::Message::Or::MultiPath::MessageArray
  # @api private
  # @return [MessageArray] a new instance of MessageArray
  #
  # source://dry-schema//lib/dry/schema/message/or/multi_path.rb#14
  def initialize(messages); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message/or/multi_path.rb#19
  def _paths; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message/or/multi_path.rb#29
  def to_h; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message/or/multi_path.rb#24
  def to_or(root); end
end

# A message type used by OR operations with the same path
#
# @api public
#
# source://dry-schema//lib/dry/schema/message/or/single_path.rb#11
class Dry::Schema::Message::Or::SinglePath < ::Dry::Schema::Message::Or::Abstract
  # @api private
  # @return [SinglePath] a new instance of SinglePath
  #
  # source://dry-schema//lib/dry/schema/message/or/single_path.rb#21
  def initialize(*args, messages); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message/or/single_path.rb#15
  def _path; end

  # Dump a message into a string
  #
  # Both sides of the message will be joined using translated
  # value under `dry_schema.or` message key
  #
  # @api public
  # @return [String]
  # @see Message#dump
  #
  # source://dry-schema//lib/dry/schema/message/or/single_path.rb#39
  def dump; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message/or/single_path.rb#18
  def messages; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message/or/single_path.rb#12
  def path; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message/or/single_path.rb#56
  def to_a; end

  # Dump an `or` message into a hash
  #
  # @api public
  # @return [String]
  # @see Message#to_h
  #
  # source://dry-schema//lib/dry/schema/message/or/single_path.rb#51
  def to_h; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message/or/single_path.rb#61
  def to_or(root); end

  # Dump a message into a string
  #
  # Both sides of the message will be joined using translated
  # value under `dry_schema.or` message key
  #
  # @api public
  # @return [String]
  # @see Message#dump
  #
  # source://dry-schema//lib/dry/schema/message/or/single_path.rb#39
  def to_s; end
end

# Compiles rule results AST into human-readable format
#
# @api private
#
# source://dry-schema//lib/dry/schema/message_compiler.rb#11
class Dry::Schema::MessageCompiler
  include ::Dry::Initializer::Mixin::Root
  extend ::Dry::Initializer

  # @api private
  # @return [MessageCompiler] a new instance of MessageCompiler
  #
  # source://dry-schema//lib/dry/schema/message_compiler.rb#48
  def initialize(messages, **options); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler.rb#225
  def append_mapped_size_tokens(tokens); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler.rb#66
  def call(ast); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler.rb#45
  def default_lookup_options; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler.rb#190
  def lookup_options(arg_vals:, input:); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler.rb#198
  def message_text(template, tokens, options); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler.rb#209
  def message_tokens(args); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler.rb#162
  def message_type(*_arg0); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler.rb#43
  def options; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler.rb#119
  def or_translator; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler.rb#76
  def visit(node, opts = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler.rb#97
  def visit_and(node, opts); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler.rb#81
  def visit_failure(node, opts); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler.rb#87
  def visit_hint(*_arg0); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler.rb#178
  def visit_implication(node, *args); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler.rb#167
  def visit_key(node, opts); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler.rb#127
  def visit_namespace(node, opts); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler.rb#92
  def visit_not(node, opts); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler.rb#113
  def visit_or(node, opts); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler.rb#133
  def visit_predicate(node, opts); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler.rb#173
  def visit_set(node, opts); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler.rb#108
  def visit_unexpected_key(node, opts); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler.rb#184
  def visit_xor(node, opts); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler.rb#55
  def with(new_options); end
end

# @api private
#
# source://dry-schema//lib/dry/schema/message_compiler.rb#23
Dry::Schema::MessageCompiler::DEFAULT_PREDICATE_RESOLVERS = T.let(T.unsafe(nil), Hash)

# @api private
#
# source://dry-schema//lib/dry/schema/message_compiler.rb#27
Dry::Schema::MessageCompiler::EMPTY_MESSAGE_SET = T.let(T.unsafe(nil), Dry::Schema::MessageSet)

# @api private
#
# source://dry-schema//lib/dry/schema/message_compiler.rb#26
Dry::Schema::MessageCompiler::EMPTY_OPTS = T.let(T.unsafe(nil), Dry::Schema::MessageCompiler::VisitorOpts)

# @api private
#
# source://dry-schema//lib/dry/schema/message_compiler.rb#28
Dry::Schema::MessageCompiler::FULL_MESSAGE_WHITESPACE = T.let(T.unsafe(nil), Hash)

# Optimized option hash used by visitor methods in message compiler
#
# @api private
#
# source://dry-schema//lib/dry/schema/message_compiler/visitor_opts.rb#13
class Dry::Schema::MessageCompiler::VisitorOpts < ::Hash
  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler/visitor_opts.rb#28
  def call(other); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler/visitor_opts.rb#50
  def current_messages; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler/visitor_opts.rb#32
  def dup(current_messages = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler/visitor_opts.rb#42
  def failures; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler/visitor_opts.rb#46
  def hints; end

  # @api private
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/message_compiler/visitor_opts.rb#38
  def key_failure?(path); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_compiler/visitor_opts.rb#23
  def path; end

  class << self
    # @api private
    #
    # source://dry-schema//lib/dry/schema/message_compiler/visitor_opts.rb#14
    def new; end
  end
end

# A set of messages used to generate errors
#
# @api public
# @see Result#message_set
#
# source://dry-schema//lib/dry/schema/message_set.rb#12
class Dry::Schema::MessageSet
  include ::Enumerable
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @return [MessageSet] a new instance of MessageSet
  #
  # source://dry-schema//lib/dry/schema/message_set.rb#32
  def initialize(messages, options = T.unsafe(nil)); end

  # Get a list of message texts for the given key
  #
  # @api public
  # @param key [Symbol]
  # @return [Array<String>]
  #
  # source://dry-schema//lib/dry/schema/message_set.rb#71
  def [](key); end

  # Iterate over messages
  #
  # @api public
  # @example
  #   result.errors.each do |message|
  #   puts message.text
  #   end
  # @return [Array]
  #
  # source://dry-schema//lib/dry/schema/message_set.rb#47
  def each(&block); end

  # Check if a message set is empty
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/message_set.rb#93
  def empty?; end

  # Get a list of message texts for the given key
  #
  # @api public
  # @param key [Symbol]
  # @raise KeyError
  # @return [Array<String>]
  #
  # source://dry-schema//lib/dry/schema/message_set.rb#84
  def fetch(key); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_set.rb#98
  def freeze; end

  # A list of compiled message objects
  #
  # @api public
  # @return [Array<Message>]
  #
  # source://dry-schema//lib/dry/schema/message_set.rb#19
  def messages; end

  # Options hash
  #
  # @api public
  # @return [Hash]
  #
  # source://dry-schema//lib/dry/schema/message_set.rb#24
  def options; end

  # Dump message set to a hash
  #
  # @api public
  # @return [Hash<Symbol=>Array<String>>]
  #
  # source://dry-schema//lib/dry/schema/message_set.rb#59
  def to_h; end

  # Dump message set to a hash
  #
  # @api public
  # @return [Hash<Symbol=>Array<String>>]
  #
  # source://dry-schema//lib/dry/schema/message_set.rb#59
  def to_hash; end

  private

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_set.rb#112
  def combine_message_hashes(hashes); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_set.rb#121
  def combine_message_values(values); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_set.rb#107
  def messages_map(messages = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/message_set.rb#136
  def partition_message_values(values); end

  class << self
    # @api private
    #
    # source://dry-schema//lib/dry/schema/message_set.rb#27
    def [](messages, options = T.unsafe(nil)); end
  end
end

# An API for configuring message backends
#
# @api private
#
# source://dry-schema//lib/dry/schema/messages.rb#8
module Dry::Schema::Messages
  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages.rb#16
  def setup(config); end

  class << self
    # source://dry-schema//lib/dry/schema/messages.rb#16
    def setup(config); end
  end
end

# Abstract class for message backends
#
# @api public
#
# source://dry-schema//lib/dry/schema/messages/abstract.rb#14
class Dry::Schema::Messages::Abstract
  include ::Dry::Configurable::Initializer
  include ::Dry::Core::Constants
  include ::Dry::Configurable
  include ::Dry::Configurable::Methods
  include ::Dry::Configurable::InstanceMethods
  include ::Dry::Core::Equalizer::Methods
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods

  # Retrieve a message template
  #
  # @api public
  # @return [Template]
  #
  # source://dry-schema//lib/dry/schema/messages/abstract.rb#91
  def [](predicate, options); end

  # Retrieve a message template
  #
  # @api public
  # @return [Template]
  #
  # source://dry-schema//lib/dry/schema/messages/abstract.rb#91
  def call(predicate, options); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/abstract.rb#169
  def default_locale; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/abstract.rb#141
  def filled_lookup_paths(tokens); end

  # @api private
  # @raise [NotImplementedError]
  #
  # source://dry-schema//lib/dry/schema/messages/abstract.rb#174
  def interpolatable_data(_key, _options, **_data); end

  # @api private
  # @raise [NotImplementedError]
  #
  # source://dry-schema//lib/dry/schema/messages/abstract.rb#179
  def interpolate(_key, _options, **_data); end

  # Check if given key is defined
  #
  # @api public
  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/messages/abstract.rb#117
  def key?(_key, _options = T.unsafe(nil)); end

  # Retrieve an array of looked up paths
  #
  # @api public
  # @param predicate [Symbol]
  # @param options [Hash]
  # @return [String]
  #
  # source://dry-schema//lib/dry/schema/messages/abstract.rb#129
  def looked_up_paths(predicate, options); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/abstract.rb#135
  def lookup_paths(predicate, options); end

  # Return a new message backend that will look for messages under provided namespace
  #
  # @api public
  # @param namespace [Symbol, String]
  #
  # source://dry-schema//lib/dry/schema/messages/abstract.rb#155
  def namespaced(namespace); end

  # Return root path to messages file
  #
  # @api public
  # @return [Pathname]
  #
  # source://dry-schema//lib/dry/schema/messages/abstract.rb#164
  def root; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/abstract.rb#78
  def rule(name, options = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/abstract.rb#146
  def rule_lookup_paths(tokens); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/abstract.rb#73
  def translate(key, locale: T.unsafe(nil)); end

  private

  # @api private
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/messages/abstract.rb#197
  def custom_top_namespace?(path); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/abstract.rb#186
  def lookup_tokens(predicate, options); end

  class << self
    # @api private
    #
    # source://dry-schema//lib/dry/schema/messages/abstract.rb#52
    def build(options = T.unsafe(nil)); end

    # @api private
    #
    # source://dry-schema//lib/dry/schema/messages/abstract.rb#47
    def setting_names; end
  end
end

# @api private
#
# source://dry-schema//lib/dry/schema/messages.rb#9
Dry::Schema::Messages::BACKENDS = T.let(T.unsafe(nil), Hash)

# Namespaced messages backend
#
# @api public
#
# source://dry-schema//lib/dry/schema/messages/namespaced.rb#10
class Dry::Schema::Messages::Namespaced < ::Dry::Schema::Messages::Abstract
  # @api private
  # @return [Namespaced] a new instance of Namespaced
  #
  # source://dry-schema//lib/dry/schema/messages/namespaced.rb#23
  def initialize(namespace, messages); end

  # @api public
  #
  # source://dry-schema//lib/dry/schema/messages/namespaced.rb#44
  def [](key, options = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/namespaced.rb#72
  def cache_key(predicate, options); end

  # @api public
  #
  # source://dry-schema//lib/dry/schema/messages/namespaced.rb#44
  def call(key, options = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/namespaced.rb#20
  def call_opts; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/namespaced.rb#17
  def config; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/namespaced.rb#59
  def filled_lookup_paths(tokens); end

  # Get a message for the given key and its options
  #
  # @api public
  # @param key [Symbol]
  # @param options [Hash]
  # @return [String]
  #
  # source://dry-schema//lib/dry/schema/messages/namespaced.rb#39
  def get(key, options = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/namespaced.rb#77
  def interpolatable_data(key, options, **data); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/namespaced.rb#82
  def interpolate(key, options, **data); end

  # Check if given key is defined
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/messages/namespaced.rb#54
  def key?(key, *args); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/namespaced.rb#14
  def messages; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/namespaced.rb#11
  def namespace; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/namespaced.rb#64
  def rule_lookup_paths(tokens); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/namespaced.rb#87
  def translate(key, **args); end
end

# @api private
#
# source://dry-schema//lib/dry/schema/messages/template.rb#12
class Dry::Schema::Messages::Template
  include ::Dry::Initializer::Mixin::Root
  include ::Dry::Core::Equalizer::Methods
  extend ::Dry::Initializer

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/template.rb#27
  def [](data = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/template.rb#27
  def call(data = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/template.rb#21
  def data(data = T.unsafe(nil)); end

  private

  # @api private
  # @raise [KeyError]
  #
  # source://dry-schema//lib/dry/schema/messages/template.rb#35
  def ensure_message!; end
end

# Plain YAML message backend
#
# @api public
#
# source://dry-schema//lib/dry/schema/messages/yaml.rb#14
class Dry::Schema::Messages::YAML < ::Dry::Schema::Messages::Abstract
  # @api private
  # @return [YAML] a new instance of YAML
  #
  # source://dry-schema//lib/dry/schema/messages/yaml.rb#84
  def initialize(data: T.unsafe(nil), config: T.unsafe(nil)); end

  # Loaded localized message templates
  #
  # @api public
  # @return [Hash]
  #
  # source://dry-schema//lib/dry/schema/messages/yaml.rb#28
  def data; end

  # Get a message for the given key and its options
  #
  # @api public
  # @param key [Symbol]
  # @param options [Hash]
  # @return [String]
  #
  # source://dry-schema//lib/dry/schema/messages/yaml.rb#111
  def get(key, options = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/yaml.rb#152
  def interpolatable_data(key, options, **data); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/yaml.rb#158
  def interpolate(key, options, **data); end

  # Check if given key is defined
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/messages/yaml.rb#120
  def key?(key, options = T.unsafe(nil)); end

  # Get an array of looked up paths
  #
  # @api public
  # @param predicate [Symbol]
  # @param options [Hash]
  # @return [String]
  #
  # source://dry-schema//lib/dry/schema/messages/yaml.rb#99
  def looked_up_paths(predicate, options); end

  # Merge messages from an additional path
  #
  # @api public
  # @param overrides [String]
  # @return [Messages::I18n]
  #
  # source://dry-schema//lib/dry/schema/messages/yaml.rb#131
  def merge(overrides); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/yaml.rb#146
  def prepare; end

  # Translation function
  #
  # @api public
  # @return [Proc]
  #
  # source://dry-schema//lib/dry/schema/messages/yaml.rb#33
  def t; end

  private

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/yaml.rb#185
  def cache; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/yaml.rb#201
  def evaluated_key(key, options); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/yaml.rb#166
  def evaluation_context(key, options); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/messages/yaml.rb#190
  def load_translations(path); end

  class << self
    # @api private
    #
    # source://dry-schema//lib/dry/schema/messages/yaml.rb#36
    def build(options = T.unsafe(nil)); end

    # @api private
    #
    # source://dry-schema//lib/dry/schema/messages/yaml.rb#72
    def cache; end

    # @api private
    #
    # source://dry-schema//lib/dry/schema/messages/yaml.rb#50
    def flat_hash(hash, path = T.unsafe(nil), keys = T.unsafe(nil)); end

    # @api private
    #
    # source://dry-schema//lib/dry/schema/messages/yaml.rb#79
    def source_cache; end
  end
end

# @api public
#
# source://dry-schema//lib/dry/schema/messages/yaml.rb#17
Dry::Schema::Messages::YAML::EMPTY_CONTEXT = T.let(T.unsafe(nil), Binding)

# @api public
#
# source://dry-schema//lib/dry/schema/messages/yaml.rb#15
Dry::Schema::Messages::YAML::LOCALE_TOKEN = T.let(T.unsafe(nil), String)

# @api public
#
# source://dry-schema//lib/dry/schema/messages/yaml.rb#16
Dry::Schema::Messages::YAML::TOKEN_REGEXP = T.let(T.unsafe(nil), Regexp)

# An error raised when a localized message cannot be found
#
# @api public
#
# source://dry-schema//lib/dry/schema/constants.rb#36
class Dry::Schema::MissingMessageError < ::StandardError
  # source://dry-schema//lib/dry/schema/constants.rb#38
  def initialize(path, paths = T.unsafe(nil)); end
end

# A special rule type that is configured under a specified namespace
#
# This is used internally to create rules that can be properly handled
# by the message compiler in situations where a schema reuses another schema
# but it is configured to use a message namespace
#
# @api private
#
# source://dry-schema//lib/dry/schema/namespaced_rule.rb#12
class Dry::Schema::NamespacedRule
  # @api private
  # @return [NamespacedRule] a new instance of NamespacedRule
  #
  # source://dry-schema//lib/dry/schema/namespaced_rule.rb#20
  def initialize(namespace, rule); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/namespaced_rule.rb#32
  def ast(input = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/namespaced_rule.rb#26
  def call(input); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/namespaced_rule.rb#17
  def namespace; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/namespaced_rule.rb#14
  def rule; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/namespaced_rule.rb#32
  def to_ast(input = T.unsafe(nil)); end
end

# Params schema type
#
# @api public
# @see Processor
# @see Schema#Params
#
# source://dry-schema//lib/dry/schema/params.rb#11
class Dry::Schema::Params < ::Dry::Schema::Processor; end

# Path represents a list of keys in a hash
#
# @api private
#
# source://dry-schema//lib/dry/schema/path.rb#10
class Dry::Schema::Path
  include ::Dry::Core::Equalizer::Methods
  include ::Comparable
  include ::Enumerable

  # @api private
  # @return [Path] a new instance of Path
  #
  # source://dry-schema//lib/dry/schema/path.rb#57
  def initialize(keys); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/path.rb#88
  def &(other); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/path.rb#79
  def <=>(other); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/path.rb#69
  def each(&block); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/path.rb#74
  def include?(other); end

  # @api private
  # @return [Array<Symbol>]
  #
  # source://dry-schema//lib/dry/schema/path.rb#16
  def keys; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/path.rb#95
  def last; end

  # @api private
  def root(*_arg0); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/path.rb#100
  def same_root?(other); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/path.rb#62
  def to_h(value = T.unsafe(nil)); end

  class << self
    # @api private
    #
    # source://dry-schema//lib/dry/schema/path.rb#43
    def [](spec); end

    # Coerce a spec into a path object
    #
    # @api private
    # @param spec [Path, Symbol, String, Hash, Array<Symbol>]
    # @return [Path]
    #
    # source://dry-schema//lib/dry/schema/path.rb#27
    def call(spec); end

    # Extract a list of keys from a hash
    #
    # @api private
    #
    # source://dry-schema//lib/dry/schema/path.rb#50
    def keys_from_hash(hash); end
  end
end

# @api private
#
# source://dry-schema//lib/dry/schema/path.rb#104
Dry::Schema::Path::EMPTY = T.let(T.unsafe(nil), Dry::Schema::Path)

# Predicate objects used within the DSL
#
# @api public
#
# source://dry-schema//lib/dry/schema/predicate.rb#11
class Dry::Schema::Predicate
  include ::Dry::Logic::Operators
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @return [Predicate] a new instance of Predicate
  #
  # source://dry-schema//lib/dry/schema/predicate.rb#56
  def initialize(compiler, name, args, block); end

  # Negate a predicate
  #
  # @api public
  # @example
  #   required(:name).value(:string) { !empty? }
  # @return [Negation]
  #
  # source://dry-schema//lib/dry/schema/predicate.rb#73
  def !; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/predicate.rb#47
  def args; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/predicate.rb#50
  def arity; end

  # Dump predicate to an AST
  #
  # @api private
  # @return [Array]
  #
  # source://dry-schema//lib/dry/schema/predicate.rb#96
  def ast(*_arg0); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/predicate.rb#53
  def block; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/predicate.rb#41
  def compiler; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/predicate.rb#78
  def ensure_valid; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/predicate.rb#44
  def name; end

  # Dump predicate to an AST
  #
  # @api private
  # @return [Array]
  #
  # source://dry-schema//lib/dry/schema/predicate.rb#96
  def to_ast(*_arg0); end

  # Compile predicate to a rule object
  #
  # @api private
  #
  # source://dry-schema//lib/dry/schema/predicate.rb#87
  def to_rule; end
end

# A negated predicate
#
# @api private
#
# source://dry-schema//lib/dry/schema/predicate.rb#15
class Dry::Schema::Predicate::Negation
  include ::Dry::Logic::Operators

  # @api private
  # @return [Negation] a new instance of Negation
  #
  # source://dry-schema//lib/dry/schema/predicate.rb#22
  def initialize(predicate); end

  # Dump negated predicate to an AST
  #
  # @api private
  # @return [Array]
  #
  # source://dry-schema//lib/dry/schema/predicate.rb#31
  def ast(*_arg0, **_arg1, &_arg2); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/predicate.rb#19
  def predicate; end

  # Dump negated predicate to an AST
  #
  # @api private
  # @return [Array]
  #
  # source://dry-schema//lib/dry/schema/predicate.rb#31
  def to_ast(*_arg0, **_arg1, &_arg2); end
end

# @api private
#
# source://dry-schema//lib/dry/schema/predicate_inferrer.rb#6
class Dry::Schema::PredicateInferrer < ::Dry::Types::PredicateInferrer
  # @api private
  # @return [PredicateInferrer] a new instance of PredicateInferrer
  #
  # source://dry-schema//lib/dry/schema/predicate_inferrer.rb#9
  def initialize(registry = T.unsafe(nil)); end
end

# @api private
#
# source://dry-schema//lib/dry/schema/predicate_inferrer.rb#7
class Dry::Schema::PredicateInferrer::Compiler < ::Dry::Types::PredicateInferrer::Compiler; end

# A registry with predicate objects from `Dry::Logic::Predicates`
#
# @api private
#
# source://dry-schema//lib/dry/schema/predicate_registry.rb#9
class Dry::Schema::PredicateRegistry < ::Dry::Types::PredicateRegistry
  # @api private
  #
  # source://dry-schema//lib/dry/schema/predicate_registry.rb#10
  def arg_list(name, *values); end
end

# @api private
#
# source://dry-schema//lib/dry/schema/primitive_inferrer.rb#6
class Dry::Schema::PrimitiveInferrer < ::Dry::Types::PrimitiveInferrer
  # @api private
  # @return [PrimitiveInferrer] a new instance of PrimitiveInferrer
  #
  # source://dry-schema//lib/dry/schema/primitive_inferrer.rb#9
  def initialize; end
end

# @api private
#
# source://dry-schema//lib/dry/schema/primitive_inferrer.rb#7
class Dry::Schema::PrimitiveInferrer::Compiler < ::Dry::Types::PrimitiveInferrer::Compiler; end

# Processes input data using objects configured within the DSL
# Processing is split into steps represented by `ProcessorSteps`.
#
# @api public
# @see ProcessorSteps
# @see Params
# @see JSON
#
# source://dry-schema//lib/dry/schema/processor.rb#15
class Dry::Schema::Processor
  include ::Dry::Initializer::Mixin::Root
  include ::Dry::Logic::Operators
  include ::Dry::Schema::Info::SchemaMethods
  extend ::Dry::Initializer
  extend ::Dry::Core::Constants
  extend ::Dry::Configurable
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods

  # Apply processing steps to the provided input
  #
  # @api public
  # @param input [Hash]
  # @return [Result]
  #
  # source://dry-schema//lib/dry/schema/processor.rb#77
  def [](input); end

  # @api public
  # @raise [NotImplementedError]
  #
  # source://dry-schema//lib/dry/schema/processor.rb#85
  def ^(_other); end

  # Return AST representation of the rules
  #
  # @api private
  #
  # source://dry-schema//lib/dry/schema/processor.rb#168
  def ast(*_arg0); end

  # Apply processing steps to the provided input
  #
  # @api public
  # @param input [Hash]
  # @return [Result]
  #
  # source://dry-schema//lib/dry/schema/processor.rb#77
  def call(input); end

  # Return the rules config
  #
  # @api private
  # @return [Dry::Types::Config]
  #
  # source://dry-schema//lib/dry/schema/processor.rb#161
  def config; end

  # Check if there are filter rules
  #
  # @api private
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/processor.rb#201
  def filter_rules?; end

  # Return filter schema
  #
  # @api private
  #
  # source://dry-schema//lib/dry/schema/processor.rb#208
  def filter_schema; end

  # Return string representation
  #
  # @api public
  # @return [String]
  #
  # source://dry-schema//lib/dry/schema/processor.rb#115
  def inspect; end

  # Return the key map
  #
  # @api public
  # @return [KeyMap]
  #
  # source://dry-schema//lib/dry/schema/processor.rb#126
  def key_map; end

  # Merge with another schema
  #
  # @api public
  # @param other [Processor]
  # @return [Processor, Params, JSON]
  #
  # source://dry-schema//lib/dry/schema/processor.rb#97
  def merge(other); end

  # Return the message compiler
  #
  # @api private
  # @return [MessageCompiler]
  #
  # source://dry-schema//lib/dry/schema/processor.rb#178
  def message_compiler; end

  # Return the rule applier
  #
  # @api private
  #
  # source://dry-schema//lib/dry/schema/processor.rb#151
  def rule_applier; end

  # Return the rules from rule applier
  #
  # @api private
  # @return [MessageCompiler]
  #
  # source://dry-schema//lib/dry/schema/processor.rb#187
  def rules; end

  # Return type schema used when composing subschemas
  #
  # @api private
  # @return [Dry::Types::Schema]
  #
  # source://dry-schema//lib/dry/schema/processor.rb#144
  def strict_type_schema; end

  # Return AST representation of the rules
  #
  # @api private
  #
  # source://dry-schema//lib/dry/schema/processor.rb#168
  def to_ast(*_arg0); end

  # Return a proc that acts like a schema object
  #
  # @api public
  # @return [Proc]
  #
  # source://dry-schema//lib/dry/schema/processor.rb#106
  def to_proc; end

  # Return the rule applier
  #
  # @api private
  #
  # source://dry-schema//lib/dry/schema/processor.rb#151
  def to_rule; end

  # Return the type schema
  #
  # @api private
  # @return [Dry::Types::Lax]
  #
  # source://dry-schema//lib/dry/schema/processor.rb#135
  def type_schema; end

  # Return the types from the schema DSL
  #
  # @api private
  #
  # source://dry-schema//lib/dry/schema/processor.rb#194
  def types; end

  # @api public
  # @raise [NotImplementedError]
  #
  # source://dry-schema//lib/dry/schema/processor.rb#85
  def xor(_other); end

  class << self
    # Define a schema for your processor class
    #
    # @api public
    # @return [Class]
    # @see Schema#define
    # @see Schema#Params
    # @see Schema#JSON
    #
    # source://dry-schema//lib/dry/schema/processor.rb#45
    def define(&block); end

    # Return DSL configured via #define
    #
    # @api private
    # @return [DSL]
    #
    # source://dry-schema//lib/dry/schema/processor.rb#34
    def definition; end

    # Build a new processor object
    #
    # @api public
    # @return [Processor]
    #
    # source://dry-schema//lib/dry/schema/processor.rb#57
    def new(options = T.unsafe(nil), &block); end
  end
end

# Steps for the Dry::Schema::Processor
#
# There are 4 main steps:
#
#   1. `key_coercer` - Prepare input hash using a key map
#   2. `filter_schema` - Apply pre-coercion filtering rules
#      (optional step, used only when `filter` was used)
#   3. `value_coercer` - Apply value coercions based on type specifications
#   4. `rule_applier` - Apply rules
#
# @api public
# @see Processor
#
# source://dry-schema//lib/dry/schema/processor_steps.rb#21
class Dry::Schema::ProcessorSteps
  include ::Dry::Initializer::Mixin::Root
  extend ::Dry::Initializer

  # Returns step by name
  #
  # @api public
  # @param name [Symbol] The step name
  #
  # source://dry-schema//lib/dry/schema/processor_steps.rb#65
  def [](name); end

  # Sets step by name
  #
  # @api public
  # @param name [Symbol] The step name
  #
  # source://dry-schema//lib/dry/schema/processor_steps.rb#74
  def []=(name, value); end

  # Add passed block before mentioned step
  #
  # @api public
  # @param name [Symbol] The step name
  # @return [ProcessorSteps]
  #
  # source://dry-schema//lib/dry/schema/processor_steps.rb#85
  def after(name, &block); end

  # Add passed block before mentioned step
  #
  # @api public
  # @param name [Symbol] The step name
  # @return [ProcessorSteps]
  #
  # source://dry-schema//lib/dry/schema/processor_steps.rb#99
  def before(name, &block); end

  # Executes steps and callbacks in order
  #
  # @api public
  # @param result [Result]
  # @return [Result]
  #
  # source://dry-schema//lib/dry/schema/processor_steps.rb#35
  def call(result); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/processor_steps.rb#128
  def import_callbacks(path, other); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/processor_steps.rb#51
  def key_map; end

  # Stacks callback steps and returns new ProcessorSteps instance
  #
  # @api public
  # @param other [ProcessorSteps]
  # @return [ProcessorSteps]
  #
  # source://dry-schema//lib/dry/schema/processor_steps.rb#113
  def merge(other); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/processor_steps.rb#121
  def merge_callbacks(left, right); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/processor_steps.rb#46
  def rule_applier; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/processor_steps.rb#56
  def type_schema; end
end

# @api public
#
# source://dry-schema//lib/dry/schema/constants.rb#14
Dry::Schema::QUESTION_MARK = T.let(T.unsafe(nil), String)

# Processing result
#
# @api public
# @see Processor#call
#
# source://dry-schema//lib/dry/schema/result.rb#13
class Dry::Schema::Result
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Initializer::Mixin::Root
  extend ::Dry::Initializer

  # Read value from the output hash
  #
  # @api public
  # @param name [Symbol]
  # @return [Object]
  #
  # source://dry-schema//lib/dry/schema/result.rb#110
  def [](name); end

  # Add a new error AST node
  #
  # @api private
  #
  # source://dry-schema//lib/dry/schema/result.rb#198
  def add_error(node); end

  # Return a new result scoped to a specific path
  #
  # @api private
  # @param path [Symbol, Array, Path]
  # @return [Result]
  #
  # source://dry-schema//lib/dry/schema/result.rb#46
  def at(at_path, &block); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/result.rb#98
  def concat(other); end

  # Pattern matching support
  #
  # @api private
  #
  # source://dry-schema//lib/dry/schema/result.rb#191
  def deconstruct_keys(_); end

  # Check if there's an error for the provided spec
  #
  # @api public
  # @param spec [Symbol, Hash<Symbol=>Symbol>]
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/result.rb#132
  def error?(spec); end

  # Get human-readable error representation
  #
  # @api public
  # @return [MessageSet]
  # @see #message_set
  #
  # source://dry-schema//lib/dry/schema/result.rb#161
  def errors(options = T.unsafe(nil)); end

  # Check if the result is not successful
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/result.rb#150
  def failure?; end

  # Return a string representation of the result
  #
  # @api public
  # @return [String]
  #
  # source://dry-schema//lib/dry/schema/result.rb#184
  def inspect; end

  # Check if a given key is present in the output
  #
  # @api public
  # @param name [Symbol]
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/result.rb#121
  def key?(name); end

  # Return the message set
  #
  # @api public
  # @option options
  # @option options
  # @option options
  # @param options [Hash]
  # @return [MessageSet]
  #
  # source://dry-schema//lib/dry/schema/result.rb#175
  def message_set(options = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/result.rb#51
  def new(output, **opts, &block); end

  # Dump result to a hash returning processed and validated data
  #
  # @api private
  # @return [Hash]
  #
  # source://dry-schema//lib/dry/schema/result.rb#77
  def output; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/result.rb#68
  def path; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/result.rb#83
  def replace(value); end

  # Check if the result is successful
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/result.rb#141
  def success?; end

  # Dump result to a hash returning processed and validated data
  #
  # @api private
  # @return [Hash]
  #
  # source://dry-schema//lib/dry/schema/result.rb#77
  def to_h; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/result.rb#62
  def update(hash); end

  class << self
    # @api private
    # @yield [result]
    #
    # source://dry-schema//lib/dry/schema/result.rb#33
    def new(*_arg0, **_arg1); end
  end
end

# Applies rules defined within the DSL
#
# @api private
#
# source://dry-schema//lib/dry/schema/rule_applier.rb#11
class Dry::Schema::RuleApplier
  include ::Dry::Initializer::Mixin::Root
  extend ::Dry::Initializer

  # @api private
  #
  # source://dry-schema//lib/dry/schema/rule_applier.rb#24
  def call(input); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/rule_applier.rb#38
  def to_ast; end
end

# core processor steps in the default execution order
#
# @api public
#
# source://dry-schema//lib/dry/schema/constants.rb#18
Dry::Schema::STEPS_IN_ORDER = T.let(T.unsafe(nil), Array)

# @api private
#
# source://dry-schema//lib/dry/schema/step.rb#8
class Dry::Schema::Step
  # @api private
  # @return [Step] a new instance of Step
  #
  # source://dry-schema//lib/dry/schema/step.rb#22
  def initialize(type:, name:, executor:, path: T.unsafe(nil)); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/step.rb#31
  def call(result); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/step.rb#16
  def executor; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/step.rb#10
  def name; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/step.rb#19
  def path; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/step.rb#40
  def scoped(parent_path); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/step.rb#13
  def type; end

  private

  # @api private
  # @raise [ArgumentError]
  #
  # source://dry-schema//lib/dry/schema/step.rb#52
  def validate_name(name); end
end

# Captures predicates defined within the DSL
#
# @api private
#
# source://dry-schema//lib/dry/schema/trace.rb#8
class Dry::Schema::Trace < ::BasicObject
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @return [Trace] a new instance of Trace
  #
  # source://dry-schema//lib/dry/schema/trace.rb#22
  def initialize(compiler = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/trace.rb#54
  def <<(op); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/trace.rb#54
  def append(op); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/trace.rb#19
  def captures; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/trace.rb#77
  def class; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/trace.rb#16
  def compiler; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/trace.rb#28
  def evaluate(*args, **opts); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/trace.rb#39
  def evaluate_predicates(predicates); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/trace.rb#72
  def to_ast; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/trace.rb#61
  def to_rule(name = T.unsafe(nil)); end

  private

  # @api private
  #
  # source://dry-schema//lib/dry/schema/trace.rb#93
  def method_missing(meth, *args, &block); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/trace.rb#84
  def reduced_rule; end

  # @api private
  # @return [Boolean]
  #
  # source://dry-schema//lib/dry/schema/trace.rb#88
  def respond_to_missing?(meth, include_private = T.unsafe(nil)); end
end

# @api private
#
# source://dry-schema//lib/dry/schema/trace.rb#9
Dry::Schema::Trace::INVALID_PREDICATES = T.let(T.unsafe(nil), Array)

# A class to build containers for custom types, which can be used in schemas
#
# @api public
# @example
#   MyTypeContainer = Dry::Schema::TypeContainer.new
#   MyTypeContainer.register('params.fancy_string', Types::FancyString)
#
# source://dry-schema//lib/dry/schema/type_container.rb#15
class Dry::Schema::TypeContainer
  include ::Dry::Core::Container::Mixin::Initializer
  include ::Dry::Core::Container::Mixin
  extend ::Dry::Core::Container::Configuration
  extend ::Dry::Core::Constants
  extend ::Dry::Configurable
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods

  # @api public
  # @return [TypeContainer] a new instance of TypeContainer
  #
  # source://dry-core/1.0.1/lib/dry/core/container/mixin.rb#71
  def initialize(*args, &block); end

  # source://dry-core/1.0.1/lib/dry/core/container/mixin.rb#83
  def config; end

  # @api public
  #
  # source://dry-core/1.0.1/lib/dry/core/container/mixin.rb#181
  def registered?(key); end
end

# A simple wrapper around Dry::Types registry
#
# This is used internally by specialized processor sub-classes
#
# @api private
#
# source://dry-schema//lib/dry/schema/type_registry.rb#13
class Dry::Schema::TypeRegistry
  # @api private
  # @return [TypeRegistry] a new instance of TypeRegistry
  #
  # source://dry-schema//lib/dry/schema/type_registry.rb#26
  def initialize(types, namespace = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/type_registry.rb#37
  def [](name); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/type_registry.rb#18
  def namespace; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/type_registry.rb#32
  def namespaced(ns); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/type_registry.rb#15
  def types; end

  class << self
    # @api private
    #
    # source://dry-schema//lib/dry/schema/type_registry.rb#21
    def new(types = T.unsafe(nil), namespace = T.unsafe(nil)); end
  end
end

# Schema's own type registry
#
# @api public
#
# source://dry-schema//lib/dry/schema/types.rb#10
module Dry::Schema::Types
  extend ::Dry::Types::BuilderMethods
  extend ::Dry::Core::Deprecations::Interface

  mixes_in_class_methods ::Dry::Types::BuilderMethods
end

# Combines multiple logical operations into a single type, taking into
# account the type of logical operation (or, and, implication) and the
# underlying types (schemas, nominals, etc.)
#
# @api private
#
# source://dry-schema//lib/dry/schema/types_merger.rb#10
class Dry::Schema::TypesMerger
  # @api private
  # @return [TypesMerger] a new instance of TypesMerger
  #
  # source://dry-schema//lib/dry/schema/types_merger.rb#171
  def initialize(type_registry = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/types_merger.rb#176
  def call(op_class, lhs, rhs); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/types_merger.rb#11
  def type_registry; end
end

# @api private
#
# source://dry-schema//lib/dry/schema/types_merger.rb#14
class Dry::Schema::TypesMerger::ValueMerger
  # @api private
  # @return [ValueMerger] a new instance of ValueMerger
  #
  # source://dry-schema//lib/dry/schema/types_merger.rb#21
  def initialize(types_merger, op_class, old, new); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/types_merger.rb#29
  def call; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/types_merger.rb#72
  def merge_unwrapped_types(unwrapped_old, unwrapped_new); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/types_merger.rb#18
  def new; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/types_merger.rb#17
  def old; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/types_merger.rb#16
  def op_class; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/types_merger.rb#15
  def types_merger; end

  private

  # @api private
  #
  # source://dry-schema//lib/dry/schema/types_merger.rb#51
  def merge_and; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/types_merger.rb#139
  def merge_equivalent_types(unwrapped_old, unwrapped_new); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/types_merger.rb#51
  def merge_implication; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/types_merger.rb#46
  def merge_or; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/types_merger.rb#51
  def merge_ordered; end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/types_merger.rb#128
  def merge_schemas(unwrapped_old, unwrapped_new); end

  # @api private
  #
  # source://dry-schema//lib/dry/schema/types_merger.rb#152
  def unwrap_type(type); end
end

# Used by the processors to coerce values in the input hash
#
# @api private
#
# source://dry-schema//lib/dry/schema/value_coercer.rb#11
class Dry::Schema::ValueCoercer
  include ::Dry::Initializer::Mixin::Root
  include ::Dry::Core::Equalizer::Methods
  extend ::Dry::Initializer

  # @api private
  #
  # source://dry-schema//lib/dry/schema/value_coercer.rb#19
  def call(input); end
end
