# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sigstore` gem.
# Please instead update this file by running `bin/tapioca gem sigstore`.


# source://sigstore//lib/sigstore.rb#17
module Sigstore
  class << self
    # source://sigstore//lib/sigstore.rb#21
    def logger; end

    # Sets the attribute logger
    #
    # @param value the value to set the attribute logger to.
    #
    # source://sigstore//lib/sigstore.rb#19
    def logger=(_arg0); end
  end
end

# source://sigstore//lib/sigstore/models.rb#45
class Sigstore::BundleType
  include ::Comparable

  # @return [BundleType] a new instance of BundleType
  #
  # source://sigstore//lib/sigstore/models.rb#50
  def initialize(media_type); end

  # source://sigstore//lib/sigstore/models.rb#73
  def <=>(other); end

  # Returns the value of attribute media_type.
  #
  # source://sigstore//lib/sigstore/models.rb#48
  def media_type; end

  class << self
    # source://sigstore//lib/sigstore/models.rb#60
    def from_media_type(media_type); end
  end
end

# source://sigstore//lib/sigstore/models.rb#54
Sigstore::BundleType::BUNDLE_0_1 = T.let(T.unsafe(nil), Sigstore::BundleType)

# source://sigstore//lib/sigstore/models.rb#55
Sigstore::BundleType::BUNDLE_0_2 = T.let(T.unsafe(nil), Sigstore::BundleType)

# source://sigstore//lib/sigstore/models.rb#56
Sigstore::BundleType::BUNDLE_0_3 = T.let(T.unsafe(nil), Sigstore::BundleType)

# source://sigstore//lib/sigstore/models.rb#58
Sigstore::BundleType::VERSIONS = T.let(T.unsafe(nil), Array)

# source://sigstore//lib/sigstore/error.rb#18
class Sigstore::Error < ::StandardError; end

# source://sigstore//lib/sigstore/error.rb#35
class Sigstore::Error::FailedRekorLookup < ::Sigstore::Error; end

# source://sigstore//lib/sigstore/error.rb#36
class Sigstore::Error::FailedRekorPost < ::Sigstore::Error; end

# source://sigstore//lib/sigstore/error.rb#20
class Sigstore::Error::InvalidBundle < ::Sigstore::Error; end

# source://sigstore//lib/sigstore/error.rb#21
class Sigstore::Error::InvalidCertificate < ::Sigstore::Error; end

# source://sigstore//lib/sigstore/error.rb#27
class Sigstore::Error::InvalidCheckpoint < ::Sigstore::Error; end

# source://sigstore//lib/sigstore/error.rb#31
class Sigstore::Error::InvalidIdentityToken < ::Sigstore::Error; end

# source://sigstore//lib/sigstore/error.rb#26
class Sigstore::Error::InvalidKey < ::Sigstore::Error; end

# source://sigstore//lib/sigstore/error.rb#34
class Sigstore::Error::InvalidRekorEntry < ::Sigstore::Error; end

# source://sigstore//lib/sigstore/error.rb#19
class Sigstore::Error::InvalidSignature < ::Sigstore::Error; end

# source://sigstore//lib/sigstore/error.rb#28
class Sigstore::Error::InvalidVerificationInput < ::Sigstore::Error; end

# source://sigstore//lib/sigstore/error.rb#33
class Sigstore::Error::MissingRekorEntry < ::Sigstore::Error; end

# source://sigstore//lib/sigstore/error.rb#24
class Sigstore::Error::NoBundle < ::Sigstore::Error; end

# source://sigstore//lib/sigstore/error.rb#22
class Sigstore::Error::NoCertificate < ::Sigstore::Error; end

# source://sigstore//lib/sigstore/error.rb#25
class Sigstore::Error::NoSignature < ::Sigstore::Error; end

# source://sigstore//lib/sigstore/error.rb#23
class Sigstore::Error::NoTrustedRoot < ::Sigstore::Error; end

# source://sigstore//lib/sigstore/error.rb#30
class Sigstore::Error::Signing < ::Sigstore::Error; end

# source://sigstore//lib/sigstore/error.rb#38
class Sigstore::Error::Unimplemented < ::Sigstore::Error; end

# source://sigstore//lib/sigstore/error.rb#41
class Sigstore::Error::UnsupportedKeyType < ::Sigstore::Error; end

# source://sigstore//lib/sigstore/error.rb#40
class Sigstore::Error::UnsupportedPlatform < ::Sigstore::Error; end

# source://sigstore//lib/sigstore/internal/util.rb#18
module Sigstore::Internal; end

# source://sigstore//lib/sigstore/internal/json.rb#18
module Sigstore::Internal::JSON
  class << self
    # Implements https://wiki.laptop.org/go/Canonical_JSON
    #
    # source://sigstore//lib/sigstore/internal/json.rb#21
    def canonical_generate(data, buffer = T.unsafe(nil)); end
  end
end

# source://sigstore//lib/sigstore/internal/key.rb#21
class Sigstore::Internal::Key
  include ::Sigstore::Loggable
  extend ::Sigstore::Loggable::ClassMethods

  # @return [Key] a new instance of Key
  #
  # source://sigstore//lib/sigstore/internal/key.rb#63
  def initialize(key_type, schema, key, key_id: T.unsafe(nil)); end

  # Returns the value of attribute key_id.
  #
  # source://sigstore//lib/sigstore/internal/key.rb#61
  def key_id; end

  # Returns the value of attribute key_type.
  #
  # source://sigstore//lib/sigstore/internal/key.rb#61
  def key_type; end

  # source://sigstore//lib/sigstore/internal/key.rb#85
  def public_to_der; end

  # Returns the value of attribute schema.
  #
  # source://sigstore//lib/sigstore/internal/key.rb#61
  def schema; end

  # source://sigstore//lib/sigstore/internal/key.rb#74
  def to_der; end

  # source://sigstore//lib/sigstore/internal/key.rb#70
  def to_pem; end

  # source://sigstore//lib/sigstore/internal/key.rb#78
  def verify(algo, signature, data); end

  class << self
    # source://sigstore//lib/sigstore/internal/key.rb#24
    def from_key_details(key_details, key_bytes); end

    # source://sigstore//lib/sigstore/internal/key.rb#39
    def read(key_type, schema, key_bytes, key_id: T.unsafe(nil)); end
  end
end

# source://sigstore//lib/sigstore/internal/key.rb#143
class Sigstore::Internal::Key::ED25519 < ::Sigstore::Internal::Key
  # @raise [ArgumentError]
  # @return [ED25519] a new instance of ED25519
  #
  # source://sigstore//lib/sigstore/internal/key.rb#157
  def initialize(*_arg0, **_arg1, &_arg2); end

  # source://sigstore//lib/sigstore/internal/key.rb#177
  def verify(_algo, signature, data); end

  class << self
    # source://sigstore//lib/sigstore/internal/key.rb#144
    def pkey_from_der(raw); end
  end
end

# source://sigstore//lib/sigstore/internal/key.rb#89
class Sigstore::Internal::Key::EDCSA < ::Sigstore::Internal::Key
  # @return [EDCSA] a new instance of EDCSA
  #
  # source://sigstore//lib/sigstore/internal/key.rb#90
  def initialize(*_arg0, **_arg1, &_arg2); end
end

# source://sigstore//lib/sigstore/internal/key.rb#112
class Sigstore::Internal::Key::RSA < ::Sigstore::Internal::Key
  # @raise [ArgumentError]
  # @return [RSA] a new instance of RSA
  #
  # source://sigstore//lib/sigstore/internal/key.rb#113
  def initialize(*_arg0, **_arg1, &_arg2); end

  # source://sigstore//lib/sigstore/internal/key.rb#131
  def verify(_algo, signature, data); end
end

# source://sigstore//lib/sigstore/internal/keyring.rb#19
class Sigstore::Internal::Keyring
  # @return [Keyring] a new instance of Keyring
  #
  # source://sigstore//lib/sigstore/internal/keyring.rb#20
  def initialize(keys:); end

  # source://sigstore//lib/sigstore/internal/keyring.rb#29
  def verify(key_id:, signature:, data:); end
end

# source://sigstore//lib/sigstore/internal/merkle.rb#21
module Sigstore::Internal::Merkle
  class << self
    # source://sigstore//lib/sigstore/internal/merkle.rb#105
    def chain_border_right(seed, hashes); end

    # source://sigstore//lib/sigstore/internal/merkle.rb#94
    def chain_inner(seed, hashes, log_index); end

    # source://sigstore//lib/sigstore/internal/merkle.rb#82
    def decompose_inclusion_proof(log_index, tree_size); end

    # source://sigstore//lib/sigstore/internal/merkle.rb#111
    def hash_children(left, right); end

    # source://sigstore//lib/sigstore/internal/merkle.rb#89
    def hash_leaf(data); end

    # source://sigstore//lib/sigstore/internal/merkle.rb#47
    def root_from_inclusion_proof(log_index, tree_size, proof, leaf_hash); end

    # @raise [InvalidInclusionProofError]
    #
    # source://sigstore//lib/sigstore/internal/merkle.rb#37
    def verify_inclusion(index, tree_size, proof, root, leaf_hash); end

    # @raise [MissingInclusionProofError]
    #
    # source://sigstore//lib/sigstore/internal/merkle.rb#27
    def verify_merkle_inclusion(entry); end
  end
end

# source://sigstore//lib/sigstore/internal/merkle.rb#25
class Sigstore::Internal::Merkle::InclusionProofSizeError < ::Sigstore::Internal::Merkle::InvalidInclusionProofError; end

# source://sigstore//lib/sigstore/internal/merkle.rb#24
class Sigstore::Internal::Merkle::InvalidInclusionProofError < ::StandardError; end

# source://sigstore//lib/sigstore/internal/merkle.rb#23
class Sigstore::Internal::Merkle::MissingHashError < ::StandardError; end

# source://sigstore//lib/sigstore/internal/merkle.rb#22
class Sigstore::Internal::Merkle::MissingInclusionProofError < ::StandardError; end

# source://sigstore//lib/sigstore/internal/set.rb#19
module Sigstore::Internal::SET
  class << self
    # @raise [Error]
    #
    # source://sigstore//lib/sigstore/internal/set.rb#20
    def verify_set(keyring:, entry:); end
  end
end

# source://sigstore//lib/sigstore/internal/util.rb#19
module Sigstore::Internal::Util
  private

  # source://sigstore//lib/sigstore/internal/util.rb#47
  def base64_decode(string); end

  # source://sigstore//lib/sigstore/internal/util.rb#43
  def base64_encode(string); end

  # source://sigstore//lib/sigstore/internal/util.rb#22
  def hash_algorithm_name(algorithm); end

  # source://sigstore//lib/sigstore/internal/util.rb#39
  def hex_decode(string); end

  # source://sigstore//lib/sigstore/internal/util.rb#35
  def hex_encode(string); end

  class << self
    # source://sigstore//lib/sigstore/internal/util.rb#47
    def base64_decode(string); end

    # source://sigstore//lib/sigstore/internal/util.rb#43
    def base64_encode(string); end

    # source://sigstore//lib/sigstore/internal/util.rb#22
    def hash_algorithm_name(algorithm); end

    # source://sigstore//lib/sigstore/internal/util.rb#39
    def hex_decode(string); end

    # source://sigstore//lib/sigstore/internal/util.rb#35
    def hex_encode(string); end
  end
end

# source://sigstore//lib/sigstore/internal/x509.rb#22
module Sigstore::Internal::X509; end

# source://sigstore//lib/sigstore/internal/x509.rb#23
class Sigstore::Internal::X509::Certificate
  extend ::Forwardable

  # @raise [Error::InvalidCertificate]
  # @return [Certificate] a new instance of Certificate
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#28
  def initialize(x509_certificate); end

  # source://sigstore//lib/sigstore/internal/x509.rb#100
  def ==(other); end

  # @raise [Error::InvalidCertificate]
  # @return [Boolean]
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#122
  def ca?; end

  # source://sigstore//lib/sigstore/internal/x509.rb#90
  def extension(cls); end

  # source://sigstore//lib/sigstore/internal/x509.rb#97
  def hash(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#104
  def leaf?; end

  # source://sigstore//lib/sigstore/internal/x509.rb#97
  def not_after(*args, **_arg1, &block); end

  # source://sigstore//lib/sigstore/internal/x509.rb#97
  def not_before(*args, **_arg1, &block); end

  # Returns the value of attribute openssl.
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#26
  def openssl; end

  # @return [Boolean]
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#148
  def preissuer?; end

  # source://sigstore//lib/sigstore/internal/x509.rb#97
  def public_key(*args, **_arg1, &block); end

  # source://sigstore//lib/sigstore/internal/x509.rb#97
  def subject(*args, **_arg1, &block); end

  # source://sigstore//lib/sigstore/internal/x509.rb#45
  def tbs_certificate_der; end

  # source://sigstore//lib/sigstore/internal/x509.rb#97
  def to_der(*args, **_arg1, &block); end

  # source://sigstore//lib/sigstore/internal/x509.rb#97
  def to_pem(*args, **_arg1, &block); end

  # source://sigstore//lib/sigstore/internal/x509.rb#97
  def to_text(*args, **_arg1, &block); end

  # source://sigstore//lib/sigstore/internal/x509.rb#97
  def version(*args, **_arg1, &block); end

  class << self
    # source://sigstore//lib/sigstore/internal/x509.rb#39
    def read(certificate_bytes); end
  end
end

# source://sigstore//lib/sigstore/internal/x509.rb#156
class Sigstore::Internal::X509::Extension
  # @return [Extension] a new instance of Extension
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#161
  def initialize(extension); end

  # @return [Boolean]
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#184
  def critical?; end

  # @raise [ArgumentError]
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#195
  def shift_bitstring(value); end

  # @raise [ArgumentError]
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#188
  def shift_value(value, klass); end

  class << self
    # Returns the value of attribute oid.
    #
    # source://sigstore//lib/sigstore/internal/x509.rb#158
    def oid; end

    # Sets the attribute oid
    #
    # @param value the value to set the attribute oid to.
    #
    # source://sigstore//lib/sigstore/internal/x509.rb#158
    def oid=(_arg0); end

    # Returns the value of attribute schema.
    #
    # source://sigstore//lib/sigstore/internal/x509.rb#158
    def schema; end

    # Sets the attribute schema
    #
    # @param value the value to set the attribute schema to.
    #
    # source://sigstore//lib/sigstore/internal/x509.rb#158
    def schema=(_arg0); end
  end
end

# source://sigstore//lib/sigstore/internal/x509.rb#257
class Sigstore::Internal::X509::Extension::BasicConstraints < ::Sigstore::Internal::X509::Extension
  # Returns the value of attribute ca.
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#260
  def ca; end

  # source://sigstore//lib/sigstore/internal/x509.rb#262
  def parse_value(value); end

  # Returns the value of attribute path_len_constraint.
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#260
  def path_len_constraint; end
end

# source://sigstore//lib/sigstore/internal/x509.rb#232
class Sigstore::Internal::X509::Extension::ExtendedKeyUsage < ::Sigstore::Internal::X509::Extension
  # @return [Boolean]
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#252
  def code_signing?; end

  # @raise [ArgumentError]
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#237
  def parse_value(value); end

  # Returns the value of attribute purposes.
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#235
  def purposes; end
end

# source://sigstore//lib/sigstore/internal/x509.rb#250
Sigstore::Internal::X509::Extension::ExtendedKeyUsage::CODE_SIGNING = T.let(T.unsafe(nil), OpenSSL::ASN1::ObjectId)

# source://sigstore//lib/sigstore/internal/x509.rb#445
class Sigstore::Internal::X509::Extension::FulcioIssuer < ::Sigstore::Internal::X509::Extension
  # Returns the value of attribute issuer.
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#448
  def issuer; end

  # source://sigstore//lib/sigstore/internal/x509.rb#450
  def parse_value(value); end
end

# source://sigstore//lib/sigstore/internal/x509.rb#219
class Sigstore::Internal::X509::Extension::KeyUsage < ::Sigstore::Internal::X509::Extension
  # Returns the value of attribute crl_sign.
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#222
  def crl_sign; end

  # Returns the value of attribute data_encipherment.
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#222
  def data_encipherment; end

  # Returns the value of attribute decipher_only.
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#222
  def decipher_only; end

  # Returns the value of attribute digital_signature.
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#222
  def digital_signature; end

  # Returns the value of attribute encipher_only.
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#222
  def encipher_only; end

  # Returns the value of attribute key_agreement.
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#222
  def key_agreement; end

  # Returns the value of attribute key_cert_sign.
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#222
  def key_cert_sign; end

  # Returns the value of attribute key_encipherment.
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#222
  def key_encipherment; end

  # Returns the value of attribute non_repudiation.
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#222
  def non_repudiation; end

  # source://sigstore//lib/sigstore/internal/x509.rb#225
  def parse_value(value); end
end

# source://sigstore//lib/sigstore/internal/x509.rb#325
class Sigstore::Internal::X509::Extension::PrecertificateSignedCertificateTimestamps < ::Sigstore::Internal::X509::Extension
  # source://sigstore//lib/sigstore/internal/x509.rb#330
  def parse_value(value); end

  # Returns the value of attribute signed_certificate_timestamps.
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#328
  def signed_certificate_timestamps; end

  private

  # source://sigstore//lib/sigstore/internal/x509.rb#392
  def unpack1_at(string, format, offset:); end

  # source://sigstore//lib/sigstore/internal/x509.rb#388
  def unpack_at(string, format, offset:); end

  # https://letsencrypt.org/2018/04/04/sct-encoding.html
  #
  # @raise [Error::InvalidCertificate]
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#406
  def unpack_sct_list(string); end
end

# source://sigstore//lib/sigstore/internal/x509.rb#366
Sigstore::Internal::X509::Extension::PrecertificateSignedCertificateTimestamps::HASHES = T.let(T.unsafe(nil), Hash)

# source://sigstore//lib/sigstore/internal/x509.rb#377
Sigstore::Internal::X509::Extension::PrecertificateSignedCertificateTimestamps::SIGNATURE_ALGORITHMS = T.let(T.unsafe(nil), Hash)

class Sigstore::Internal::X509::Extension::PrecertificateSignedCertificateTimestamps::Timestamp < ::Data
  # source://sigstore//lib/sigstore/internal/x509.rb#364
  def entry_type; end

  # source://sigstore//lib/sigstore/internal/x509.rb#364
  def extensions_bytes; end

  # source://sigstore//lib/sigstore/internal/x509.rb#364
  def hash_algorithm; end

  # source://sigstore//lib/sigstore/internal/x509.rb#364
  def log_id; end

  # source://sigstore//lib/sigstore/internal/x509.rb#364
  def signature; end

  # source://sigstore//lib/sigstore/internal/x509.rb#364
  def signature_algorithm; end

  # source://sigstore//lib/sigstore/internal/x509.rb#364
  def timestamp; end

  # source://sigstore//lib/sigstore/internal/x509.rb#364
  def version; end

  class << self
    # source://sigstore//lib/sigstore/internal/x509.rb#364
    def [](*_arg0); end

    # source://sigstore//lib/sigstore/internal/x509.rb#364
    def inspect; end

    # source://sigstore//lib/sigstore/internal/x509.rb#364
    def members; end

    # source://sigstore//lib/sigstore/internal/x509.rb#364
    def new(*_arg0); end
  end
end

# source://sigstore//lib/sigstore/internal/x509.rb#276
class Sigstore::Internal::X509::Extension::SubjectAlternativeName < ::Sigstore::Internal::X509::Extension
  # Returns the value of attribute general_names.
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#279
  def general_names; end

  # EDIPartyName ::= SEQUENCE {
  #       nameAssigner            [0]     DirectoryString OPTIONAL,
  #       partyName               [1]     DirectoryString }
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#306
  def parse_value(value); end
end

# source://sigstore//lib/sigstore/internal/x509.rb#204
class Sigstore::Internal::X509::Extension::SubjectKeyIdentifier < ::Sigstore::Internal::X509::Extension
  # Returns the value of attribute key_identifier.
  #
  # source://sigstore//lib/sigstore/internal/x509.rb#205
  def key_identifier; end

  # source://sigstore//lib/sigstore/internal/x509.rb#209
  def parse_value(value); end
end

# source://sigstore//lib/sigstore.rb#29
module Sigstore::Loggable
  mixes_in_class_methods ::Sigstore::Loggable::ClassMethods

  # source://sigstore//lib/sigstore.rb#30
  def logger; end

  class << self
    # @private
    #
    # source://sigstore//lib/sigstore.rb#34
    def included(base); end
  end
end

# source://sigstore//lib/sigstore.rb#38
module Sigstore::Loggable::ClassMethods
  # source://sigstore//lib/sigstore.rb#39
  def logger; end
end

# source://sigstore//lib/sigstore/oidc.rb#18
module Sigstore::OIDC; end

# source://sigstore//lib/sigstore/oidc.rb#27
Sigstore::OIDC::DEFAULT_AUDIENCE = T.let(T.unsafe(nil), String)

# source://sigstore//lib/sigstore/oidc.rb#30
class Sigstore::OIDC::IdentityToken
  # @raise [Error::InvalidIdentityToken]
  # @return [IdentityToken] a new instance of IdentityToken
  #
  # source://sigstore//lib/sigstore/oidc.rb#33
  def initialize(raw_token); end

  # Returns the value of attribute identity.
  #
  # source://sigstore//lib/sigstore/oidc.rb#31
  def identity; end

  # source://sigstore//lib/sigstore/oidc.rb#57
  def issuer; end

  # Returns the value of attribute raw_token.
  #
  # source://sigstore//lib/sigstore/oidc.rb#31
  def raw_token; end

  private

  # Returns whether or not this `Identity` is currently within its self-stated validity period.
  #
  # @return [Boolean]
  #
  # source://sigstore//lib/sigstore/oidc.rb#102
  def in_validity_period?; end

  class << self
    # source://sigstore//lib/sigstore/oidc.rb#61
    def decode_jwt(raw_token); end

    private

    # @raise [Error::InvalidIdentityToken]
    #
    # source://sigstore//lib/sigstore/oidc.rb#135
    def validate_aud(aud, audience); end

    # @raise [Error::InvalidIdentityToken]
    #
    # source://sigstore//lib/sigstore/oidc.rb#130
    def validate_exp(exp, now, leeway); end

    # @raise [Error::InvalidIdentityToken]
    #
    # source://sigstore//lib/sigstore/oidc.rb#120
    def validate_iat(iat, now, leeway); end

    # @raise [Error::InvalidIdentityToken]
    #
    # source://sigstore//lib/sigstore/oidc.rb#125
    def validate_nbf(nbf, now, leeway); end

    # source://sigstore//lib/sigstore/oidc.rb#112
    def validate_required_claims(payload, required); end
  end
end

# source://sigstore//lib/sigstore/oidc.rb#19
Sigstore::OIDC::KNOWN_OIDC_ISSUERS = T.let(T.unsafe(nil), Hash)

# source://sigstore//lib/sigstore/policy.rb#18
module Sigstore::Policy; end

# source://sigstore//lib/sigstore/policy.rb#64
class Sigstore::Policy::AnyOf
  # @return [AnyOf] a new instance of AnyOf
  #
  # source://sigstore//lib/sigstore/policy.rb#65
  def initialize(*policies); end

  # source://sigstore//lib/sigstore/policy.rb#69
  def verify(cert); end
end

# source://sigstore//lib/sigstore/policy.rb#82
class Sigstore::Policy::Identity
  # @return [Identity] a new instance of Identity
  #
  # source://sigstore//lib/sigstore/policy.rb#83
  def initialize(identity:, issuer:); end

  # @raise [Error::InvalidCertificate]
  #
  # source://sigstore//lib/sigstore/policy.rb#88
  def verify(cert); end
end

# source://sigstore//lib/sigstore/policy.rb#50
class Sigstore::Policy::OIDCIssuer < ::Sigstore::Policy::SingleX509ExtPolicy; end

# source://sigstore//lib/sigstore/policy.rb#51
Sigstore::Policy::OIDCIssuer::OID = T.let(T.unsafe(nil), String)

# source://sigstore//lib/sigstore/policy.rb#60
class Sigstore::Policy::OIDCIssuerV2 < ::Sigstore::Policy::SingleX509ExtDerEncodedPolicy; end

# source://sigstore//lib/sigstore/policy.rb#61
Sigstore::Policy::OIDCIssuerV2::OID = T.let(T.unsafe(nil), String)

# source://sigstore//lib/sigstore/policy.rb#54
class Sigstore::Policy::SingleX509ExtDerEncodedPolicy < ::Sigstore::Policy::SingleX509ExtPolicy
  # source://sigstore//lib/sigstore/policy.rb#55
  def ext_value(ext); end
end

# source://sigstore//lib/sigstore/policy.rb#19
class Sigstore::Policy::SingleX509ExtPolicy
  # @return [SingleX509ExtPolicy] a new instance of SingleX509ExtPolicy
  #
  # source://sigstore//lib/sigstore/policy.rb#20
  def initialize(value); end

  # source://sigstore//lib/sigstore/policy.rb#41
  def ext_value(ext); end

  # source://sigstore//lib/sigstore/policy.rb#45
  def oid; end

  # source://sigstore//lib/sigstore/policy.rb#24
  def verify(cert); end
end

# source://sigstore//lib/sigstore/trusted_root.rb#25
Sigstore::REGISTRY = T.let(T.unsafe(nil), Protobug::Registry)

# source://sigstore//lib/sigstore/rekor/client.rb#20
module Sigstore::Rekor; end

# source://sigstore//lib/sigstore/rekor/checkpoint.rb#19
module Sigstore::Rekor::Checkpoint
  class << self
    # @raise [Error::InvalidRekorEntry]
    #
    # source://sigstore//lib/sigstore/rekor/checkpoint.rb#98
    def verify_checkpoint(rekor_keyring, entry); end
  end
end

# source://sigstore//lib/sigstore/rekor/checkpoint.rb#80
class Sigstore::Rekor::Checkpoint::LogCheckpoint < ::Struct
  # Returns the value of attribute log_hash
  #
  # @return [Object] the current value of log_hash
  #
  # source://sigstore//lib/sigstore/rekor/checkpoint.rb#80
  def log_hash; end

  # Sets the attribute log_hash
  #
  # @param value [Object] the value to set the attribute log_hash to.
  # @return [Object] the newly set value
  #
  # source://sigstore//lib/sigstore/rekor/checkpoint.rb#80
  def log_hash=(_); end

  # Returns the value of attribute log_size
  #
  # @return [Object] the current value of log_size
  #
  # source://sigstore//lib/sigstore/rekor/checkpoint.rb#80
  def log_size; end

  # Sets the attribute log_size
  #
  # @param value [Object] the value to set the attribute log_size to.
  # @return [Object] the newly set value
  #
  # source://sigstore//lib/sigstore/rekor/checkpoint.rb#80
  def log_size=(_); end

  # Returns the value of attribute origin
  #
  # @return [Object] the current value of origin
  #
  # source://sigstore//lib/sigstore/rekor/checkpoint.rb#80
  def origin; end

  # Sets the attribute origin
  #
  # @param value [Object] the value to set the attribute origin to.
  # @return [Object] the newly set value
  #
  # source://sigstore//lib/sigstore/rekor/checkpoint.rb#80
  def origin=(_); end

  # Returns the value of attribute other_content
  #
  # @return [Object] the current value of other_content
  #
  # source://sigstore//lib/sigstore/rekor/checkpoint.rb#80
  def other_content; end

  # Sets the attribute other_content
  #
  # @param value [Object] the value to set the attribute other_content to.
  # @return [Object] the newly set value
  #
  # source://sigstore//lib/sigstore/rekor/checkpoint.rb#80
  def other_content=(_); end

  class << self
    # source://sigstore//lib/sigstore/rekor/checkpoint.rb#80
    def [](*_arg0); end

    # @raise [Error::InvalidCheckpoint]
    #
    # source://sigstore//lib/sigstore/rekor/checkpoint.rb#83
    def from_text(text); end

    # source://sigstore//lib/sigstore/rekor/checkpoint.rb#80
    def inspect; end

    # source://sigstore//lib/sigstore/rekor/checkpoint.rb#80
    def keyword_init?; end

    # source://sigstore//lib/sigstore/rekor/checkpoint.rb#80
    def members; end

    # source://sigstore//lib/sigstore/rekor/checkpoint.rb#80
    def new(*_arg0); end
  end
end

# source://sigstore//lib/sigstore/rekor/checkpoint.rb#20
class Sigstore::Rekor::Checkpoint::Signature < ::Struct
  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  #
  # source://sigstore//lib/sigstore/rekor/checkpoint.rb#20
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  #
  # source://sigstore//lib/sigstore/rekor/checkpoint.rb#20
  def name=(_); end

  # Returns the value of attribute sig_hash
  #
  # @return [Object] the current value of sig_hash
  #
  # source://sigstore//lib/sigstore/rekor/checkpoint.rb#20
  def sig_hash; end

  # Sets the attribute sig_hash
  #
  # @param value [Object] the value to set the attribute sig_hash to.
  # @return [Object] the newly set value
  #
  # source://sigstore//lib/sigstore/rekor/checkpoint.rb#20
  def sig_hash=(_); end

  # Returns the value of attribute signature
  #
  # @return [Object] the current value of signature
  #
  # source://sigstore//lib/sigstore/rekor/checkpoint.rb#20
  def signature; end

  # Sets the attribute signature
  #
  # @param value [Object] the value to set the attribute signature to.
  # @return [Object] the newly set value
  #
  # source://sigstore//lib/sigstore/rekor/checkpoint.rb#20
  def signature=(_); end

  class << self
    # source://sigstore//lib/sigstore/rekor/checkpoint.rb#20
    def [](*_arg0); end

    # source://sigstore//lib/sigstore/rekor/checkpoint.rb#20
    def inspect; end

    # source://sigstore//lib/sigstore/rekor/checkpoint.rb#20
    def keyword_init?; end

    # source://sigstore//lib/sigstore/rekor/checkpoint.rb#20
    def members; end

    # source://sigstore//lib/sigstore/rekor/checkpoint.rb#20
    def new(*_arg0); end
  end
end

# source://sigstore//lib/sigstore/rekor/checkpoint.rb#22
class Sigstore::Rekor::Checkpoint::SignedCheckpoint < ::Struct
  # Returns the value of attribute checkpoint
  #
  # @return [Object] the current value of checkpoint
  #
  # source://sigstore//lib/sigstore/rekor/checkpoint.rb#22
  def checkpoint; end

  # Sets the attribute checkpoint
  #
  # @param value [Object] the value to set the attribute checkpoint to.
  # @return [Object] the newly set value
  #
  # source://sigstore//lib/sigstore/rekor/checkpoint.rb#22
  def checkpoint=(_); end

  # Returns the value of attribute signed_note
  #
  # @return [Object] the current value of signed_note
  #
  # source://sigstore//lib/sigstore/rekor/checkpoint.rb#22
  def signed_note; end

  # Sets the attribute signed_note
  #
  # @param value [Object] the value to set the attribute signed_note to.
  # @return [Object] the newly set value
  #
  # source://sigstore//lib/sigstore/rekor/checkpoint.rb#22
  def signed_note=(_); end

  class << self
    # source://sigstore//lib/sigstore/rekor/checkpoint.rb#22
    def [](*_arg0); end

    # source://sigstore//lib/sigstore/rekor/checkpoint.rb#25
    def from_text(text); end

    # source://sigstore//lib/sigstore/rekor/checkpoint.rb#22
    def inspect; end

    # source://sigstore//lib/sigstore/rekor/checkpoint.rb#22
    def keyword_init?; end

    # source://sigstore//lib/sigstore/rekor/checkpoint.rb#22
    def members; end

    # source://sigstore//lib/sigstore/rekor/checkpoint.rb#22
    def new(*_arg0); end
  end
end

# source://sigstore//lib/sigstore/rekor/checkpoint.rb#33
class Sigstore::Rekor::Checkpoint::SignedNote < ::Struct
  # Returns the value of attribute note
  #
  # @return [Object] the current value of note
  #
  # source://sigstore//lib/sigstore/rekor/checkpoint.rb#33
  def note; end

  # Sets the attribute note
  #
  # @param value [Object] the value to set the attribute note to.
  # @return [Object] the newly set value
  #
  # source://sigstore//lib/sigstore/rekor/checkpoint.rb#33
  def note=(_); end

  # Returns the value of attribute signatures
  #
  # @return [Object] the current value of signatures
  #
  # source://sigstore//lib/sigstore/rekor/checkpoint.rb#33
  def signatures; end

  # Sets the attribute signatures
  #
  # @param value [Object] the value to set the attribute signatures to.
  # @return [Object] the newly set value
  #
  # source://sigstore//lib/sigstore/rekor/checkpoint.rb#33
  def signatures=(_); end

  # source://sigstore//lib/sigstore/rekor/checkpoint.rb#66
  def verify(rekor_keyring, key_id); end

  class << self
    # source://sigstore//lib/sigstore/rekor/checkpoint.rb#33
    def [](*_arg0); end

    # @raise [Error::InvalidCheckpoint]
    #
    # source://sigstore//lib/sigstore/rekor/checkpoint.rb#36
    def from_text(text); end

    # source://sigstore//lib/sigstore/rekor/checkpoint.rb#33
    def inspect; end

    # source://sigstore//lib/sigstore/rekor/checkpoint.rb#33
    def keyword_init?; end

    # source://sigstore//lib/sigstore/rekor/checkpoint.rb#33
    def members; end

    # source://sigstore//lib/sigstore/rekor/checkpoint.rb#33
    def new(*_arg0); end
  end
end

# source://sigstore//lib/sigstore/rekor/client.rb#21
class Sigstore::Rekor::Client
  # @return [Client] a new instance of Client
  #
  # source://sigstore//lib/sigstore/rekor/client.rb#25
  def initialize(url:); end

  # source://sigstore//lib/sigstore/rekor/client.rb#41
  def log; end

  class << self
    # source://sigstore//lib/sigstore/rekor/client.rb#33
    def production; end

    # source://sigstore//lib/sigstore/rekor/client.rb#37
    def staging; end
  end
end

# source://sigstore//lib/sigstore/rekor/client.rb#22
Sigstore::Rekor::Client::DEFAULT_REKOR_URL = T.let(T.unsafe(nil), String)

# source://sigstore//lib/sigstore/rekor/client.rb#23
Sigstore::Rekor::Client::STAGING_REKOR_URL = T.let(T.unsafe(nil), String)

# source://sigstore//lib/sigstore/rekor/client.rb#57
class Sigstore::Rekor::Entries
  # @return [Entries] a new instance of Entries
  #
  # source://sigstore//lib/sigstore/rekor/client.rb#58
  def initialize(url, session:); end

  # source://sigstore//lib/sigstore/rekor/client.rb#67
  def post(entry); end

  # source://sigstore//lib/sigstore/rekor/client.rb#63
  def retrieve; end

  class << self
    # @raise [ArgumentError]
    #
    # source://sigstore//lib/sigstore/rekor/client.rb#107
    def decode_transparency_log_entry(response); end
  end
end

# source://sigstore//lib/sigstore/rekor/client.rb#83
class Sigstore::Rekor::Entries::Retrieve
  # @return [Retrieve] a new instance of Retrieve
  #
  # source://sigstore//lib/sigstore/rekor/client.rb#84
  def initialize(url, session:); end

  # source://sigstore//lib/sigstore/rekor/client.rb#89
  def post(expected_entry); end
end

# source://sigstore//lib/sigstore/rekor/client.rb#46
class Sigstore::Rekor::Log
  # @return [Log] a new instance of Log
  #
  # source://sigstore//lib/sigstore/rekor/client.rb#47
  def initialize(url, session:); end

  # source://sigstore//lib/sigstore/rekor/client.rb#52
  def entries; end
end

# source://sigstore//lib/sigstore/models.rb#120
class Sigstore::SBundle
  # @return [SBundle] a new instance of SBundle
  #
  # source://sigstore//lib/sigstore/models.rb#123
  def initialize(*_arg0); end

  # Returns the value of attribute bundle_type.
  #
  # source://sigstore//lib/sigstore/models.rb#121
  def bundle_type; end

  # source://sigstore//lib/sigstore/models.rb#141
  def expected_tlog_entry(hashed_input); end

  # Returns the value of attribute leaf_certificate.
  #
  # source://sigstore//lib/sigstore/models.rb#121
  def leaf_certificate; end

  private

  # source://sigstore//lib/sigstore/models.rb#266
  def expected_dsse_0_0_1_tlog_entry; end

  # source://sigstore//lib/sigstore/models.rb#214
  def expected_hashed_rekord_tlog_entry(hashed_input); end

  # source://sigstore//lib/sigstore/models.rb#235
  def expected_intoto_0_0_2_tlog_entry; end

  # @raise [Error::InvalidBundle]
  #
  # source://sigstore//lib/sigstore/models.rb#168
  def validate_version!; end

  class << self
    # source://sigstore//lib/sigstore/models.rb#130
    def for_cert_bytes_and_signature(cert_bytes, signature); end
  end
end

# source://sigstore//lib/sigstore/signer.rb#25
class Sigstore::Signer
  include ::Sigstore::Loggable
  extend ::Sigstore::Loggable::ClassMethods

  # @return [Signer] a new instance of Signer
  #
  # source://sigstore//lib/sigstore/signer.rb#28
  def initialize(jwt:, trusted_root:); end

  # source://sigstore//lib/sigstore/signer.rb#35
  def sign(payload); end

  private

  # source://sigstore//lib/sigstore/signer.rb#196
  def build_proposed_hashed_rekord_entry(signature, cert, hashed_input); end

  # source://sigstore//lib/sigstore/signer.rb#265
  def collect_bundle(leaf_certificate, tlog_entries, timestamp_verification_data, hashed_input, signature); end

  # source://sigstore//lib/sigstore/signer.rb#261
  def expected_identity; end

  # source://sigstore//lib/sigstore/signer.rb#106
  def fetch_cert(csr); end

  # source://sigstore//lib/sigstore/signer.rb#70
  def generate_csr(keypair); end

  # source://sigstore//lib/sigstore/signer.rb#63
  def generate_keypair; end

  # source://sigstore//lib/sigstore/signer.rb#181
  def sign_payload(payload, key); end

  # TODO: implement
  #
  # source://sigstore//lib/sigstore/signer.rb#188
  def submit_signature_hash_to_timstamping_service(_signature); end

  # source://sigstore//lib/sigstore/signer.rb#225
  def submit_signed_metadata_to_transparency_service(signature, cert, hashed_input); end

  # @raise [Error::Signing]
  #
  # source://sigstore//lib/sigstore/signer.rb#247
  def verify(artifact, bundle); end

  # source://sigstore//lib/sigstore/signer.rb#132
  def verify_chain(leaf); end
end

# source://sigstore//lib/sigstore/tuf/config.rb#18
module Sigstore::TUF; end

# source://sigstore//lib/sigstore/tuf/file.rb#20
module Sigstore::TUF::BaseFile
  mixes_in_class_methods ::Sigstore::TUF::BaseFile::ClassMethods

  class << self
    # @private
    #
    # source://sigstore//lib/sigstore/tuf/file.rb#21
    def included(base); end
  end
end

# source://sigstore//lib/sigstore/tuf/file.rb#26
module Sigstore::TUF::BaseFile::ClassMethods
  # @raise [ArgumentError]
  #
  # source://sigstore//lib/sigstore/tuf/file.rb#45
  def validate_hashes(hashes); end

  # @raise [ArgumentError]
  #
  # source://sigstore//lib/sigstore/tuf/file.rb#53
  def validate_length(length); end

  # source://sigstore//lib/sigstore/tuf/file.rb#27
  def verify_hashes(data, expected_hashed); end

  # @raise [Error::LengthOrHashMismatch]
  #
  # source://sigstore//lib/sigstore/tuf/file.rb#37
  def verify_length(data, expected_length); end
end

# source://sigstore//lib/sigstore/tuf.rb#25
Sigstore::TUF::DEFAULT_TUF_URL = T.let(T.unsafe(nil), String)

# source://sigstore//lib/sigstore/tuf/error.rb#20
class Sigstore::TUF::Error < ::Sigstore::Error; end

# source://sigstore//lib/sigstore/tuf/error.rb#30
class Sigstore::TUF::Error::BadUpdateOrder < ::Sigstore::TUF::Error; end

# source://sigstore//lib/sigstore/tuf/error.rb#26
class Sigstore::TUF::Error::BadVersionNumber < ::Sigstore::TUF::Error::RepositoryError; end

# An error occurred while attempting to download a file.
#
# source://sigstore//lib/sigstore/tuf/error.rb#35
class Sigstore::TUF::Error::DownloadError < ::Sigstore::TUF::Error; end

# source://sigstore//lib/sigstore/tuf/error.rb#32
class Sigstore::TUF::Error::DuplicateKeys < ::Sigstore::TUF::Error; end

# source://sigstore//lib/sigstore/tuf/error.rb#27
class Sigstore::TUF::Error::EqualVersionNumber < ::Sigstore::TUF::Error::BadVersionNumber; end

# source://sigstore//lib/sigstore/tuf/error.rb#25
class Sigstore::TUF::Error::ExpiredMetadata < ::Sigstore::TUF::Error::RepositoryError; end

# source://sigstore//lib/sigstore/tuf/error.rb#37
class Sigstore::TUF::Error::Fetch < ::Sigstore::TUF::Error; end

# source://sigstore//lib/sigstore/tuf/error.rb#31
class Sigstore::TUF::Error::InvalidData < ::Sigstore::TUF::Error; end

# source://sigstore//lib/sigstore/tuf/error.rb#24
class Sigstore::TUF::Error::LengthOrHashMismatch < ::Sigstore::TUF::Error::RepositoryError; end

# source://sigstore//lib/sigstore/tuf/error.rb#38
class Sigstore::TUF::Error::RemoteConnection < ::Sigstore::TUF::Error::Fetch; end

# An error with a repository's state, such as a missing file.
#
# source://sigstore//lib/sigstore/tuf/error.rb#22
class Sigstore::TUF::Error::RepositoryError < ::Sigstore::TUF::Error; end

# source://sigstore//lib/sigstore/tuf/error.rb#28
class Sigstore::TUF::Error::TooFewSignatures < ::Sigstore::TUF::Error::RepositoryError; end

# source://sigstore//lib/sigstore/tuf/error.rb#40
class Sigstore::TUF::Error::UnsuccessfulResponse < ::Sigstore::TUF::Error::Fetch
  # @return [UnsuccessfulResponse] a new instance of UnsuccessfulResponse
  #
  # source://sigstore//lib/sigstore/tuf/error.rb#43
  def initialize(message, response); end

  # Returns the value of attribute response.
  #
  # source://sigstore//lib/sigstore/tuf/error.rb#41
  def response; end
end

# source://sigstore//lib/sigstore/tuf/keys.rb#18
class Sigstore::TUF::Keys
  include ::Enumerable

  # @return [Keys] a new instance of Keys
  #
  # source://sigstore//lib/sigstore/tuf/keys.rb#21
  def initialize(keys); end

  # source://sigstore//lib/sigstore/tuf/keys.rb#38
  def each(&_arg0); end

  # source://sigstore//lib/sigstore/tuf/keys.rb#34
  def fetch(key_id); end
end

# source://sigstore//lib/sigstore/tuf/file.rb#61
module Sigstore::TUF::MetaFile
  include ::Sigstore::TUF::BaseFile

  mixes_in_class_methods ::Sigstore::TUF::BaseFile::ClassMethods
  mixes_in_class_methods ::Sigstore::TUF::MetaFile::ClassMethods

  # @raise [ArgumentError]
  #
  # source://sigstore//lib/sigstore/tuf/file.rb#68
  def initialize(version: T.unsafe(nil), length: T.unsafe(nil), hashes: T.unsafe(nil), unrecognized_fields: T.unsafe(nil)); end

  # source://sigstore//lib/sigstore/tuf/file.rb#80
  def verify_length_and_hashes(data); end

  class << self
    # @private
    #
    # source://sigstore//lib/sigstore/tuf/file.rb#62
    def included(base); end
  end
end

# source://sigstore//lib/sigstore/tuf/file.rb#85
module Sigstore::TUF::MetaFile::ClassMethods
  # source://sigstore//lib/sigstore/tuf/file.rb#86
  def from_hash(meta_dict); end
end

# source://sigstore//lib/sigstore/tuf/roles.rb#61
class Sigstore::TUF::Role
  include ::Sigstore::Loggable
  extend ::Sigstore::Loggable::ClassMethods

  # @return [Role] a new instance of Role
  #
  # source://sigstore//lib/sigstore/tuf/roles.rb#66
  def initialize(data, keys); end

  # Returns the value of attribute keys.
  #
  # source://sigstore//lib/sigstore/tuf/roles.rb#64
  def keys; end

  # Returns the value of attribute name.
  #
  # source://sigstore//lib/sigstore/tuf/roles.rb#64
  def name; end

  # Returns the value of attribute paths.
  #
  # source://sigstore//lib/sigstore/tuf/roles.rb#64
  def paths; end

  # @return [Boolean]
  #
  # source://sigstore//lib/sigstore/tuf/roles.rb#74
  def terminating?; end

  # Returns the value of attribute threshold.
  #
  # source://sigstore//lib/sigstore/tuf/roles.rb#64
  def threshold; end

  # @raise [Error::TooFewSignatures]
  #
  # source://sigstore//lib/sigstore/tuf/roles.rb#78
  def verify_delegate(type, bytes, signatures); end
end

# source://sigstore//lib/sigstore/tuf/roles.rb#18
class Sigstore::TUF::Roles
  include ::Enumerable

  # @return [Roles] a new instance of Roles
  #
  # source://sigstore//lib/sigstore/tuf/roles.rb#21
  def initialize(data, keys); end

  # source://sigstore//lib/sigstore/tuf/roles.rb#40
  def each(&_arg0); end

  # source://sigstore//lib/sigstore/tuf/roles.rb#49
  def fetch(name); end

  # source://sigstore//lib/sigstore/tuf/roles.rb#53
  def for_target(target_path); end

  # source://sigstore//lib/sigstore/tuf/roles.rb#44
  def verify_delegate(type, bytes, signatures); end
end

# source://sigstore//lib/sigstore/tuf/root.rb#24
class Sigstore::TUF::Root
  include ::Sigstore::Loggable
  extend ::Sigstore::Loggable::ClassMethods

  # @raise [Error::InvalidData]
  # @return [Root] a new instance of Root
  #
  # source://sigstore//lib/sigstore/tuf/root.rb#30
  def initialize(data); end

  # Returns the value of attribute consistent_snapshot.
  #
  # source://sigstore//lib/sigstore/tuf/root.rb#28
  def consistent_snapshot; end

  # @return [Boolean]
  #
  # source://sigstore//lib/sigstore/tuf/root.rb#49
  def expired?(reference_time); end

  # Returns the value of attribute expires.
  #
  # source://sigstore//lib/sigstore/tuf/root.rb#28
  def expires; end

  # source://sigstore//lib/sigstore/tuf/root.rb#45
  def verify_delegate(type, bytes, signatures); end

  # Returns the value of attribute version.
  #
  # source://sigstore//lib/sigstore/tuf/root.rb#28
  def version; end
end

# source://sigstore//lib/sigstore/tuf/root.rb#27
Sigstore::TUF::Root::TYPE = T.let(T.unsafe(nil), String)

# source://sigstore//lib/sigstore/tuf.rb#26
Sigstore::TUF::STAGING_TUF_URL = T.let(T.unsafe(nil), String)

# The class for the Snapshot role
#
# source://sigstore//lib/sigstore/tuf/snapshot.rb#21
class Sigstore::TUF::Snapshot
  # @raise [Error::InvalidData]
  # @return [Snapshot] a new instance of Snapshot
  #
  # source://sigstore//lib/sigstore/tuf/snapshot.rb#26
  def initialize(data); end

  # @return [Boolean]
  #
  # source://sigstore//lib/sigstore/tuf/snapshot.rb#35
  def expired?(reference_time); end

  # Returns the value of attribute meta.
  #
  # source://sigstore//lib/sigstore/tuf/snapshot.rb#24
  def meta; end

  # Returns the value of attribute version.
  #
  # source://sigstore//lib/sigstore/tuf/snapshot.rb#24
  def version; end
end

# source://sigstore//lib/sigstore/tuf/snapshot.rb#39
class Sigstore::TUF::Snapshot::Meta
  include ::Sigstore::TUF::MetaFile
  include ::Sigstore::TUF::BaseFile
  extend ::Sigstore::TUF::BaseFile::ClassMethods
  extend ::Sigstore::TUF::MetaFile::ClassMethods

  # Returns the value of attribute version.
  #
  # source://sigstore//lib/sigstore/tuf/snapshot.rb#42
  def version; end
end

# source://sigstore//lib/sigstore/tuf/snapshot.rb#22
Sigstore::TUF::Snapshot::TYPE = T.let(T.unsafe(nil), String)

# source://sigstore//lib/sigstore/tuf/targets.rb#22
class Sigstore::TUF::Targets
  # @raise [Error::InvalidData]
  # @return [Targets] a new instance of Targets
  #
  # source://sigstore//lib/sigstore/tuf/targets.rb#27
  def initialize(data); end

  # Returns the value of attribute delegations.
  #
  # source://sigstore//lib/sigstore/tuf/targets.rb#25
  def delegations; end

  # @return [Boolean]
  #
  # source://sigstore//lib/sigstore/tuf/targets.rb#39
  def expired?(reference_time); end

  # Returns the value of attribute targets.
  #
  # source://sigstore//lib/sigstore/tuf/targets.rb#25
  def targets; end

  # source://sigstore//lib/sigstore/tuf/targets.rb#43
  def verify_delegate(type, bytes, signatures); end

  # Returns the value of attribute version.
  #
  # source://sigstore//lib/sigstore/tuf/targets.rb#25
  def version; end
end

# source://sigstore//lib/sigstore/tuf/targets.rb#65
class Sigstore::TUF::Targets::Delegations
  # @return [Delegations] a new instance of Delegations
  #
  # source://sigstore//lib/sigstore/tuf/targets.rb#66
  def initialize(data); end

  # @return [Boolean]
  #
  # source://sigstore//lib/sigstore/tuf/targets.rb#75
  def any?; end

  # source://sigstore//lib/sigstore/tuf/targets.rb#79
  def fetch(name); end

  # source://sigstore//lib/sigstore/tuf/targets.rb#71
  def roles_for_target(target_path); end
end

# source://sigstore//lib/sigstore/tuf/targets.rb#23
Sigstore::TUF::Targets::TYPE = T.let(T.unsafe(nil), String)

# source://sigstore//lib/sigstore/tuf/targets.rb#48
class Sigstore::TUF::Targets::Target
  include ::Sigstore::TUF::BaseFile
  extend ::Sigstore::TUF::BaseFile::ClassMethods

  # @return [Target] a new instance of Target
  #
  # source://sigstore//lib/sigstore/tuf/targets.rb#53
  def initialize(data, path); end

  # Returns the value of attribute hashes.
  #
  # source://sigstore//lib/sigstore/tuf/targets.rb#49
  def hashes; end

  # Returns the value of attribute path.
  #
  # source://sigstore//lib/sigstore/tuf/targets.rb#49
  def path; end

  # source://sigstore//lib/sigstore/tuf/targets.rb#59
  def verify_length_and_hashes(data); end
end

# source://sigstore//lib/sigstore/tuf/timestamp.rb#18
class Sigstore::TUF::Timestamp
  # @raise [Error::InvalidData]
  # @return [Timestamp] a new instance of Timestamp
  #
  # source://sigstore//lib/sigstore/tuf/timestamp.rb#23
  def initialize(data); end

  # @return [Boolean]
  #
  # source://sigstore//lib/sigstore/tuf/timestamp.rb#35
  def expired?(reference_time); end

  # Returns the value of attribute expires.
  #
  # source://sigstore//lib/sigstore/tuf/timestamp.rb#21
  def expires; end

  # Returns the value of attribute snapshot_meta.
  #
  # source://sigstore//lib/sigstore/tuf/timestamp.rb#21
  def snapshot_meta; end

  # Returns the value of attribute spec_version.
  #
  # source://sigstore//lib/sigstore/tuf/timestamp.rb#21
  def spec_version; end

  # Returns the value of attribute unrecognized_fields.
  #
  # source://sigstore//lib/sigstore/tuf/timestamp.rb#21
  def unrecognized_fields; end

  # Returns the value of attribute version.
  #
  # source://sigstore//lib/sigstore/tuf/timestamp.rb#21
  def version; end
end

# source://sigstore//lib/sigstore/tuf/timestamp.rb#19
Sigstore::TUF::Timestamp::TYPE = T.let(T.unsafe(nil), String)

# source://sigstore//lib/sigstore/tuf.rb#28
class Sigstore::TUF::TrustUpdater
  include ::Sigstore::Loggable
  extend ::Sigstore::Loggable::ClassMethods

  # @return [TrustUpdater] a new instance of TrustUpdater
  #
  # source://sigstore//lib/sigstore/tuf.rb#35
  def initialize(metadata_url, offline, metadata_dir: T.unsafe(nil), targets_dir: T.unsafe(nil), target_base_url: T.unsafe(nil), config: T.unsafe(nil)); end

  # source://sigstore//lib/sigstore/tuf.rb#92
  def get_dirs(url); end

  # @raise [ArgumentError]
  #
  # source://sigstore//lib/sigstore/tuf.rb#122
  def refresh; end

  # @raise [Error::NoTrustedRoot]
  #
  # source://sigstore//lib/sigstore/tuf.rb#107
  def trusted_root_path; end

  # Returns the value of attribute updater.
  #
  # source://sigstore//lib/sigstore/tuf.rb#33
  def updater; end

  private

  # @raise [ArgumentError]
  #
  # source://sigstore//lib/sigstore/tuf.rb#130
  def fetch(uri); end
end

# source://sigstore//lib/sigstore/tuf.rb#31
Sigstore::TUF::TrustUpdater::Net = Net

# source://sigstore//lib/sigstore/tuf/trusted_metadata_set.rb#24
class Sigstore::TUF::TrustedMetadataSet
  include ::Sigstore::Loggable
  extend ::Sigstore::Loggable::ClassMethods

  # @return [TrustedMetadataSet] a new instance of TrustedMetadataSet
  #
  # source://sigstore//lib/sigstore/tuf/trusted_metadata_set.rb#27
  def initialize(root_data, envelope_type, reference_time: T.unsafe(nil)); end

  # source://sigstore//lib/sigstore/tuf/trusted_metadata_set.rb#121
  def [](role); end

  # @return [Boolean]
  #
  # source://sigstore//lib/sigstore/tuf/trusted_metadata_set.rb#117
  def include?(type); end

  # source://sigstore//lib/sigstore/tuf/trusted_metadata_set.rb#36
  def root; end

  # @raise [Error::BadUpdateOrder]
  #
  # source://sigstore//lib/sigstore/tuf/trusted_metadata_set.rb#40
  def root=(data); end

  # source://sigstore//lib/sigstore/tuf/trusted_metadata_set.rb#52
  def snapshot; end

  # @raise [Error::BadUpdateOrder]
  #
  # source://sigstore//lib/sigstore/tuf/trusted_metadata_set.rb#88
  def snapshot=(data, trusted: T.unsafe(nil)); end

  # source://sigstore//lib/sigstore/tuf/trusted_metadata_set.rb#56
  def timestamp; end

  # @raise [Error::BadUpdateOrder]
  #
  # source://sigstore//lib/sigstore/tuf/trusted_metadata_set.rb#60
  def timestamp=(data); end

  # @raise [Error::BadUpdateOrder]
  #
  # source://sigstore//lib/sigstore/tuf/trusted_metadata_set.rb#125
  def update_delegated_targets(data, role, parent_role); end

  private

  # @raise [Error::ExpiredMetadata]
  #
  # source://sigstore//lib/sigstore/tuf/trusted_metadata_set.rb#184
  def check_final_snapshot; end

  # @raise [Error::ExpiredMetadata]
  #
  # source://sigstore//lib/sigstore/tuf/trusted_metadata_set.rb#177
  def check_final_timestamp; end

  # source://sigstore//lib/sigstore/tuf/trusted_metadata_set.rb#160
  def load_data(type, data, delegator, role_name = T.unsafe(nil)); end

  # source://sigstore//lib/sigstore/tuf/trusted_metadata_set.rb#152
  def load_trusted_root(data); end
end

# source://sigstore//lib/sigstore/tuf/updater.rb#27
class Sigstore::TUF::Updater
  include ::Sigstore::Loggable
  extend ::Sigstore::Loggable::ClassMethods

  # @return [Updater] a new instance of Updater
  #
  # source://sigstore//lib/sigstore/tuf/updater.rb#30
  def initialize(metadata_dir:, metadata_base_url:, target_base_url:, target_dir:, fetcher:, config: T.unsafe(nil)); end

  # @raise [ArgumentError]
  #
  # source://sigstore//lib/sigstore/tuf/updater.rb#73
  def download_target(target_info, filepath = T.unsafe(nil), target_base_url = T.unsafe(nil)); end

  # source://sigstore//lib/sigstore/tuf/updater.rb#60
  def find_cached_target(target_info, filepath = T.unsafe(nil)); end

  # source://sigstore//lib/sigstore/tuf/updater.rb#55
  def get_targetinfo(target_path); end

  # source://sigstore//lib/sigstore/tuf/updater.rb#48
  def refresh; end

  private

  # source://sigstore//lib/sigstore/tuf/updater.rb#192
  def download_metadata(role_name, version); end

  # @raise [ArgumentError]
  #
  # source://sigstore//lib/sigstore/tuf/updater.rb#261
  def generate_target_file_path(target_info); end

  # source://sigstore//lib/sigstore/tuf/updater.rb#106
  def load_local_metadata(role_name); end

  # source://sigstore//lib/sigstore/tuf/updater.rb#112
  def load_root; end

  # source://sigstore//lib/sigstore/tuf/updater.rb#151
  def load_snapshot; end

  # source://sigstore//lib/sigstore/tuf/updater.rb#166
  def load_targets(role, parent_role); end

  # source://sigstore//lib/sigstore/tuf/updater.rb#129
  def load_timestamp; end

  # source://sigstore//lib/sigstore/tuf/updater.rb#200
  def metadata_url(role_name, version); end

  # source://sigstore//lib/sigstore/tuf/updater.rb#209
  def persist_metadata(role_name, data); end

  # source://sigstore//lib/sigstore/tuf/updater.rb#223
  def preorder_depth_first_walk(target_path); end
end

# source://sigstore//lib/sigstore/tuf/config.rb#19
class Sigstore::TUF::UpdaterConfig
  # @return [UpdaterConfig] a new instance of UpdaterConfig
  #
  # source://sigstore//lib/sigstore/tuf/config.rb#23
  def initialize(max_root_rotations: T.unsafe(nil), max_delegations: T.unsafe(nil), root_max_length: T.unsafe(nil), timestamp_max_length: T.unsafe(nil), snapshot_max_length: T.unsafe(nil), targets_max_length: T.unsafe(nil), prefix_targets_with_hash: T.unsafe(nil), envelope_type: T.unsafe(nil), app_user_agent: T.unsafe(nil)); end

  # Returns the value of attribute app_user_agent.
  #
  # source://sigstore//lib/sigstore/tuf/config.rb#20
  def app_user_agent; end

  # Returns the value of attribute envelope_type.
  #
  # source://sigstore//lib/sigstore/tuf/config.rb#20
  def envelope_type; end

  # Returns the value of attribute max_delegations.
  #
  # source://sigstore//lib/sigstore/tuf/config.rb#20
  def max_delegations; end

  # Returns the value of attribute max_root_rotations.
  #
  # source://sigstore//lib/sigstore/tuf/config.rb#20
  def max_root_rotations; end

  # Returns the value of attribute prefix_targets_with_hash.
  #
  # source://sigstore//lib/sigstore/tuf/config.rb#20
  def prefix_targets_with_hash; end

  # Returns the value of attribute root_max_length.
  #
  # source://sigstore//lib/sigstore/tuf/config.rb#20
  def root_max_length; end

  # Returns the value of attribute snapshot_max_length.
  #
  # source://sigstore//lib/sigstore/tuf/config.rb#20
  def snapshot_max_length; end

  # Returns the value of attribute targets_max_length.
  #
  # source://sigstore//lib/sigstore/tuf/config.rb#20
  def targets_max_length; end

  # Returns the value of attribute timestamp_max_length.
  #
  # source://sigstore//lib/sigstore/tuf/config.rb#20
  def timestamp_max_length; end
end

# source://sigstore//lib/sigstore/trusted_root.rb#29
class Sigstore::TrustedRoot
  # source://sigstore//lib/sigstore/trusted_root.rb#77
  def certificate_authority_for_signing; end

  # @raise [Error::InvalidBundle]
  #
  # source://sigstore//lib/sigstore/trusted_root.rb#55
  def ctfe_keys; end

  # @raise [Error::InvalidBundle]
  #
  # source://sigstore//lib/sigstore/trusted_root.rb#62
  def fulcio_cert_chain; end

  # @raise [Error::InvalidBundle]
  #
  # source://sigstore//lib/sigstore/trusted_root.rb#48
  def rekor_keys; end

  # source://sigstore//lib/sigstore/trusted_root.rb#71
  def tlog_for_signing; end

  private

  # source://sigstore//lib/sigstore/trusted_root.rb#94
  def ca_keys(certificate_authorities, allow_expired:); end

  # @return [Boolean]
  #
  # source://sigstore//lib/sigstore/trusted_root.rb#106
  def timerange_valid?(period, allow_expired:); end

  # source://sigstore//lib/sigstore/trusted_root.rb#85
  def tlog_keys(tlogs); end

  class << self
    # source://sigstore//lib/sigstore/trusted_root.rb#43
    def from_file(path); end

    # source://sigstore//lib/sigstore/trusted_root.rb#38
    def from_tuf(url, offline); end

    # source://sigstore//lib/sigstore/trusted_root.rb#30
    def production(offline: T.unsafe(nil)); end

    # source://sigstore//lib/sigstore/trusted_root.rb#34
    def staging(offline: T.unsafe(nil)); end
  end
end

# source://sigstore//lib/sigstore/models.rb#35
class Sigstore::VerificationFailure < ::Sigstore::VerificationResult
  # @return [VerificationFailure] a new instance of VerificationFailure
  #
  # source://sigstore//lib/sigstore/models.rb#39
  def initialize(reason); end

  # Returns the value of attribute reason.
  #
  # source://sigstore//lib/sigstore/models.rb#37
  def reason; end
end

# source://sigstore//lib/sigstore/models.rb#78
class Sigstore::VerificationInput
  # @return [VerificationInput] a new instance of VerificationInput
  #
  # source://sigstore//lib/sigstore/models.rb#81
  def initialize(*_arg0); end

  # Returns the value of attribute hashed_input.
  #
  # source://sigstore//lib/sigstore/models.rb#79
  def hashed_input; end

  # Returns the value of attribute sbundle.
  #
  # source://sigstore//lib/sigstore/models.rb#79
  def sbundle; end

  # Returns the value of attribute trusted_root.
  #
  # source://sigstore//lib/sigstore/models.rb#79
  def trusted_root; end
end

# source://sigstore//lib/sigstore/models.rb#22
class Sigstore::VerificationResult < ::Struct
  # Returns the value of attribute success
  #
  # @return [Object] the current value of success
  #
  # source://sigstore//lib/sigstore/models.rb#22
  def success; end

  # Sets the attribute success
  #
  # @param value [Object] the value to set the attribute success to.
  # @return [Object] the newly set value
  #
  # source://sigstore//lib/sigstore/models.rb#22
  def success=(_); end

  # Returns the value of attribute success
  #
  # @return [Object] the current value of success
  #
  # source://sigstore//lib/sigstore/models.rb#25
  def verified?; end

  class << self
    # source://sigstore//lib/sigstore/models.rb#22
    def [](*_arg0); end

    # source://sigstore//lib/sigstore/models.rb#22
    def inspect; end

    # source://sigstore//lib/sigstore/models.rb#22
    def keyword_init?; end

    # source://sigstore//lib/sigstore/models.rb#22
    def members; end

    # source://sigstore//lib/sigstore/models.rb#22
    def new(*_arg0); end
  end
end

# source://sigstore//lib/sigstore/models.rb#28
class Sigstore::VerificationSuccess < ::Sigstore::VerificationResult
  # @return [VerificationSuccess] a new instance of VerificationSuccess
  #
  # source://sigstore//lib/sigstore/models.rb#30
  def initialize; end
end

# source://sigstore//lib/sigstore/verifier.rb#26
class Sigstore::Verifier
  include ::Sigstore::Loggable
  extend ::Sigstore::Loggable::ClassMethods

  # @return [Verifier] a new instance of Verifier
  #
  # source://sigstore//lib/sigstore/verifier.rb#31
  def initialize(rekor_client:, fulcio_cert_chain:, timestamp_authorities:, rekor_keyring:, ct_keyring:); end

  # Returns the value of attribute rekor_client.
  #
  # source://sigstore//lib/sigstore/verifier.rb#29
  def rekor_client; end

  # source://sigstore//lib/sigstore/verifier.rb#57
  def verify(input:, policy:, offline:); end

  # @raise [Error::InvalidCertificate]
  #
  # source://sigstore//lib/sigstore/verifier.rb#257
  def verify_scts(leaf_certificate, chain); end

  private

  # source://sigstore//lib/sigstore/verifier.rb#474
  def diff_json(a, b); end

  # source://sigstore//lib/sigstore/verifier.rb#352
  def extract_timestamp_from_verification_data(data); end

  # @raise [Error::InvalidCertificate]
  #
  # source://sigstore//lib/sigstore/verifier.rb#344
  def find_issuer_cert(chain); end

  # @raise [Error::InvalidBundle]
  #
  # source://sigstore//lib/sigstore/verifier.rb#411
  def find_rekor_entry(bundle, hashed_input, offline:); end

  # source://sigstore//lib/sigstore/verifier.rb#293
  def pack_digitally_signed(sct, certificate, issuer_key_id = T.unsafe(nil)); end

  # @raise [Error::InvalidBundle]
  #
  # source://sigstore//lib/sigstore/verifier.rb#218
  def verify_dsse(dsse_envelope, public_key); end

  # @raise [Error::InvalidBundle]
  #
  # source://sigstore//lib/sigstore/verifier.rb#233
  def verify_in_toto(input, in_toto_payload); end

  # source://sigstore//lib/sigstore/verifier.rb#205
  def verify_raw(public_key, signature, data); end

  # source://sigstore//lib/sigstore/verifier.rb#278
  def verify_sct(sct, certificate, chain, ct_keyring); end

  class << self
    # source://sigstore//lib/sigstore/verifier.rb#39
    def for_trust_root(trust_root:); end

    # source://sigstore//lib/sigstore/verifier.rb#49
    def production(trust_root: T.unsafe(nil)); end

    # source://sigstore//lib/sigstore/verifier.rb#53
    def staging(trust_root: T.unsafe(nil)); end
  end
end
