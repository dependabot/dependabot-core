# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `ostruct` gem.
# Please instead update this file by running `bin/tapioca gem ostruct`.


# An OpenStruct is a data structure, similar to a Hash, that allows the
# definition of arbitrary attributes with their accompanying values. This is
# accomplished by using Ruby's metaprogramming to define methods on the class
# itself.
#
# == Examples
#
#   require "ostruct"
#
#   person = OpenStruct.new
#   person.name = "John Smith"
#   person.age  = 70
#
#   person.name      # => "John Smith"
#   person.age       # => 70
#   person.address   # => nil
#
# An OpenStruct employs a Hash internally to store the attributes and values
# and can even be initialized with one:
#
#   australia = OpenStruct.new(:country => "Australia", :capital => "Canberra")
#     # => #<OpenStruct country="Australia", capital="Canberra">
#
# Hash keys with spaces or characters that could normally not be used for
# method calls (e.g. <code>()[]*</code>) will not be immediately available
# on the OpenStruct object as a method for retrieval or assignment, but can
# still be reached through the Object#send method or using [].
#
#   measurements = OpenStruct.new("length (in inches)" => 24)
#   measurements[:"length (in inches)"]       # => 24
#   measurements.send("length (in inches)")   # => 24
#
#   message = OpenStruct.new(:queued? => true)
#   message.queued?                           # => true
#   message.send("queued?=", false)
#   message.queued?                           # => false
#
# Removing the presence of an attribute requires the execution of the
# delete_field method as setting the property value to +nil+ will not
# remove the attribute.
#
#   first_pet  = OpenStruct.new(:name => "Rowdy", :owner => "John Smith")
#   second_pet = OpenStruct.new(:name => "Rowdy")
#
#   first_pet.owner = nil
#   first_pet                 # => #<OpenStruct name="Rowdy", owner=nil>
#   first_pet == second_pet   # => false
#
#   first_pet.delete_field(:owner)
#   first_pet                 # => #<OpenStruct name="Rowdy">
#   first_pet == second_pet   # => true
#
# Ractor compatibility: A frozen OpenStruct with shareable values is itself shareable.
#
# == Caveats
#
# An OpenStruct utilizes Ruby's method lookup structure to find and define the
# necessary methods for properties. This is accomplished through the methods
# method_missing and define_singleton_method.
#
# This should be a consideration if there is a concern about the performance of
# the objects that are created, as there is much more overhead in the setting
# of these properties compared to using a Hash or a Struct.
# Creating an open struct from a small Hash and accessing a few of the
# entries can be 200 times slower than accessing the hash directly.
#
# This is a potential security issue; building OpenStruct from untrusted user data
# (e.g. JSON web request) may be susceptible to a "symbol denial of service" attack
# since the keys create methods and names of methods are never garbage collected.
#
# This may also be the source of incompatibilities between Ruby versions:
#
#   o = OpenStruct.new
#   o.then # => nil in Ruby < 2.6, enumerator for Ruby >= 2.6
#
# Builtin methods may be overwritten this way, which may be a source of bugs
# or security issues:
#
#   o = OpenStruct.new
#   o.methods # => [:to_h, :marshal_load, :marshal_dump, :each_pair, ...
#   o.methods = [:foo, :bar]
#   o.methods # => [:foo, :bar]
#
# To help remedy clashes, OpenStruct uses only protected/private methods ending with <code>!</code>
# and defines aliases for builtin public methods by adding a <code>!</code>:
#
#   o = OpenStruct.new(make: 'Bentley', class: :luxury)
#   o.class # => :luxury
#   o.class! # => OpenStruct
#
# It is recommended (but not enforced) to not use fields ending in <code>!</code>;
# Note that a subclass' methods may not be overwritten, nor can OpenStruct's own methods
# ending with <code>!</code>.
#
# For all these reasons, consider not using OpenStruct at all.
#
# source://ostruct//lib/ostruct.rb#109
class OpenStruct
  # Creates a new OpenStruct object.  By default, the resulting OpenStruct
  # object will have no attributes.
  #
  # The optional +hash+, if given, will generate attributes and values
  # (can be a Hash, an OpenStruct or a Struct).
  # For example:
  #
  #   require "ostruct"
  #   hash = { "country" => "Australia", :capital => "Canberra" }
  #   data = OpenStruct.new(hash)
  #
  #   data   # => #<OpenStruct country="Australia", capital="Canberra">
  #
  # @return [OpenStruct] a new instance of OpenStruct
  #
  # source://ostruct//lib/ostruct.rb#134
  def initialize(hash = T.unsafe(nil)); end

  # Compares this object and +other+ for equality.  An OpenStruct is equal to
  # +other+ when +other+ is an OpenStruct and the two objects' Hash tables are
  # equal.
  #
  #   require "ostruct"
  #   first_pet  = OpenStruct.new("name" => "Rowdy")
  #   second_pet = OpenStruct.new(:name  => "Rowdy")
  #   third_pet  = OpenStruct.new("name" => "Rowdy", :age => nil)
  #
  #   first_pet == second_pet   # => true
  #   first_pet == third_pet    # => false
  #
  # source://ostruct//lib/ostruct.rb#423
  def ==(other); end

  # :call-seq:
  #   ostruct[name]  -> object
  #
  # Returns the value of an attribute, or +nil+ if there is no such attribute.
  #
  #   require "ostruct"
  #   person = OpenStruct.new("name" => "John Smith", "age" => 70)
  #   person[:age]   # => 70, same as person.age
  #
  # source://ostruct//lib/ostruct.rb#303
  def [](name); end

  # :call-seq:
  #   ostruct[name] = obj  -> obj
  #
  # Sets the value of an attribute.
  #
  #   require "ostruct"
  #   person = OpenStruct.new("name" => "John Smith", "age" => 70)
  #   person[:age] = 42   # equivalent to person.age = 42
  #   person.age          # => 42
  #
  # source://ostruct//lib/ostruct.rb#318
  def []=(name, value); end

  # Removes the named field from the object and returns the value the field
  # contained if it was defined. You may optionally provide a block.
  # If the field is not defined, the result of the block is returned,
  # or a NameError is raised if no block was given.
  #
  #   require "ostruct"
  #
  #   person = OpenStruct.new(name: "John", age: 70, pension: 300)
  #
  #   person.delete_field!("age")  # => 70
  #   person                       # => #<OpenStruct name="John", pension=300>
  #
  # Setting the value to +nil+ will not remove the attribute:
  #
  #   person.pension = nil
  #   person                 # => #<OpenStruct name="John", pension=nil>
  #
  #   person.delete_field('number')  # => NameError
  #
  #   person.delete_field('number') { 8675_309 } # => 8675309
  #
  # source://ostruct//lib/ostruct.rb#371
  def delete_field(name, &block); end

  # source://ostruct//lib/ostruct.rb#371
  def delete_field!(name, &block); end

  # :call-seq:
  #   ostruct.dig(name, *identifiers) -> object
  #
  # Finds and returns the object in nested objects
  # that is specified by +name+ and +identifiers+.
  # The nested objects may be instances of various classes.
  # See {Dig Methods}[rdoc-ref:dig_methods.rdoc].
  #
  # Examples:
  #   require "ostruct"
  #   address = OpenStruct.new("city" => "Anytown NC", "zip" => 12345)
  #   person  = OpenStruct.new("name" => "John Smith", "address" => address)
  #   person.dig(:address, "zip") # => 12345
  #   person.dig(:business_address, "zip") # => nil
  #
  # source://ostruct//lib/ostruct.rb#340
  def dig(name, *names); end

  # source://ostruct//lib/ostruct.rb#340
  def dig!(name, *names); end

  # :call-seq:
  #   ostruct.each_pair {|name, value| block }  -> ostruct
  #   ostruct.each_pair                         -> Enumerator
  #
  # Yields all attributes (as symbols) along with the corresponding values
  # or returns an enumerator if no block is given.
  #
  #   require "ostruct"
  #   data = OpenStruct.new("country" => "Australia", :capital => "Canberra")
  #   data.each_pair.to_a   # => [[:country, "Australia"], [:capital, "Canberra"]]
  #
  # source://ostruct//lib/ostruct.rb#211
  def each_pair; end

  # source://ostruct//lib/ostruct.rb#211
  def each_pair!; end

  # Provides marshalling support for use by the YAML library.
  #
  # source://ostruct//lib/ostruct.rb#446
  def encode_with(coder); end

  # source://ostruct//lib/ostruct.rb#446
  def encode_with!(coder); end

  # Compares this object and +other+ for equality.  An OpenStruct is eql? to
  # +other+ when +other+ is an OpenStruct and the two objects' Hash tables are
  # eql?.
  #
  # @return [Boolean]
  #
  # source://ostruct//lib/ostruct.rb#433
  def eql?(other); end

  # source://ostruct//lib/ostruct.rb#269
  def freeze; end

  # source://ostruct//lib/ostruct.rb#269
  def freeze!; end

  # Computes a hash code for this OpenStruct.
  #
  # source://ostruct//lib/ostruct.rb#439
  def hash; end

  # source://ostruct//lib/ostruct.rb#439
  def hash!; end

  # Provides marshalling support for use by the YAML library.
  #
  # source://ostruct//lib/ostruct.rb#459
  def init_with(coder); end

  # source://ostruct//lib/ostruct.rb#459
  def init_with!(coder); end

  # Returns a string containing a detailed summary of the keys and values.
  #
  # source://ostruct//lib/ostruct.rb#388
  def inspect; end

  # source://ostruct//lib/ostruct.rb#388
  def inspect!; end

  # Provides marshalling support for use by the Marshal library.
  #
  # source://ostruct//lib/ostruct.rb#220
  def marshal_dump; end

  # source://ostruct//lib/ostruct.rb#220
  def marshal_dump!; end

  # source://ostruct//lib/ostruct.rb#406
  def table; end

  # source://ostruct//lib/ostruct.rb#182
  def to_h(&block); end

  # source://ostruct//lib/ostruct.rb#182
  def to_h!(&block); end

  # Returns a string containing a detailed summary of the keys and values.
  #
  # source://ostruct//lib/ostruct.rb#388
  def to_s; end

  # source://ostruct//lib/ostruct.rb#388
  def to_s!; end

  protected

  # source://ostruct//lib/ostruct.rb#406
  def table!; end

  private

  # source://ostruct//lib/ostruct.rb#147
  def initialize_clone(orig); end

  # source://ostruct//lib/ostruct.rb#152
  def initialize_dup(orig); end

  # source://ostruct//lib/ostruct.rb#251
  def is_method_protected!(name); end

  #
  # Provides marshalling support for use by the Marshal library.
  #
  # source://ostruct//lib/ostruct.rb#157
  def marshal_load(hash); end

  # source://ostruct//lib/ostruct.rb#274
  def method_missing(mid, *args); end

  # Used internally to defined properties on the
  # OpenStruct. It does this by using the metaprogramming function
  # define_singleton_method for both the getter method and the setter method.
  #
  # source://ostruct//lib/ostruct.rb#234
  def new_ostruct_member!(name); end

  # :call-seq:
  #   ostruct[name] = obj  -> obj
  #
  # Sets the value of an attribute.
  #
  #   require "ostruct"
  #   person = OpenStruct.new("name" => "John Smith", "age" => 70)
  #   person[:age] = 42   # equivalent to person.age = 42
  #   person.age          # => 42
  #
  # source://ostruct//lib/ostruct.rb#318
  def set_ostruct_member_value!(name, value); end

  # source://ostruct//lib/ostruct.rb#157
  def update_to_values!(hash); end
end

# source://ostruct//lib/ostruct.rb#112
OpenStruct::HAS_PERFORMANCE_WARNINGS = T.let(T.unsafe(nil), TrueClass)

# source://ostruct//lib/ostruct.rb#110
OpenStruct::VERSION = T.let(T.unsafe(nil), String)
