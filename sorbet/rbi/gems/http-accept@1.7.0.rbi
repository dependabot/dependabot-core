# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `http-accept` gem.
# Please instead update this file by running `bin/tapioca gem http-accept`.

# source://http-accept//lib/http/accept/version.rb#21
module HTTP; end

# source://http-accept//lib/http/accept/version.rb#22
module HTTP::Accept; end

# A content type is different from a media range, in that a content type should not have any wild cards.
#
# source://http-accept//lib/http/accept/content_type.rb#27
class HTTP::Accept::ContentType < ::HTTP::Accept::MediaTypes::MediaRange
  # @raise [ArgumentError]
  # @return [ContentType] a new instance of ContentType
  #
  # source://http-accept//lib/http/accept/content_type.rb#28
  def initialize(mime_type, parameters = T.unsafe(nil)); end
end

# source://http-accept//lib/http/accept/encodings.rb#29
module HTTP::Accept::Encodings
  class << self
    # Parse the list of browser preferred content codings and return ordered by priority. If no
    # `Accept-Encoding:` header is specified, the behaviour is the same as if
    # `Accept-Encoding: *` was provided, and if a blank `Accept-Encoding:` header value is
    # specified, the behaviour is the same as if `Accept-Encoding: identity` was provided
    # (according to RFC).
    #
    # source://http-accept//lib/http/accept/encodings.rb#74
    def browser_preferred_content_codings(env); end

    # source://http-accept//lib/http/accept/encodings.rb#57
    def parse(text); end
  end
end

# source://http-accept//lib/http/accept/encodings.rb#36
HTTP::Accept::Encodings::CODINGS = T.let(T.unsafe(nil), Regexp)

# https://tools.ietf.org/html/rfc7231#section-5.3.4
#
# source://http-accept//lib/http/accept/encodings.rb#31
HTTP::Accept::Encodings::CONTENT_CODING = T.let(T.unsafe(nil), Regexp)

# source://http-accept//lib/http/accept/encodings.rb#38
class HTTP::Accept::Encodings::ContentCoding < ::Struct
  # Returns the value of attribute encoding
  #
  # @return [Object] the current value of encoding
  def encoding; end

  # Sets the attribute encoding
  #
  # @param value [Object] the value to set the attribute encoding to.
  # @return [Object] the newly set value
  def encoding=(_); end

  # Returns the value of attribute q
  #
  # @return [Object] the current value of q
  def q; end

  # Sets the attribute q
  #
  # @param value [Object] the value to set the attribute q to.
  # @return [Object] the newly set value
  def q=(_); end

  # source://http-accept//lib/http/accept/encodings.rb#39
  def quality_factor; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end

    # @raise [ParseError]
    #
    # source://http-accept//lib/http/accept/encodings.rb#43
    def parse(scanner); end
  end
end

# source://http-accept//lib/http/accept/encodings.rb#65
HTTP::Accept::Encodings::HTTP_ACCEPT_ENCODING = T.let(T.unsafe(nil), String)

# source://http-accept//lib/http/accept/encodings.rb#67
HTTP::Accept::Encodings::IDENTITY_CONTENT_CODING = T.let(T.unsafe(nil), HTTP::Accept::Encodings::ContentCoding)

# https://tools.ietf.org/html/rfc7231#section-5.3.1
#
# source://http-accept//lib/http/accept/encodings.rb#34
HTTP::Accept::Encodings::QVALUE = T.let(T.unsafe(nil), Regexp)

# source://http-accept//lib/http/accept/encodings.rb#66
HTTP::Accept::Encodings::WILDCARD_CONTENT_CODING = T.let(T.unsafe(nil), HTTP::Accept::Encodings::ContentCoding)

# source://http-accept//lib/http/accept/languages.rb#28
module HTTP::Accept::Languages
  class << self
    # source://http-accept//lib/http/accept/languages.rb#118
    def parse(text); end
  end
end

# https://greenbytes.de/tech/webdav/rfc7231.html#quality.values
#
# source://http-accept//lib/http/accept/languages.rb#36
HTTP::Accept::Languages::LANGUAGE_RANGE = T.let(T.unsafe(nil), Regexp)

# https://tools.ietf.org/html/rfc3066#section-2.1
#
# source://http-accept//lib/http/accept/languages.rb#30
HTTP::Accept::Languages::LOCALE = T.let(T.unsafe(nil), Regexp)

# source://http-accept//lib/http/accept/languages.rb#99
class HTTP::Accept::Languages::LanguageRange < ::Struct
  # Returns the value of attribute locale
  #
  # @return [Object] the current value of locale
  def locale; end

  # Sets the attribute locale
  #
  # @param value [Object] the value to set the attribute locale to.
  # @return [Object] the newly set value
  def locale=(_); end

  # Returns the value of attribute q
  #
  # @return [Object] the current value of q
  def q; end

  # Sets the attribute q
  #
  # @param value [Object] the value to set the attribute q to.
  # @return [Object] the newly set value
  def q=(_); end

  # source://http-accept//lib/http/accept/languages.rb#100
  def quality_factor; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end

    # @raise [ParseError]
    #
    # source://http-accept//lib/http/accept/languages.rb#104
    def parse(scanner); end
  end
end

# Provides an efficient data-structure for matching the Accept-Languages header to set of available locales according to https://tools.ietf.org/html/rfc7231#section-5.3.5 and https://tools.ietf.org/html/rfc4647#section-2.3
#
# source://http-accept//lib/http/accept/languages.rb#39
class HTTP::Accept::Languages::Locales
  # @return [Locales] a new instance of Locales
  #
  # source://http-accept//lib/http/accept/languages.rb#52
  def initialize(names); end

  # Returns the intersection of others retaining order.
  #
  # source://http-accept//lib/http/accept/languages.rb#78
  def &(languages); end

  # source://http-accept//lib/http/accept/languages.rb#90
  def +(others); end

  # source://http-accept//lib/http/accept/languages.rb#68
  def each(&block); end

  # source://http-accept//lib/http/accept/languages.rb#61
  def freeze; end

  # @return [Boolean]
  #
  # source://http-accept//lib/http/accept/languages.rb#82
  def include?(locale_name); end

  # source://http-accept//lib/http/accept/languages.rb#86
  def join(*args); end

  # Returns the value of attribute names.
  #
  # source://http-accept//lib/http/accept/languages.rb#74
  def names; end

  # Returns the value of attribute patterns.
  #
  # source://http-accept//lib/http/accept/languages.rb#75
  def patterns; end

  # source://http-accept//lib/http/accept/languages.rb#94
  def to_a; end

  class << self
    # source://http-accept//lib/http/accept/languages.rb#40
    def expand(locale, into); end
  end
end

# https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.9
#
# source://http-accept//lib/http/accept/languages.rb#33
HTTP::Accept::Languages::QVALUE = T.let(T.unsafe(nil), Regexp)

# Parse and process the HTTP Accept: header.
#
# source://http-accept//lib/http/accept/media_types/map.rb#23
module HTTP::Accept::MediaTypes
  class << self
    # Parse the list of browser preferred content types and return ordered by priority. If no `Accept:` header is specified, the behaviour is the same as if `Accept: */*` was provided (according to RFC).
    #
    # source://http-accept//lib/http/accept/media_types.rb#114
    def browser_preferred_media_types(env); end

    # source://http-accept//lib/http/accept/media_types.rb#102
    def parse(text, normalize_whitespace = T.unsafe(nil)); end
  end
end

# source://http-accept//lib/http/accept/media_types.rb#110
HTTP::Accept::MediaTypes::HTTP_ACCEPT = T.let(T.unsafe(nil), String)

# According to https://tools.ietf.org/html/rfc7231#section-5.3.2
#
# source://http-accept//lib/http/accept/media_types.rb#34
HTTP::Accept::MediaTypes::MIME_TYPE = T.let(T.unsafe(nil), Regexp)

# Map a set of mime types to objects.
#
# source://http-accept//lib/http/accept/media_types/map.rb#25
class HTTP::Accept::MediaTypes::Map
  # @return [Map] a new instance of Map
  #
  # source://http-accept//lib/http/accept/media_types/map.rb#28
  def initialize; end

  # Add a converter to the collection. A converter can be anything that responds to #content_type. Objects will be considered in the order they are added, subsequent objects cannot override previously defined media types. `object` must respond to #split('/', 2) which should give the type and subtype.
  #
  # source://http-accept//lib/http/accept/media_types/map.rb#66
  def <<(object); end

  # source://http-accept//lib/http/accept/media_types/map.rb#61
  def [](media_range); end

  # source://http-accept//lib/http/accept/media_types/map.rb#57
  def []=(media_range, object); end

  # Given a list of content types (e.g. from browser_preferred_content_types), return the best converter. Media types can be an array of MediaRange or String values.
  #
  # source://http-accept//lib/http/accept/media_types/map.rb#42
  def for(media_types); end

  # source://http-accept//lib/http/accept/media_types/map.rb#32
  def freeze; end
end

# source://http-accept//lib/http/accept/media_types/map.rb#26
HTTP::Accept::MediaTypes::Map::WILDCARD = T.let(T.unsafe(nil), String)

# A single entry in the Accept: header, which includes a mime type and associated parameters.
#
# source://http-accept//lib/http/accept/media_types.rb#38
class HTTP::Accept::MediaTypes::MediaRange < ::Struct
  # source://http-accept//lib/http/accept/media_types.rb#47
  def ===(other); end

  # Returns the value of attribute mime_type
  #
  # @return [Object] the current value of mime_type
  def mime_type; end

  # Sets the attribute mime_type
  #
  # @param value [Object] the value to set the attribute mime_type to.
  # @return [Object] the newly set value
  def mime_type=(_); end

  # Returns the value of attribute parameters
  #
  # @return [Object] the current value of parameters
  def parameters; end

  # Sets the attribute parameters
  #
  # @param value [Object] the value to set the attribute parameters to.
  # @return [Object] the newly set value
  def parameters=(_); end

  # source://http-accept//lib/http/accept/media_types.rb#39
  def parameters_string; end

  # source://http-accept//lib/http/accept/media_types.rb#61
  def quality_factor; end

  # source://http-accept//lib/http/accept/media_types.rb#65
  def split(on = T.unsafe(nil), count = T.unsafe(nil)); end

  # source://http-accept//lib/http/accept/media_types.rb#55
  def to_s; end

  # source://http-accept//lib/http/accept/media_types.rb#55
  def to_str; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end

    # @raise [ParseError]
    #
    # source://http-accept//lib/http/accept/media_types.rb#86
    def parse(scanner, normalize_whitespace = T.unsafe(nil)); end

    # source://http-accept//lib/http/accept/media_types.rb#69
    def parse_parameters(scanner, normalize_whitespace); end
  end
end

# source://http-accept//lib/http/accept/media_types.rb#35
HTTP::Accept::MediaTypes::PARAMETER = T.let(T.unsafe(nil), Regexp)

# source://http-accept//lib/http/accept/media_types.rb#111
HTTP::Accept::MediaTypes::WILDCARD_MEDIA_RANGE = T.let(T.unsafe(nil), HTTP::Accept::MediaTypes::MediaRange)

# source://http-accept//lib/http/accept/parse_error.rb#23
class HTTP::Accept::ParseError < ::ArgumentError; end

# source://http-accept//lib/http/accept/quoted_string.rb#25
HTTP::Accept::QUOTED_STRING = T.let(T.unsafe(nil), Regexp)

# source://http-accept//lib/http/accept/quoted_string.rb#27
module HTTP::Accept::QuotedString
  class << self
    # Quote a string if required. Doesn't handle newlines correctly currently.
    #
    # source://http-accept//lib/http/accept/quoted_string.rb#44
    def quote(value, force = T.unsafe(nil)); end

    # Unquote a "quoted-string" value according to https://tools.ietf.org/html/rfc7230#section-3.2.6
    # It should already match the QUOTED_STRING pattern above by the parser.
    #
    # source://http-accept//lib/http/accept/quoted_string.rb#30
    def unquote(value, normalize_whitespace = T.unsafe(nil)); end
  end
end

# source://http-accept//lib/http/accept/sort.rb#23
module HTTP::Accept::Sort
  class << self
    # This sorts items with higher priority first, and keeps items with the same priority in the same relative order.
    #
    # source://http-accept//lib/http/accept/sort.rb#25
    def by_quality_factor(items); end
  end
end

# According to https://tools.ietf.org/html/rfc7231#appendix-C
#
# source://http-accept//lib/http/accept/quoted_string.rb#24
HTTP::Accept::TOKEN = T.let(T.unsafe(nil), Regexp)

# source://http-accept//lib/http/accept/version.rb#23
HTTP::Accept::VERSION = T.let(T.unsafe(nil), String)
