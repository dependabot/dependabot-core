# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `net-http` gem.
# Please instead update this file by running `bin/tapioca gem net-http`.


# \Class \Net::HTTP provides a rich library that implements the client
# in a client-server model that uses the \HTTP request-response protocol.
# For information about \HTTP, see:
#
# - {Hypertext Transfer Protocol}[https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol].
# - {Technical overview}[https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Technical_overview].
#
# == About the Examples
#
# :include: doc/net-http/examples.rdoc
#
# == Strategies
#
# - If you will make only a few GET requests,
#   consider using {OpenURI}[https://docs.ruby-lang.org/en/master/OpenURI.html].
# - If you will make only a few requests of all kinds,
#   consider using the various singleton convenience methods in this class.
#   Each of the following methods automatically starts and finishes
#   a {session}[rdoc-ref:Net::HTTP@Sessions] that sends a single request:
#
#     # Return string response body.
#     Net::HTTP.get(hostname, path)
#     Net::HTTP.get(uri)
#
#     # Write string response body to $stdout.
#     Net::HTTP.get_print(hostname, path)
#     Net::HTTP.get_print(uri)
#
#     # Return response as Net::HTTPResponse object.
#     Net::HTTP.get_response(hostname, path)
#     Net::HTTP.get_response(uri)
#     data = '{"title": "foo", "body": "bar", "userId": 1}'
#     Net::HTTP.post(uri, data)
#     params = {title: 'foo', body: 'bar', userId: 1}
#     Net::HTTP.post_form(uri, params)
#     data = '{"title": "foo", "body": "bar", "userId": 1}'
#     Net::HTTP.put(uri, data)
#
# - If performance is important, consider using sessions, which lower request overhead.
#   This {session}[rdoc-ref:Net::HTTP@Sessions] has multiple requests for
#   {HTTP methods}[https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods]
#   and {WebDAV methods}[https://en.wikipedia.org/wiki/WebDAV#Implementation]:
#
#     Net::HTTP.start(hostname) do |http|
#       # Session started automatically before block execution.
#       http.get(path)
#       http.head(path)
#       body = 'Some text'
#       http.post(path, body)  # Can also have a block.
#       http.put(path, body)
#       http.delete(path)
#       http.options(path)
#       http.trace(path)
#       http.patch(path, body) # Can also have a block.
#       http.copy(path)
#       http.lock(path, body)
#       http.mkcol(path, body)
#       http.move(path)
#       http.propfind(path, body)
#       http.proppatch(path, body)
#       http.unlock(path, body)
#       # Session finished automatically at block exit.
#     end
#
# The methods cited above are convenience methods that, via their few arguments,
# allow minimal control over the requests.
# For greater control, consider using {request objects}[rdoc-ref:Net::HTTPRequest].
#
# == URIs
#
# On the internet, a URI
# ({Universal Resource Identifier}[https://en.wikipedia.org/wiki/Uniform_Resource_Identifier])
# is a string that identifies a particular resource.
# It consists of some or all of: scheme, hostname, path, query, and fragment;
# see {URI syntax}[https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax].
#
# A Ruby {URI::Generic}[https://docs.ruby-lang.org/en/master/URI/Generic.html] object
# represents an internet URI.
# It provides, among others, methods
# +scheme+, +hostname+, +path+, +query+, and +fragment+.
#
# === Schemes
#
# An internet \URI has
# a {scheme}[https://en.wikipedia.org/wiki/List_of_URI_schemes].
#
# The two schemes supported in \Net::HTTP are <tt>'https'</tt> and <tt>'http'</tt>:
#
#   uri.scheme                       # => "https"
#   URI('http://example.com').scheme # => "http"
#
# === Hostnames
#
# A hostname identifies a server (host) to which requests may be sent:
#
#   hostname = uri.hostname # => "jsonplaceholder.typicode.com"
#   Net::HTTP.start(hostname) do |http|
#     # Some HTTP stuff.
#   end
#
# === Paths
#
# A host-specific path identifies a resource on the host:
#
#   _uri = uri.dup
#   _uri.path = '/todos/1'
#   hostname = _uri.hostname
#   path = _uri.path
#   Net::HTTP.get(hostname, path)
#
# === Queries
#
# A host-specific query adds name/value pairs to the URI:
#
#   _uri = uri.dup
#   params = {userId: 1, completed: false}
#   _uri.query = URI.encode_www_form(params)
#   _uri # => #<URI::HTTPS https://jsonplaceholder.typicode.com?userId=1&completed=false>
#   Net::HTTP.get(_uri)
#
# === Fragments
#
# A {URI fragment}[https://en.wikipedia.org/wiki/URI_fragment] has no effect
# in \Net::HTTP;
# the same data is returned, regardless of whether a fragment is included.
#
# == Request Headers
#
# Request headers may be used to pass additional information to the host,
# similar to arguments passed in a method call;
# each header is a name/value pair.
#
# Each of the \Net::HTTP methods that sends a request to the host
# has optional argument +headers+,
# where the headers are expressed as a hash of field-name/value pairs:
#
#   headers = {Accept: 'application/json', Connection: 'Keep-Alive'}
#   Net::HTTP.get(uri, headers)
#
# See lists of both standard request fields and common request fields at
# {Request Fields}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Request_fields].
# A host may also accept other custom fields.
#
# == \HTTP Sessions
#
# A _session_ is a connection between a server (host) and a client that:
#
# - Is begun by instance method Net::HTTP#start.
# - May contain any number of requests.
# - Is ended by instance method Net::HTTP#finish.
#
# See example sessions at {Strategies}[rdoc-ref:Net::HTTP@Strategies].
#
# === Session Using \Net::HTTP.start
#
# If you have many requests to make to a single host (and port),
# consider using singleton method Net::HTTP.start with a block;
# the method handles the session automatically by:
#
# - Calling #start before block execution.
# - Executing the block.
# - Calling #finish after block execution.
#
# In the block, you can use these instance methods,
# each of which that sends a single request:
#
# - {HTTP methods}[https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods]:
#
#   - #get, #request_get: GET.
#   - #head, #request_head: HEAD.
#   - #post, #request_post: POST.
#   - #delete: DELETE.
#   - #options: OPTIONS.
#   - #trace: TRACE.
#   - #patch: PATCH.
#
# - {WebDAV methods}[https://en.wikipedia.org/wiki/WebDAV#Implementation]:
#
#   - #copy: COPY.
#   - #lock: LOCK.
#   - #mkcol: MKCOL.
#   - #move: MOVE.
#   - #propfind: PROPFIND.
#   - #proppatch: PROPPATCH.
#   - #unlock: UNLOCK.
#
# === Session Using \Net::HTTP.start and \Net::HTTP.finish
#
# You can manage a session manually using methods #start and #finish:
#
#   http = Net::HTTP.new(hostname)
#   http.start
#   http.get('/todos/1')
#   http.get('/todos/2')
#   http.delete('/posts/1')
#   http.finish # Needed to free resources.
#
# === Single-Request Session
#
# Certain convenience methods automatically handle a session by:
#
# - Creating an \HTTP object
# - Starting a session.
# - Sending a single request.
# - Finishing the session.
# - Destroying the object.
#
# Such methods that send GET requests:
#
# - ::get: Returns the string response body.
# - ::get_print: Writes the string response body to $stdout.
# - ::get_response: Returns a Net::HTTPResponse object.
#
# Such methods that send POST requests:
#
# - ::post: Posts data to the host.
# - ::post_form: Posts form data to the host.
#
# == \HTTP Requests and Responses
#
# Many of the methods above are convenience methods,
# each of which sends a request and returns a string
# without directly using \Net::HTTPRequest and \Net::HTTPResponse objects.
#
# You can, however, directly create a request object, send the request,
# and retrieve the response object; see:
#
# - Net::HTTPRequest.
# - Net::HTTPResponse.
#
# == Following Redirection
#
# Each returned response is an instance of a subclass of Net::HTTPResponse.
# See the {response class hierarchy}[rdoc-ref:Net::HTTPResponse@Response+Subclasses].
#
# In particular, class Net::HTTPRedirection is the parent
# of all redirection classes.
# This allows you to craft a case statement to handle redirections properly:
#
#   def fetch(uri, limit = 10)
#     # You should choose a better exception.
#     raise ArgumentError, 'Too many HTTP redirects' if limit == 0
#
#     res = Net::HTTP.get_response(URI(uri))
#     case res
#     when Net::HTTPSuccess     # Any success class.
#       res
#     when Net::HTTPRedirection # Any redirection class.
#       location = res['Location']
#       warn "Redirected to #{location}"
#       fetch(location, limit - 1)
#     else                      # Any other class.
#       res.value
#     end
#   end
#
#   fetch(uri)
#
# == Basic Authentication
#
# Basic authentication is performed according to
# {RFC2617}[http://www.ietf.org/rfc/rfc2617.txt]:
#
#   req = Net::HTTP::Get.new(uri)
#   req.basic_auth('user', 'pass')
#   res = Net::HTTP.start(hostname) do |http|
#     http.request(req)
#   end
#
# == Streaming Response Bodies
#
# By default \Net::HTTP reads an entire response into memory.  If you are
# handling large files or wish to implement a progress bar you can instead
# stream the body directly to an IO.
#
#   Net::HTTP.start(hostname) do |http|
#     req = Net::HTTP::Get.new(uri)
#     http.request(req) do |res|
#       open('t.tmp', 'w') do |f|
#         res.read_body do |chunk|
#           f.write chunk
#         end
#       end
#     end
#   end
#
# == HTTPS
#
# HTTPS is enabled for an \HTTP connection by Net::HTTP#use_ssl=:
#
#   Net::HTTP.start(hostname, :use_ssl => true) do |http|
#     req = Net::HTTP::Get.new(uri)
#     res = http.request(req)
#   end
#
# Or if you simply want to make a GET request, you may pass in a URI
# object that has an \HTTPS URL. \Net::HTTP automatically turns on TLS
# verification if the URI object has a 'https' URI scheme:
#
#   uri # => #<URI::HTTPS https://jsonplaceholder.typicode.com/>
#   Net::HTTP.get(uri)
#
# == Proxy Server
#
# An \HTTP object can have
# a {proxy server}[https://en.wikipedia.org/wiki/Proxy_server].
#
# You can create an \HTTP object with a proxy server
# using method Net::HTTP.new or method Net::HTTP.start.
#
# The proxy may be defined either by argument +p_addr+
# or by environment variable <tt>'http_proxy'</tt>.
#
# === Proxy Using Argument +p_addr+ as a \String
#
# When argument +p_addr+ is a string hostname,
# the returned +http+ has the given host as its proxy:
#
#   http = Net::HTTP.new(hostname, nil, 'proxy.example')
#   http.proxy?          # => true
#   http.proxy_from_env? # => false
#   http.proxy_address   # => "proxy.example"
#   # These use default values.
#   http.proxy_port      # => 80
#   http.proxy_user      # => nil
#   http.proxy_pass      # => nil
#
# The port, username, and password for the proxy may also be given:
#
#   http = Net::HTTP.new(hostname, nil, 'proxy.example', 8000, 'pname', 'ppass')
#   # => #<Net::HTTP jsonplaceholder.typicode.com:80 open=false>
#   http.proxy?          # => true
#   http.proxy_from_env? # => false
#   http.proxy_address   # => "proxy.example"
#   http.proxy_port      # => 8000
#   http.proxy_user      # => "pname"
#   http.proxy_pass      # => "ppass"
#
# === Proxy Using '<tt>ENV['http_proxy']</tt>'
#
# When environment variable <tt>'http_proxy'</tt>
# is set to a \URI string,
# the returned +http+ will have the server at that URI as its proxy;
# note that the \URI string must have a protocol
# such as <tt>'http'</tt> or <tt>'https'</tt>:
#
#   ENV['http_proxy'] = 'http://example.com'
#   http = Net::HTTP.new(hostname)
#   http.proxy?          # => true
#   http.proxy_from_env? # => true
#   http.proxy_address   # => "example.com"
#   # These use default values.
#   http.proxy_port      # => 80
#   http.proxy_user      # => nil
#   http.proxy_pass      # => nil
#
# The \URI string may include proxy username, password, and port number:
#
#   ENV['http_proxy'] = 'http://pname:ppass@example.com:8000'
#   http = Net::HTTP.new(hostname)
#   http.proxy?          # => true
#   http.proxy_from_env? # => true
#   http.proxy_address   # => "example.com"
#   http.proxy_port      # => 8000
#   http.proxy_user      # => "pname"
#   http.proxy_pass      # => "ppass"
#
# === Filtering Proxies
#
# With method Net::HTTP.new (but not Net::HTTP.start),
# you can use argument +p_no_proxy+ to filter proxies:
#
# - Reject a certain address:
#
#     http = Net::HTTP.new('example.com', nil, 'proxy.example', 8000, 'pname', 'ppass', 'proxy.example')
#     http.proxy_address # => nil
#
# - Reject certain domains or subdomains:
#
#     http = Net::HTTP.new('example.com', nil, 'my.proxy.example', 8000, 'pname', 'ppass', 'proxy.example')
#     http.proxy_address # => nil
#
# - Reject certain addresses and port combinations:
#
#     http = Net::HTTP.new('example.com', nil, 'proxy.example', 8000, 'pname', 'ppass', 'proxy.example:1234')
#     http.proxy_address # => "proxy.example"
#
#     http = Net::HTTP.new('example.com', nil, 'proxy.example', 8000, 'pname', 'ppass', 'proxy.example:8000')
#     http.proxy_address # => nil
#
# - Reject a list of the types above delimited using a comma:
#
#     http = Net::HTTP.new('example.com', nil, 'proxy.example', 8000, 'pname', 'ppass', 'my.proxy,proxy.example:8000')
#     http.proxy_address # => nil
#
#     http = Net::HTTP.new('example.com', nil, 'my.proxy', 8000, 'pname', 'ppass', 'my.proxy,proxy.example:8000')
#     http.proxy_address # => nil
#
# == Compression and Decompression
#
# \Net::HTTP does not compress the body of a request before sending.
#
# By default, \Net::HTTP adds header <tt>'Accept-Encoding'</tt>
# to a new {request object}[rdoc-ref:Net::HTTPRequest]:
#
#   Net::HTTP::Get.new(uri)['Accept-Encoding']
#   # => "gzip;q=1.0,deflate;q=0.6,identity;q=0.3"
#
# This requests the server to zip-encode the response body if there is one;
# the server is not required to do so.
#
# \Net::HTTP does not automatically decompress a response body
# if the response has header <tt>'Content-Range'</tt>.
#
# Otherwise decompression (or not) depends on the value of header
# {Content-Encoding}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-encoding-response-header]:
#
# - <tt>'deflate'</tt>, <tt>'gzip'</tt>, or <tt>'x-gzip'</tt>:
#   decompresses the body and deletes the header.
# - <tt>'none'</tt> or <tt>'identity'</tt>:
#   does not decompress the body, but deletes the header.
# - Any other value:
#   leaves the body and header unchanged.
#
# == What's Here
#
# First, what's elsewhere. Class Net::HTTP:
#
# - Inherits from {class Object}[https://docs.ruby-lang.org/en/master/Object.html#class-Object-label-What-27s+Here].
#
# This is a categorized summary of methods and attributes.
#
# === \Net::HTTP Objects
#
# - {::new}[rdoc-ref:Net::HTTP.new]:
#   Creates a new instance.
# - {#inspect}[rdoc-ref:Net::HTTP#inspect]:
#   Returns a string representation of +self+.
#
# === Sessions
#
# - {::start}[rdoc-ref:Net::HTTP.start]:
#   Begins a new session in a new \Net::HTTP object.
# - {#started?}[rdoc-ref:Net::HTTP#started?]
#   (aliased as {#active?}[rdoc-ref:Net::HTTP#active?]):
#   Returns whether in a session.
# - {#finish}[rdoc-ref:Net::HTTP#finish]:
#   Ends an active session.
# - {#start}[rdoc-ref:Net::HTTP#start]:
#   Begins a new session in an existing \Net::HTTP object (+self+).
#
# === Connections
#
# - {:continue_timeout}[rdoc-ref:Net::HTTP#continue_timeout]:
#   Returns the continue timeout.
# - {#continue_timeout=}[rdoc-ref:Net::HTTP#continue_timeout=]:
#   Sets the continue timeout seconds.
# - {:keep_alive_timeout}[rdoc-ref:Net::HTTP#keep_alive_timeout]:
#   Returns the keep-alive timeout.
# - {:keep_alive_timeout=}[rdoc-ref:Net::HTTP#keep_alive_timeout=]:
#   Sets the keep-alive timeout.
# - {:max_retries}[rdoc-ref:Net::HTTP#max_retries]:
#   Returns the maximum retries.
# - {#max_retries=}[rdoc-ref:Net::HTTP#max_retries=]:
#   Sets the maximum retries.
# - {:open_timeout}[rdoc-ref:Net::HTTP#open_timeout]:
#   Returns the open timeout.
# - {:open_timeout=}[rdoc-ref:Net::HTTP#open_timeout=]:
#   Sets the open timeout.
# - {:read_timeout}[rdoc-ref:Net::HTTP#read_timeout]:
#   Returns the open timeout.
# - {:read_timeout=}[rdoc-ref:Net::HTTP#read_timeout=]:
#   Sets the read timeout.
# - {:ssl_timeout}[rdoc-ref:Net::HTTP#ssl_timeout]:
#   Returns the ssl timeout.
# - {:ssl_timeout=}[rdoc-ref:Net::HTTP#ssl_timeout=]:
#   Sets the ssl timeout.
# - {:write_timeout}[rdoc-ref:Net::HTTP#write_timeout]:
#   Returns the write timeout.
# - {write_timeout=}[rdoc-ref:Net::HTTP#write_timeout=]:
#   Sets the write timeout.
#
# === Requests
#
# - {::get}[rdoc-ref:Net::HTTP.get]:
#   Sends a GET request and returns the string response body.
# - {::get_print}[rdoc-ref:Net::HTTP.get_print]:
#   Sends a GET request and write the string response body to $stdout.
# - {::get_response}[rdoc-ref:Net::HTTP.get_response]:
#   Sends a GET request and returns a response object.
# - {::post_form}[rdoc-ref:Net::HTTP.post_form]:
#   Sends a POST request with form data and returns a response object.
# - {::post}[rdoc-ref:Net::HTTP.post]:
#   Sends a POST request with data and returns a response object.
# - {::put}[rdoc-ref:Net::HTTP.put]:
#   Sends a PUT request with data and returns a response object.
# - {#copy}[rdoc-ref:Net::HTTP#copy]:
#   Sends a COPY request and returns a response object.
# - {#delete}[rdoc-ref:Net::HTTP#delete]:
#   Sends a DELETE request and returns a response object.
# - {#get}[rdoc-ref:Net::HTTP#get]:
#   Sends a GET request and returns a response object.
# - {#head}[rdoc-ref:Net::HTTP#head]:
#   Sends a HEAD request and returns a response object.
# - {#lock}[rdoc-ref:Net::HTTP#lock]:
#   Sends a LOCK request and returns a response object.
# - {#mkcol}[rdoc-ref:Net::HTTP#mkcol]:
#   Sends a MKCOL request and returns a response object.
# - {#move}[rdoc-ref:Net::HTTP#move]:
#   Sends a MOVE request and returns a response object.
# - {#options}[rdoc-ref:Net::HTTP#options]:
#   Sends a OPTIONS request and returns a response object.
# - {#patch}[rdoc-ref:Net::HTTP#patch]:
#   Sends a PATCH request and returns a response object.
# - {#post}[rdoc-ref:Net::HTTP#post]:
#   Sends a POST request and returns a response object.
# - {#propfind}[rdoc-ref:Net::HTTP#propfind]:
#   Sends a PROPFIND request and returns a response object.
# - {#proppatch}[rdoc-ref:Net::HTTP#proppatch]:
#   Sends a PROPPATCH request and returns a response object.
# - {#put}[rdoc-ref:Net::HTTP#put]:
#   Sends a PUT request and returns a response object.
# - {#request}[rdoc-ref:Net::HTTP#request]:
#   Sends a request and returns a response object.
# - {#request_get}[rdoc-ref:Net::HTTP#request_get]
#   (aliased as {#get2}[rdoc-ref:Net::HTTP#get2]):
#   Sends a GET request and forms a response object;
#   if a block given, calls the block with the object,
#   otherwise returns the object.
# - {#request_head}[rdoc-ref:Net::HTTP#request_head]
#   (aliased as {#head2}[rdoc-ref:Net::HTTP#head2]):
#   Sends a HEAD request and forms a response object;
#   if a block given, calls the block with the object,
#   otherwise returns the object.
# - {#request_post}[rdoc-ref:Net::HTTP#request_post]
#   (aliased as {#post2}[rdoc-ref:Net::HTTP#post2]):
#   Sends a POST request and forms a response object;
#   if a block given, calls the block with the object,
#   otherwise returns the object.
# - {#send_request}[rdoc-ref:Net::HTTP#send_request]:
#   Sends a request and returns a response object.
# - {#trace}[rdoc-ref:Net::HTTP#trace]:
#   Sends a TRACE request and returns a response object.
# - {#unlock}[rdoc-ref:Net::HTTP#unlock]:
#   Sends an UNLOCK request and returns a response object.
#
# === Responses
#
# - {:close_on_empty_response}[rdoc-ref:Net::HTTP#close_on_empty_response]:
#   Returns whether to close connection on empty response.
# - {:close_on_empty_response=}[rdoc-ref:Net::HTTP#close_on_empty_response=]:
#   Sets whether to close connection on empty response.
# - {:ignore_eof}[rdoc-ref:Net::HTTP#ignore_eof]:
#   Returns whether to ignore end-of-file when reading a response body
#   with <tt>Content-Length</tt> headers.
# - {:ignore_eof=}[rdoc-ref:Net::HTTP#ignore_eof=]:
#   Sets whether to ignore end-of-file when reading a response body
#   with <tt>Content-Length</tt> headers.
# - {:response_body_encoding}[rdoc-ref:Net::HTTP#response_body_encoding]:
#   Returns the encoding to use for the response body.
# - {#response_body_encoding=}[rdoc-ref:Net::HTTP#response_body_encoding=]:
#   Sets the response body encoding.
#
# === Proxies
#
# - {:proxy_address}[rdoc-ref:Net::HTTP#proxy_address]:
#   Returns the proxy address.
# - {:proxy_address=}[rdoc-ref:Net::HTTP#proxy_address=]:
#   Sets the proxy address.
# - {::proxy_class?}[rdoc-ref:Net::HTTP.proxy_class?]:
#   Returns whether +self+ is a proxy class.
# - {#proxy?}[rdoc-ref:Net::HTTP#proxy?]:
#   Returns whether +self+ has a proxy.
# - {#proxy_address}[rdoc-ref:Net::HTTP#proxy_address]
#   (aliased as {#proxyaddr}[rdoc-ref:Net::HTTP#proxyaddr]):
#   Returns the proxy address.
# - {#proxy_from_env?}[rdoc-ref:Net::HTTP#proxy_from_env?]:
#   Returns whether the proxy is taken from an environment variable.
# - {:proxy_from_env=}[rdoc-ref:Net::HTTP#proxy_from_env=]:
#   Sets whether the proxy is to be taken from an environment variable.
# - {:proxy_pass}[rdoc-ref:Net::HTTP#proxy_pass]:
#   Returns the proxy password.
# - {:proxy_pass=}[rdoc-ref:Net::HTTP#proxy_pass=]:
#   Sets the proxy password.
# - {:proxy_port}[rdoc-ref:Net::HTTP#proxy_port]:
#   Returns the proxy port.
# - {:proxy_port=}[rdoc-ref:Net::HTTP#proxy_port=]:
#   Sets the proxy port.
# - {#proxy_user}[rdoc-ref:Net::HTTP#proxy_user]:
#   Returns the proxy user name.
# - {:proxy_user=}[rdoc-ref:Net::HTTP#proxy_user=]:
#   Sets the proxy user.
#
# === Security
#
# - {:ca_file}[rdoc-ref:Net::HTTP#ca_file]:
#   Returns the path to a CA certification file.
# - {:ca_file=}[rdoc-ref:Net::HTTP#ca_file=]:
#   Sets the path to a CA certification file.
# - {:ca_path}[rdoc-ref:Net::HTTP#ca_path]:
#   Returns the path of to CA directory containing certification files.
# - {:ca_path=}[rdoc-ref:Net::HTTP#ca_path=]:
#   Sets the path of to CA directory containing certification files.
# - {:cert}[rdoc-ref:Net::HTTP#cert]:
#   Returns the OpenSSL::X509::Certificate object to be used for client certification.
# - {:cert=}[rdoc-ref:Net::HTTP#cert=]:
#   Sets the OpenSSL::X509::Certificate object to be used for client certification.
# - {:cert_store}[rdoc-ref:Net::HTTP#cert_store]:
#   Returns the X509::Store to be used for verifying peer certificate.
# - {:cert_store=}[rdoc-ref:Net::HTTP#cert_store=]:
#   Sets the X509::Store to be used for verifying peer certificate.
# - {:ciphers}[rdoc-ref:Net::HTTP#ciphers]:
#   Returns the available SSL ciphers.
# - {:ciphers=}[rdoc-ref:Net::HTTP#ciphers=]:
#   Sets the available SSL ciphers.
# - {:extra_chain_cert}[rdoc-ref:Net::HTTP#extra_chain_cert]:
#   Returns the extra X509 certificates to be added to the certificate chain.
# - {:extra_chain_cert=}[rdoc-ref:Net::HTTP#extra_chain_cert=]:
#   Sets the extra X509 certificates to be added to the certificate chain.
# - {:key}[rdoc-ref:Net::HTTP#key]:
#   Returns the OpenSSL::PKey::RSA or OpenSSL::PKey::DSA object.
# - {:key=}[rdoc-ref:Net::HTTP#key=]:
#   Sets the OpenSSL::PKey::RSA or OpenSSL::PKey::DSA object.
# - {:max_version}[rdoc-ref:Net::HTTP#max_version]:
#   Returns the maximum SSL version.
# - {:max_version=}[rdoc-ref:Net::HTTP#max_version=]:
#   Sets the maximum SSL version.
# - {:min_version}[rdoc-ref:Net::HTTP#min_version]:
#   Returns the minimum SSL version.
# - {:min_version=}[rdoc-ref:Net::HTTP#min_version=]:
#   Sets the minimum SSL version.
# - {#peer_cert}[rdoc-ref:Net::HTTP#peer_cert]:
#   Returns the X509 certificate chain for the session's socket peer.
# - {:ssl_version}[rdoc-ref:Net::HTTP#ssl_version]:
#   Returns the SSL version.
# - {:ssl_version=}[rdoc-ref:Net::HTTP#ssl_version=]:
#   Sets the SSL version.
# - {#use_ssl=}[rdoc-ref:Net::HTTP#use_ssl=]:
#   Sets whether a new session is to use Transport Layer Security.
# - {#use_ssl?}[rdoc-ref:Net::HTTP#use_ssl?]:
#   Returns whether +self+ uses SSL.
# - {:verify_callback}[rdoc-ref:Net::HTTP#verify_callback]:
#   Returns the callback for the server certification verification.
# - {:verify_callback=}[rdoc-ref:Net::HTTP#verify_callback=]:
#   Sets the callback for the server certification verification.
# - {:verify_depth}[rdoc-ref:Net::HTTP#verify_depth]:
#   Returns the maximum depth for the certificate chain verification.
# - {:verify_depth=}[rdoc-ref:Net::HTTP#verify_depth=]:
#   Sets the maximum depth for the certificate chain verification.
# - {:verify_hostname}[rdoc-ref:Net::HTTP#verify_hostname]:
#   Returns the flags for server the certification verification at the beginning of the SSL/TLS session.
# - {:verify_hostname=}[rdoc-ref:Net::HTTP#verify_hostname=]:
#   Sets he flags for server the certification verification at the beginning of the SSL/TLS session.
# - {:verify_mode}[rdoc-ref:Net::HTTP#verify_mode]:
#   Returns the flags for server the certification verification at the beginning of the SSL/TLS session.
# - {:verify_mode=}[rdoc-ref:Net::HTTP#verify_mode=]:
#   Sets the flags for server the certification verification at the beginning of the SSL/TLS session.
#
# === Addresses and Ports
#
# - {:address}[rdoc-ref:Net::HTTP#address]:
#   Returns the string host name or host IP.
# - {::default_port}[rdoc-ref:Net::HTTP.default_port]:
#   Returns integer 80, the default port to use for HTTP requests.
# - {::http_default_port}[rdoc-ref:Net::HTTP.http_default_port]:
#   Returns integer 80, the default port to use for HTTP requests.
# - {::https_default_port}[rdoc-ref:Net::HTTP.https_default_port]:
#   Returns integer 443, the default port to use for HTTPS requests.
# - {#ipaddr}[rdoc-ref:Net::HTTP#ipaddr]:
#   Returns the IP address for the connection.
# - {#ipaddr=}[rdoc-ref:Net::HTTP#ipaddr=]:
#   Sets the IP address for the connection.
# - {:local_host}[rdoc-ref:Net::HTTP#local_host]:
#   Returns the string local host used to establish the connection.
# - {:local_host=}[rdoc-ref:Net::HTTP#local_host=]:
#   Sets the string local host used to establish the connection.
# - {:local_port}[rdoc-ref:Net::HTTP#local_port]:
#   Returns the integer local port used to establish the connection.
# - {:local_port=}[rdoc-ref:Net::HTTP#local_port=]:
#   Sets the integer local port used to establish the connection.
# - {:port}[rdoc-ref:Net::HTTP#port]:
#   Returns the integer port number.
#
# === \HTTP Version
#
# - {::version_1_2?}[rdoc-ref:Net::HTTP.version_1_2?]
#   (aliased as {::is_version_1_2?}[rdoc-ref:Net::HTTP.is_version_1_2?]
#   and {::version_1_2}[rdoc-ref:Net::HTTP.version_1_2]):
#   Returns true; retained for compatibility.
#
# === Debugging
#
# - {#set_debug_output}[rdoc-ref:Net::HTTP#set_debug_output]:
#   Sets the output stream for debugging.
#
# source://net-http//lib/net/http.rb#730
class Net::HTTP < ::Net::Protocol
  # Creates a new \Net::HTTP object for the specified server address,
  # without opening the TCP connection or initializing the \HTTP session.
  # The +address+ should be a DNS hostname or IP address.
  #
  # @return [HTTP] a new instance of HTTP
  #
  # source://net-http//lib/net/http.rb#1154
  def initialize(address, port = T.unsafe(nil)); end

  # Returns +true+ if the \HTTP session has been started:
  #
  #   http = Net::HTTP.new(hostname)
  #   http.started? # => false
  #   http.start
  #   http.started? # => true
  #   http.finish # => nil
  #   http.started? # => false
  #
  #   Net::HTTP.start(hostname) do |http|
  #     http.started?
  #   end # => true
  #   http.started? # => false
  #
  # @return [Boolean]
  #
  # source://net-http//lib/net/http.rb#1494
  def active?; end

  # Returns the string host name or host IP given as argument +address+ in ::new.
  #
  # source://net-http//lib/net/http.rb#1270
  def address; end

  # Sets or returns the path to a CA certification file in PEM format.
  #
  # source://net-http//lib/net/http.rb#1541
  def ca_file; end

  # Sets or returns the path to a CA certification file in PEM format.
  #
  # source://net-http//lib/net/http.rb#1541
  def ca_file=(_arg0); end

  # Sets or returns the path of to CA directory
  # containing certification files in PEM format.
  #
  # source://net-http//lib/net/http.rb#1545
  def ca_path; end

  # Sets or returns the path of to CA directory
  # containing certification files in PEM format.
  #
  # source://net-http//lib/net/http.rb#1545
  def ca_path=(_arg0); end

  # Sets or returns the OpenSSL::X509::Certificate object
  # to be used for client certification.
  #
  # source://net-http//lib/net/http.rb#1549
  def cert; end

  # Sets or returns the OpenSSL::X509::Certificate object
  # to be used for client certification.
  #
  # source://net-http//lib/net/http.rb#1549
  def cert=(_arg0); end

  # Sets or returns the X509::Store to be used for verifying peer certificate.
  #
  # source://net-http//lib/net/http.rb#1552
  def cert_store; end

  # Sets or returns the X509::Store to be used for verifying peer certificate.
  #
  # source://net-http//lib/net/http.rb#1552
  def cert_store=(_arg0); end

  # Sets or returns the available SSL ciphers.
  # See {OpenSSL::SSL::SSLContext#ciphers=}[https://docs.ruby-lang.org/en/master/OpenSSL/SSL/SSLContext.html#method-i-ciphers-3D].
  #
  # source://net-http//lib/net/http.rb#1556
  def ciphers; end

  # Sets or returns the available SSL ciphers.
  # See {OpenSSL::SSL::SSLContext#ciphers=}[https://docs.ruby-lang.org/en/master/OpenSSL/SSL/SSLContext.html#method-i-ciphers-3D].
  #
  # source://net-http//lib/net/http.rb#1556
  def ciphers=(_arg0); end

  # Sets or returns whether to close the connection when the response is empty;
  # initially +false+.
  #
  # source://net-http//lib/net/http.rb#1498
  def close_on_empty_response; end

  # Sets or returns whether to close the connection when the response is empty;
  # initially +false+.
  #
  # source://net-http//lib/net/http.rb#1498
  def close_on_empty_response=(_arg0); end

  # Returns the continue timeout value;
  # see continue_timeout=.
  #
  # source://net-http//lib/net/http.rb#1451
  def continue_timeout; end

  # Sets the continue timeout value,
  # which is the number of seconds to wait for an expected 100 Continue response.
  # If the \HTTP object does not receive a response in this many seconds
  # it sends the request body.
  #
  # source://net-http//lib/net/http.rb#1457
  def continue_timeout=(sec); end

  # Sends a COPY request to the server;
  # returns an instance of a subclass of Net::HTTPResponse.
  #
  # The request is based on the Net::HTTP::Copy object
  # created from string +path+ and initial headers hash +initheader+.
  #
  #   http = Net::HTTP.new(hostname)
  #   http.copy('/todos/1')
  #
  # source://net-http//lib/net/http.rb#2201
  def copy(path, initheader = T.unsafe(nil)); end

  # Sends a DELETE request to the server;
  # returns an instance of a subclass of Net::HTTPResponse.
  #
  # The request is based on the Net::HTTP::Delete object
  # created from string +path+ and initial headers hash +initheader+.
  #
  #   http = Net::HTTP.new(hostname)
  #   http.delete('/todos/1')
  #
  # source://net-http//lib/net/http.rb#2175
  def delete(path, initheader = T.unsafe(nil)); end

  # Sets or returns the extra X509 certificates to be added to the certificate chain.
  # See {OpenSSL::SSL::SSLContext#add_certificate}[https://docs.ruby-lang.org/en/master/OpenSSL/SSL/SSLContext.html#method-i-add_certificate].
  #
  # source://net-http//lib/net/http.rb#1560
  def extra_chain_cert; end

  # Sets or returns the extra X509 certificates to be added to the certificate chain.
  # See {OpenSSL::SSL::SSLContext#add_certificate}[https://docs.ruby-lang.org/en/master/OpenSSL/SSL/SSLContext.html#method-i-add_certificate].
  #
  # source://net-http//lib/net/http.rb#1560
  def extra_chain_cert=(_arg0); end

  # Finishes the \HTTP session:
  #
  #   http = Net::HTTP.new(hostname)
  #   http.start
  #   http.started? # => true
  #   http.finish   # => nil
  #   http.started? # => false
  #
  # Raises IOError if not in a session.
  #
  # @raise [IOError]
  #
  # source://net-http//lib/net/http.rb#1776
  def finish; end

  # :call-seq:
  #    get(path, initheader = nil) {|res| ... }
  #
  # Sends a GET request to the server;
  # returns an instance of a subclass of Net::HTTPResponse.
  #
  # The request is based on the Net::HTTP::Get object
  # created from string +path+ and initial headers hash +initheader+.
  #
  # With a block given, calls the block with the response body:
  #
  #   http = Net::HTTP.new(hostname)
  #   http.get('/todos/1') do |res|
  #     p res
  #   end # => #<Net::HTTPOK 200 OK readbody=true>
  #
  # Output:
  #
  #   "{\n  \"userId\": 1,\n  \"id\": 1,\n  \"title\": \"delectus aut autem\",\n  \"completed\": false\n}"
  #
  # With no block given, simply returns the response object:
  #
  #   http.get('/') # => #<Net::HTTPOK 200 OK readbody=true>
  #
  # Related:
  #
  # - Net::HTTP::Get: request class for \HTTP method GET.
  # - Net::HTTP.get: sends GET request, returns response body.
  #
  # source://net-http//lib/net/http.rb#1987
  def get(path, initheader = T.unsafe(nil), dest = T.unsafe(nil), &block); end

  # Sends a GET request to the server;
  # forms the response into a Net::HTTPResponse object.
  #
  # The request is based on the Net::HTTP::Get object
  # created from string +path+ and initial headers hash +initheader+.
  #
  # With no block given, returns the response object:
  #
  #   http = Net::HTTP.new(hostname)
  #   http.request_get('/todos') # => #<Net::HTTPOK 200 OK readbody=true>
  #
  # With a block given, calls the block with the response object
  # and returns the response object:
  #
  #   http.request_get('/todos') do |res|
  #     p res
  #   end # => #<Net::HTTPOK 200 OK readbody=true>
  #
  # Output:
  #
  #   #<Net::HTTPOK 200 OK readbody=false>
  #
  # source://net-http//lib/net/http.rb#2312
  def get2(path, initheader = T.unsafe(nil), &block); end

  # Sends a HEAD request to the server;
  # returns an instance of a subclass of Net::HTTPResponse.
  #
  # The request is based on the Net::HTTP::Head object
  # created from string +path+ and initial headers hash +initheader+:
  #
  #   res = http.head('/todos/1') # => #<Net::HTTPOK 200 OK readbody=true>
  #   res.body                    # => nil
  #   res.to_hash.take(3)
  #   # =>
  #   [["date", ["Wed, 15 Feb 2023 15:25:42 GMT"]],
  #    ["content-type", ["application/json; charset=utf-8"]],
  #    ["connection", ["close"]]]
  #
  # source://net-http//lib/net/http.rb#2011
  def head(path, initheader = T.unsafe(nil)); end

  # Sends a HEAD request to the server;
  # returns an instance of a subclass of Net::HTTPResponse.
  #
  # The request is based on the Net::HTTP::Head object
  # created from string +path+ and initial headers hash +initheader+.
  #
  #   http = Net::HTTP.new(hostname)
  #   http.head('/todos/1') # => #<Net::HTTPOK 200 OK readbody=true>
  #
  # source://net-http//lib/net/http.rb#2313
  def head2(path, initheader = T.unsafe(nil), &block); end

  # Sets or returns whether to ignore end-of-file when reading a response body
  # with <tt>Content-Length</tt> headers;
  # initially +true+.
  #
  # source://net-http//lib/net/http.rb#1474
  def ignore_eof; end

  # Sets or returns whether to ignore end-of-file when reading a response body
  # with <tt>Content-Length</tt> headers;
  # initially +true+.
  #
  # source://net-http//lib/net/http.rb#1474
  def ignore_eof=(_arg0); end

  # Returns a string representation of +self+:
  #
  #   Net::HTTP.new(hostname).inspect
  #   # => "#<Net::HTTP jsonplaceholder.typicode.com:80 open=false>"
  #
  # source://net-http//lib/net/http.rb#1211
  def inspect; end

  # Returns the IP address for the connection.
  #
  # If the session has not been started,
  # returns the value set by #ipaddr=,
  # or +nil+ if it has not been set:
  #
  #   http = Net::HTTP.new(hostname)
  #   http.ipaddr # => nil
  #   http.ipaddr = '172.67.155.76'
  #   http.ipaddr # => "172.67.155.76"
  #
  # If the session has been started,
  # returns the IP address from the socket:
  #
  #   http = Net::HTTP.new(hostname)
  #   http.start
  #   http.ipaddr # => "172.67.155.76"
  #   http.finish
  #
  # source://net-http//lib/net/http.rb#1351
  def ipaddr; end

  # Sets the IP address for the connection:
  #
  #   http = Net::HTTP.new(hostname)
  #   http.ipaddr # => nil
  #   http.ipaddr = '172.67.155.76'
  #   http.ipaddr # => "172.67.155.76"
  #
  # The IP address may not be set if the session has been started.
  #
  # @raise [IOError]
  #
  # source://net-http//lib/net/http.rb#1363
  def ipaddr=(addr); end

  # Sets or returns the numeric (\Integer or \Float) number of seconds
  # to keep the connection open after a request is sent;
  # initially 2.
  # If a new request is made during the given interval,
  # the still-open connection is used;
  # otherwise the connection will have been closed
  # and a new connection is opened.
  #
  # source://net-http//lib/net/http.rb#1469
  def keep_alive_timeout; end

  # Sets or returns the numeric (\Integer or \Float) number of seconds
  # to keep the connection open after a request is sent;
  # initially 2.
  # If a new request is made during the given interval,
  # the still-open connection is used;
  # otherwise the connection will have been closed
  # and a new connection is opened.
  #
  # source://net-http//lib/net/http.rb#1469
  def keep_alive_timeout=(_arg0); end

  # Sets or returns the OpenSSL::PKey::RSA or OpenSSL::PKey::DSA object.
  #
  # source://net-http//lib/net/http.rb#1563
  def key; end

  # Sets or returns the OpenSSL::PKey::RSA or OpenSSL::PKey::DSA object.
  #
  # source://net-http//lib/net/http.rb#1563
  def key=(_arg0); end

  # Sets or returns the string local host used to establish the connection;
  # initially +nil+.
  #
  # source://net-http//lib/net/http.rb#1277
  def local_host; end

  # Sets or returns the string local host used to establish the connection;
  # initially +nil+.
  #
  # source://net-http//lib/net/http.rb#1277
  def local_host=(_arg0); end

  # Sets or returns the integer local port used to establish the connection;
  # initially +nil+.
  #
  # source://net-http//lib/net/http.rb#1281
  def local_port; end

  # Sets or returns the integer local port used to establish the connection;
  # initially +nil+.
  #
  # source://net-http//lib/net/http.rb#1281
  def local_port=(_arg0); end

  # Sends a LOCK request to the server;
  # returns an instance of a subclass of Net::HTTPResponse.
  #
  # The request is based on the Net::HTTP::Lock object
  # created from string +path+, string +body+, and initial headers hash +initheader+.
  #
  #   data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
  #   http = Net::HTTP.new(hostname)
  #   http.lock('/todos/1', data)
  #
  # source://net-http//lib/net/http.rb#2121
  def lock(path, body, initheader = T.unsafe(nil)); end

  # Returns the maximum number of times to retry an idempotent request;
  # see #max_retries=.
  #
  # source://net-http//lib/net/http.rb#1407
  def max_retries; end

  # Sets the maximum number of times to retry an idempotent request in case of
  # \Net::ReadTimeout, IOError, EOFError, Errno::ECONNRESET,
  # Errno::ECONNABORTED, Errno::EPIPE, OpenSSL::SSL::SSLError,
  # Timeout::Error.
  # The initial value is 1.
  #
  # Argument +retries+ must be a non-negative numeric value:
  #
  #   http = Net::HTTP.new(hostname)
  #   http.max_retries = 2   # => 2
  #   http.max_retries       # => 2
  #
  # source://net-http//lib/net/http.rb#1397
  def max_retries=(retries); end

  # Sets or returns the maximum SSL version.
  # See {OpenSSL::SSL::SSLContext#max_version=}[https://docs.ruby-lang.org/en/master/OpenSSL/SSL/SSLContext.html#method-i-max_version-3D].
  #
  # source://net-http//lib/net/http.rb#1578
  def max_version; end

  # Sets or returns the maximum SSL version.
  # See {OpenSSL::SSL::SSLContext#max_version=}[https://docs.ruby-lang.org/en/master/OpenSSL/SSL/SSLContext.html#method-i-max_version-3D].
  #
  # source://net-http//lib/net/http.rb#1578
  def max_version=(_arg0); end

  # Sets or returns the minimum SSL version.
  # See {OpenSSL::SSL::SSLContext#min_version=}[https://docs.ruby-lang.org/en/master/OpenSSL/SSL/SSLContext.html#method-i-min_version-3D].
  #
  # source://net-http//lib/net/http.rb#1574
  def min_version; end

  # Sets or returns the minimum SSL version.
  # See {OpenSSL::SSL::SSLContext#min_version=}[https://docs.ruby-lang.org/en/master/OpenSSL/SSL/SSLContext.html#method-i-min_version-3D].
  #
  # source://net-http//lib/net/http.rb#1574
  def min_version=(_arg0); end

  # Sends a MKCOL request to the server;
  # returns an instance of a subclass of Net::HTTPResponse.
  #
  # The request is based on the Net::HTTP::Mkcol object
  # created from string +path+, string +body+, and initial headers hash +initheader+.
  #
  #   data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
  #   http.mkcol('/todos/1', data)
  #   http = Net::HTTP.new(hostname)
  #
  # source://net-http//lib/net/http.rb#2215
  def mkcol(path, body = T.unsafe(nil), initheader = T.unsafe(nil)); end

  # Sends a MOVE request to the server;
  # returns an instance of a subclass of Net::HTTPResponse.
  #
  # The request is based on the Net::HTTP::Move object
  # created from string +path+ and initial headers hash +initheader+.
  #
  #   http = Net::HTTP.new(hostname)
  #   http.move('/todos/1')
  #
  # source://net-http//lib/net/http.rb#2188
  def move(path, initheader = T.unsafe(nil)); end

  # Sets or returns the numeric (\Integer or \Float) number of seconds
  # to wait for a connection to open;
  # initially 60.
  # If the connection is not made in the given interval,
  # an exception is raised.
  #
  # source://net-http//lib/net/http.rb#1373
  def open_timeout; end

  # Sets or returns the numeric (\Integer or \Float) number of seconds
  # to wait for a connection to open;
  # initially 60.
  # If the connection is not made in the given interval,
  # an exception is raised.
  #
  # source://net-http//lib/net/http.rb#1373
  def open_timeout=(_arg0); end

  # Sends an Options request to the server;
  # returns an instance of a subclass of Net::HTTPResponse.
  #
  # The request is based on the Net::HTTP::Options object
  # created from string +path+ and initial headers hash +initheader+.
  #
  #   http = Net::HTTP.new(hostname)
  #   http.options('/')
  #
  # source://net-http//lib/net/http.rb#2148
  def options(path, initheader = T.unsafe(nil)); end

  # :call-seq:
  #    patch(path, data, initheader = nil) {|res| ... }
  #
  # Sends a PATCH request to the server;
  # returns an instance of a subclass of Net::HTTPResponse.
  #
  # The request is based on the Net::HTTP::Patch object
  # created from string +path+, string +data+, and initial headers hash +initheader+.
  #
  # With a block given, calls the block with the response body:
  #
  #   data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
  #   http = Net::HTTP.new(hostname)
  #   http.patch('/todos/1', data) do |res|
  #     p res
  #   end # => #<Net::HTTPOK 200 OK readbody=true>
  #
  # Output:
  #
  #   "{\n  \"userId\": 1,\n  \"id\": 1,\n  \"title\": \"delectus aut autem\",\n  \"completed\": false,\n  \"{\\\"userId\\\": 1, \\\"id\\\": 1, \\\"title\\\": \\\"delectus aut autem\\\", \\\"completed\\\": false}\": \"\"\n}"
  #
  # With no block given, simply returns the response object:
  #
  #   http.patch('/todos/1', data) # => #<Net::HTTPCreated 201 Created readbody=true>
  #
  # source://net-http//lib/net/http.rb#2074
  def patch(path, data, initheader = T.unsafe(nil), dest = T.unsafe(nil), &block); end

  # Returns the X509 certificate chain (an array of strings)
  # for the session's socket peer,
  # or +nil+ if none.
  #
  # source://net-http//lib/net/http.rb#1599
  def peer_cert; end

  # Returns the integer port number given as argument +port+ in ::new.
  #
  # source://net-http//lib/net/http.rb#1273
  def port; end

  # :call-seq:
  #    post(path, data, initheader = nil) {|res| ... }
  #
  # Sends a POST request to the server;
  # returns an instance of a subclass of Net::HTTPResponse.
  #
  # The request is based on the Net::HTTP::Post object
  # created from string +path+, string +data+, and initial headers hash +initheader+.
  #
  # With a block given, calls the block with the response body:
  #
  #   data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
  #   http = Net::HTTP.new(hostname)
  #   http.post('/todos', data) do |res|
  #     p res
  #   end # => #<Net::HTTPCreated 201 Created readbody=true>
  #
  # Output:
  #
  #   "{\n  \"{\\\"userId\\\": 1, \\\"id\\\": 1, \\\"title\\\": \\\"delectus aut autem\\\", \\\"completed\\\": false}\": \"\",\n  \"id\": 201\n}"
  #
  # With no block given, simply returns the response object:
  #
  #   http.post('/todos', data) # => #<Net::HTTPCreated 201 Created readbody=true>
  #
  # Related:
  #
  # - Net::HTTP::Post: request class for \HTTP method POST.
  # - Net::HTTP.post: sends POST request, returns response body.
  #
  # source://net-http//lib/net/http.rb#2045
  def post(path, data, initheader = T.unsafe(nil), dest = T.unsafe(nil), &block); end

  # Sends a POST request to the server;
  # forms the response into a Net::HTTPResponse object.
  #
  # The request is based on the Net::HTTP::Post object
  # created from string +path+, string +data+, and initial headers hash +initheader+.
  #
  # With no block given, returns the response object:
  #
  #   http = Net::HTTP.new(hostname)
  #   http.post('/todos', 'xyzzy')
  #   # => #<Net::HTTPCreated 201 Created readbody=true>
  #
  # With a block given, calls the block with the response body
  # and returns the response object:
  #
  #   http.post('/todos', 'xyzzy') do |res|
  #     p res
  #   end # => #<Net::HTTPCreated 201 Created readbody=true>
  #
  # Output:
  #
  #   "{\n  \"xyzzy\": \"\",\n  \"id\": 201\n}"
  #
  # source://net-http//lib/net/http.rb#2314
  def post2(path, data, initheader = T.unsafe(nil), &block); end

  # Sends a PROPFIND request to the server;
  # returns an instance of a subclass of Net::HTTPResponse.
  #
  # The request is based on the Net::HTTP::Propfind object
  # created from string +path+, string +body+, and initial headers hash +initheader+.
  #
  #   data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
  #   http = Net::HTTP.new(hostname)
  #   http.propfind('/todos/1', data)
  #
  # source://net-http//lib/net/http.rb#2162
  def propfind(path, body = T.unsafe(nil), initheader = T.unsafe(nil)); end

  # Sends a PROPPATCH request to the server;
  # returns an instance of a subclass of Net::HTTPResponse.
  #
  # The request is based on the Net::HTTP::Proppatch object
  # created from string +path+, string +body+, and initial headers hash +initheader+.
  #
  #   data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
  #   http = Net::HTTP.new(hostname)
  #   http.proppatch('/todos/1', data)
  #
  # source://net-http//lib/net/http.rb#2107
  def proppatch(path, body, initheader = T.unsafe(nil)); end

  # Returns +true+ if a proxy server is defined, +false+ otherwise;
  # see {Proxy Server}[rdoc-ref:Net::HTTP@Proxy+Server].
  #
  # @return [Boolean]
  #
  # source://net-http//lib/net/http.rb#1858
  def proxy?; end

  # Returns the address of the proxy server, if defined, +nil+ otherwise;
  # see {Proxy Server}[rdoc-ref:Net::HTTP@Proxy+Server].
  #
  # source://net-http//lib/net/http.rb#1880
  def proxy_address; end

  # Sets the proxy address;
  # see {Proxy Server}[rdoc-ref:Net::HTTP@Proxy+Server].
  #
  # source://net-http//lib/net/http.rb#1317
  def proxy_address=(_arg0); end

  # Sets whether to determine the proxy from environment variable
  # '<tt>ENV['http_proxy']</tt>';
  # see {Proxy Using ENV['http_proxy']}[rdoc-ref:Net::HTTP@Proxy+Using+-27ENV-5B-27http_proxy-27-5D-27].
  #
  # source://net-http//lib/net/http.rb#1313
  def proxy_from_env=(_arg0); end

  # Returns +true+ if the proxy server is defined in the environment,
  # +false+ otherwise;
  # see {Proxy Server}[rdoc-ref:Net::HTTP@Proxy+Server].
  #
  # @return [Boolean]
  #
  # source://net-http//lib/net/http.rb#1865
  def proxy_from_env?; end

  # Returns the password of the proxy server, if defined, +nil+ otherwise;
  # see {Proxy Server}[rdoc-ref:Net::HTTP@Proxy+Server].
  #
  # source://net-http//lib/net/http.rb#1911
  def proxy_pass; end

  # Sets the proxy password;
  # see {Proxy Server}[rdoc-ref:Net::HTTP@Proxy+Server].
  #
  # source://net-http//lib/net/http.rb#1329
  def proxy_pass=(_arg0); end

  # Returns the port number of the proxy server, if defined, +nil+ otherwise;
  # see {Proxy Server}[rdoc-ref:Net::HTTP@Proxy+Server].
  #
  # source://net-http//lib/net/http.rb#1890
  def proxy_port; end

  # Sets the proxy port;
  # see {Proxy Server}[rdoc-ref:Net::HTTP@Proxy+Server].
  #
  # source://net-http//lib/net/http.rb#1321
  def proxy_port=(_arg0); end

  # The proxy URI determined from the environment for this connection.
  #
  # source://net-http//lib/net/http.rb#1870
  def proxy_uri; end

  # Sets the attribute proxy_use_ssl
  #
  # @param value the value to set the attribute proxy_use_ssl to.
  #
  # source://net-http//lib/net/http.rb#1330
  def proxy_use_ssl=(_arg0); end

  # Returns the user name of the proxy server, if defined, +nil+ otherwise;
  # see {Proxy Server}[rdoc-ref:Net::HTTP@Proxy+Server].
  #
  # source://net-http//lib/net/http.rb#1900
  def proxy_user; end

  # Sets the proxy user;
  # see {Proxy Server}[rdoc-ref:Net::HTTP@Proxy+Server].
  #
  # source://net-http//lib/net/http.rb#1325
  def proxy_user=(_arg0); end

  # Returns the address of the proxy server, if defined, +nil+ otherwise;
  # see {Proxy Server}[rdoc-ref:Net::HTTP@Proxy+Server].
  #
  # source://net-http//lib/net/http.rb#1920
  def proxyaddr; end

  # Returns the port number of the proxy server, if defined, +nil+ otherwise;
  # see {Proxy Server}[rdoc-ref:Net::HTTP@Proxy+Server].
  #
  # source://net-http//lib/net/http.rb#1921
  def proxyport; end

  # Sends a PUT request to the server;
  # returns an instance of a subclass of Net::HTTPResponse.
  #
  # The request is based on the Net::HTTP::Put object
  # created from string +path+, string +data+, and initial headers hash +initheader+.
  #
  #   data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
  #   http = Net::HTTP.new(hostname)
  #   http.put('/todos/1', data) # => #<Net::HTTPOK 200 OK readbody=true>
  #
  # Related:
  #
  # - Net::HTTP::Put: request class for \HTTP method PUT.
  # - Net::HTTP.put: sends PUT request, returns response body.
  #
  # source://net-http//lib/net/http.rb#2093
  def put(path, data, initheader = T.unsafe(nil)); end

  # Sends a PUT request to the server;
  # returns an instance of a subclass of Net::HTTPResponse.
  #
  # The request is based on the Net::HTTP::Put object
  # created from string +path+, string +data+, and initial headers hash +initheader+.
  #
  #   http = Net::HTTP.new(hostname)
  #   http.put('/todos/1', 'xyzzy')
  #   # => #<Net::HTTPOK 200 OK readbody=true>
  #
  # source://net-http//lib/net/http.rb#2315
  def put2(path, data, initheader = T.unsafe(nil), &block); end

  # Returns the numeric (\Integer or \Float) number of seconds
  # to wait for one block to be read (via one read(2) call);
  # see #read_timeout=.
  #
  # source://net-http//lib/net/http.rb#1378
  def read_timeout; end

  # Sets the read timeout, in seconds, for +self+ to integer +sec+;
  # the initial value is 60.
  #
  # Argument +sec+ must be a non-negative numeric value:
  #
  #   http = Net::HTTP.new(hostname)
  #   http.read_timeout # => 60
  #   http.get('/todos/1') # => #<Net::HTTPOK 200 OK readbody=true>
  #   http.read_timeout = 0
  #   http.get('/todos/1') # Raises Net::ReadTimeout.
  #
  # source://net-http//lib/net/http.rb#1420
  def read_timeout=(sec); end

  # Sends the given request +req+ to the server;
  # forms the response into a Net::HTTPResponse object.
  #
  # The given +req+ must be an instance of a
  # {subclass of Net::HTTPRequest}[rdoc-ref:Net::HTTPRequest@Request+Subclasses].
  # Argument +body+ should be given only if needed for the request.
  #
  # With no block given, returns the response object:
  #
  #   http = Net::HTTP.new(hostname)
  #
  #   req = Net::HTTP::Get.new('/todos/1')
  #   http.request(req)
  #   # => #<Net::HTTPOK 200 OK readbody=true>
  #
  #   req = Net::HTTP::Post.new('/todos')
  #   http.request(req, 'xyzzy')
  #   # => #<Net::HTTPCreated 201 Created readbody=true>
  #
  # With a block given, calls the block with the response and returns the response:
  #
  #   req = Net::HTTP::Get.new('/todos/1')
  #   http.request(req) do |res|
  #     p res
  #   end # => #<Net::HTTPOK 200 OK readbody=true>
  #
  # Output:
  #
  #   #<Net::HTTPOK 200 OK readbody=false>
  #
  # source://net-http//lib/net/http.rb#2373
  def request(req, body = T.unsafe(nil), &block); end

  # Sends a GET request to the server;
  # forms the response into a Net::HTTPResponse object.
  #
  # The request is based on the Net::HTTP::Get object
  # created from string +path+ and initial headers hash +initheader+.
  #
  # With no block given, returns the response object:
  #
  #   http = Net::HTTP.new(hostname)
  #   http.request_get('/todos') # => #<Net::HTTPOK 200 OK readbody=true>
  #
  # With a block given, calls the block with the response object
  # and returns the response object:
  #
  #   http.request_get('/todos') do |res|
  #     p res
  #   end # => #<Net::HTTPOK 200 OK readbody=true>
  #
  # Output:
  #
  #   #<Net::HTTPOK 200 OK readbody=false>
  #
  # source://net-http//lib/net/http.rb#2254
  def request_get(path, initheader = T.unsafe(nil), &block); end

  # Sends a HEAD request to the server;
  # returns an instance of a subclass of Net::HTTPResponse.
  #
  # The request is based on the Net::HTTP::Head object
  # created from string +path+ and initial headers hash +initheader+.
  #
  #   http = Net::HTTP.new(hostname)
  #   http.head('/todos/1') # => #<Net::HTTPOK 200 OK readbody=true>
  #
  # source://net-http//lib/net/http.rb#2267
  def request_head(path, initheader = T.unsafe(nil), &block); end

  # Sends a POST request to the server;
  # forms the response into a Net::HTTPResponse object.
  #
  # The request is based on the Net::HTTP::Post object
  # created from string +path+, string +data+, and initial headers hash +initheader+.
  #
  # With no block given, returns the response object:
  #
  #   http = Net::HTTP.new(hostname)
  #   http.post('/todos', 'xyzzy')
  #   # => #<Net::HTTPCreated 201 Created readbody=true>
  #
  # With a block given, calls the block with the response body
  # and returns the response object:
  #
  #   http.post('/todos', 'xyzzy') do |res|
  #     p res
  #   end # => #<Net::HTTPCreated 201 Created readbody=true>
  #
  # Output:
  #
  #   "{\n  \"xyzzy\": \"\",\n  \"id\": 201\n}"
  #
  # source://net-http//lib/net/http.rb#2294
  def request_post(path, data, initheader = T.unsafe(nil), &block); end

  # Sends a PUT request to the server;
  # returns an instance of a subclass of Net::HTTPResponse.
  #
  # The request is based on the Net::HTTP::Put object
  # created from string +path+, string +data+, and initial headers hash +initheader+.
  #
  #   http = Net::HTTP.new(hostname)
  #   http.put('/todos/1', 'xyzzy')
  #   # => #<Net::HTTPOK 200 OK readbody=true>
  #
  # source://net-http//lib/net/http.rb#2308
  def request_put(path, data, initheader = T.unsafe(nil), &block); end

  # Returns the encoding to use for the response body;
  # see #response_body_encoding=.
  #
  # source://net-http//lib/net/http.rb#1285
  def response_body_encoding; end

  # Sets the encoding to be used for the response body;
  # returns the encoding.
  #
  # The given +value+ may be:
  #
  # - An Encoding object.
  # - The name of an encoding.
  # - An alias for an encoding name.
  #
  # See {Encoding}[https://docs.ruby-lang.org/en/master/Encoding.html].
  #
  # Examples:
  #
  #   http = Net::HTTP.new(hostname)
  #   http.response_body_encoding = Encoding::US_ASCII # => #<Encoding:US-ASCII>
  #   http.response_body_encoding = 'US-ASCII'         # => "US-ASCII"
  #   http.response_body_encoding = 'ASCII'            # => "ASCII"
  #
  # source://net-http//lib/net/http.rb#1305
  def response_body_encoding=(value); end

  # Sends an \HTTP request to the server;
  # returns an instance of a subclass of Net::HTTPResponse.
  #
  # The request is based on the Net::HTTPRequest object
  # created from string +path+, string +data+, and initial headers hash +header+.
  # That object is an instance of the
  # {subclass of Net::HTTPRequest}[rdoc-ref:Net::HTTPRequest@Request+Subclasses],
  # that corresponds to the given uppercase string +name+,
  # which must be
  # an {HTTP request method}[https://en.wikipedia.org/wiki/HTTP#Request_methods]
  # or a {WebDAV request method}[https://en.wikipedia.org/wiki/WebDAV#Implementation].
  #
  # Examples:
  #
  #   http = Net::HTTP.new(hostname)
  #   http.send_request('GET', '/todos/1')
  #   # => #<Net::HTTPOK 200 OK readbody=true>
  #   http.send_request('POST', '/todos', 'xyzzy')
  #   # => #<Net::HTTPCreated 201 Created readbody=true>
  #
  # source://net-http//lib/net/http.rb#2337
  def send_request(name, path, data = T.unsafe(nil), header = T.unsafe(nil)); end

  # *WARNING* This method opens a serious security hole.
  # Never use this method in production code.
  #
  # Sets the output stream for debugging:
  #
  #   http = Net::HTTP.new(hostname)
  #   File.open('t.tmp', 'w') do |file|
  #     http.set_debug_output(file)
  #     http.start
  #     http.get('/nosuch/1')
  #     http.finish
  #   end
  #   puts File.read('t.tmp')
  #
  # Output:
  #
  #   opening connection to jsonplaceholder.typicode.com:80...
  #   opened
  #   <- "GET /nosuch/1 HTTP/1.1\r\nAccept-Encoding: gzip;q=1.0,deflate;q=0.6,identity;q=0.3\r\nAccept: */*\r\nUser-Agent: Ruby\r\nHost: jsonplaceholder.typicode.com\r\n\r\n"
  #   -> "HTTP/1.1 404 Not Found\r\n"
  #   -> "Date: Mon, 12 Dec 2022 21:14:11 GMT\r\n"
  #   -> "Content-Type: application/json; charset=utf-8\r\n"
  #   -> "Content-Length: 2\r\n"
  #   -> "Connection: keep-alive\r\n"
  #   -> "X-Powered-By: Express\r\n"
  #   -> "X-Ratelimit-Limit: 1000\r\n"
  #   -> "X-Ratelimit-Remaining: 999\r\n"
  #   -> "X-Ratelimit-Reset: 1670879660\r\n"
  #   -> "Vary: Origin, Accept-Encoding\r\n"
  #   -> "Access-Control-Allow-Credentials: true\r\n"
  #   -> "Cache-Control: max-age=43200\r\n"
  #   -> "Pragma: no-cache\r\n"
  #   -> "Expires: -1\r\n"
  #   -> "X-Content-Type-Options: nosniff\r\n"
  #   -> "Etag: W/\"2-vyGp6PvFo4RvsFtPoIWeCReyIC8\"\r\n"
  #   -> "Via: 1.1 vegur\r\n"
  #   -> "CF-Cache-Status: MISS\r\n"
  #   -> "Server-Timing: cf-q-config;dur=1.3000000762986e-05\r\n"
  #   -> "Report-To: {\"endpoints\":[{\"url\":\"https:\\/\\/a.nel.cloudflare.com\\/report\\/v3?s=yOr40jo%2BwS1KHzhTlVpl54beJ5Wx2FcG4gGV0XVrh3X9OlR5q4drUn2dkt5DGO4GDcE%2BVXT7CNgJvGs%2BZleIyMu8CLieFiDIvOviOY3EhHg94m0ZNZgrEdpKD0S85S507l1vsEwEHkoTm%2Ff19SiO\"}],\"group\":\"cf-nel\",\"max_age\":604800}\r\n"
  #   -> "NEL: {\"success_fraction\":0,\"report_to\":\"cf-nel\",\"max_age\":604800}\r\n"
  #   -> "Server: cloudflare\r\n"
  #   -> "CF-RAY: 778977dc484ce591-DFW\r\n"
  #   -> "alt-svc: h3=\":443\"; ma=86400, h3-29=\":443\"; ma=86400\r\n"
  #   -> "\r\n"
  #   reading 2 bytes...
  #   -> "{}"
  #   read 2 bytes
  #   Conn keep-alive
  #
  # source://net-http//lib/net/http.rb#1264
  def set_debug_output(output); end

  # Sets or returns the SSL timeout seconds.
  #
  # source://net-http//lib/net/http.rb#1566
  def ssl_timeout; end

  # Sets or returns the SSL timeout seconds.
  #
  # source://net-http//lib/net/http.rb#1566
  def ssl_timeout=(_arg0); end

  # Sets or returns the SSL version.
  # See {OpenSSL::SSL::SSLContext#ssl_version=}[https://docs.ruby-lang.org/en/master/OpenSSL/SSL/SSLContext.html#method-i-ssl_version-3D].
  #
  # source://net-http//lib/net/http.rb#1570
  def ssl_version; end

  # Sets or returns the SSL version.
  # See {OpenSSL::SSL::SSLContext#ssl_version=}[https://docs.ruby-lang.org/en/master/OpenSSL/SSL/SSLContext.html#method-i-ssl_version-3D].
  #
  # source://net-http//lib/net/http.rb#1570
  def ssl_version=(_arg0); end

  # Starts an \HTTP session.
  #
  # Without a block, returns +self+:
  #
  #   http = Net::HTTP.new(hostname)
  #   # => #<Net::HTTP jsonplaceholder.typicode.com:80 open=false>
  #   http.start
  #   # => #<Net::HTTP jsonplaceholder.typicode.com:80 open=true>
  #   http.started? # => true
  #   http.finish
  #
  # With a block, calls the block with +self+,
  # finishes the session when the block exits,
  # and returns the block's value:
  #
  #   http.start do |http|
  #     http
  #   end
  #   # => #<Net::HTTP jsonplaceholder.typicode.com:80 open=false>
  #   http.started? # => false
  #
  # @raise [IOError]
  #
  # source://net-http//lib/net/http.rb#1627
  def start; end

  # Returns +true+ if the \HTTP session has been started:
  #
  #   http = Net::HTTP.new(hostname)
  #   http.started? # => false
  #   http.start
  #   http.started? # => true
  #   http.finish # => nil
  #   http.started? # => false
  #
  #   Net::HTTP.start(hostname) do |http|
  #     http.started?
  #   end # => true
  #   http.started? # => false
  #
  # @return [Boolean]
  #
  # source://net-http//lib/net/http.rb#1490
  def started?; end

  # Sends a TRACE request to the server;
  # returns an instance of a subclass of Net::HTTPResponse.
  #
  # The request is based on the Net::HTTP::Trace object
  # created from string +path+ and initial headers hash +initheader+.
  #
  #   http = Net::HTTP.new(hostname)
  #   http.trace('/todos/1')
  #
  # source://net-http//lib/net/http.rb#2228
  def trace(path, initheader = T.unsafe(nil)); end

  # Sends an UNLOCK request to the server;
  # returns an instance of a subclass of Net::HTTPResponse.
  #
  # The request is based on the Net::HTTP::Unlock object
  # created from string +path+, string +body+, and initial headers hash +initheader+.
  #
  #   data = '{"userId": 1, "id": 1, "title": "delectus aut autem", "completed": false}'
  #   http = Net::HTTP.new(hostname)
  #   http.unlock('/todos/1', data)
  #
  # source://net-http//lib/net/http.rb#2135
  def unlock(path, body, initheader = T.unsafe(nil)); end

  # Sets whether a new session is to use
  # {Transport Layer Security}[https://en.wikipedia.org/wiki/Transport_Layer_Security]:
  #
  # Raises IOError if attempting to change during a session.
  #
  # Raises OpenSSL::SSL::SSLError if the port is not an HTTPS port.
  #
  # source://net-http//lib/net/http.rb#1512
  def use_ssl=(flag); end

  # Returns +true+ if +self+ uses SSL, +false+ otherwise.
  # See Net::HTTP#use_ssl=.
  #
  # @return [Boolean]
  #
  # source://net-http//lib/net/http.rb#1502
  def use_ssl?; end

  # Sets or returns the callback for the server certification verification.
  #
  # source://net-http//lib/net/http.rb#1581
  def verify_callback; end

  # Sets or returns the callback for the server certification verification.
  #
  # source://net-http//lib/net/http.rb#1581
  def verify_callback=(_arg0); end

  # Sets or returns the maximum depth for the certificate chain verification.
  #
  # source://net-http//lib/net/http.rb#1584
  def verify_depth; end

  # Sets or returns the maximum depth for the certificate chain verification.
  #
  # source://net-http//lib/net/http.rb#1584
  def verify_depth=(_arg0); end

  # Sets or returns whether to verify that the server certificate is valid
  # for the hostname.
  # See {OpenSSL::SSL::SSLContext#verify_hostname=}[https://docs.ruby-lang.org/en/master/OpenSSL/SSL/SSLContext.html#attribute-i-verify_mode].
  #
  # source://net-http//lib/net/http.rb#1594
  def verify_hostname; end

  # Sets or returns whether to verify that the server certificate is valid
  # for the hostname.
  # See {OpenSSL::SSL::SSLContext#verify_hostname=}[https://docs.ruby-lang.org/en/master/OpenSSL/SSL/SSLContext.html#attribute-i-verify_mode].
  #
  # source://net-http//lib/net/http.rb#1594
  def verify_hostname=(_arg0); end

  # Sets or returns the flags for server the certification verification
  # at the beginning of the SSL/TLS session.
  # OpenSSL::SSL::VERIFY_NONE or OpenSSL::SSL::VERIFY_PEER are acceptable.
  #
  # source://net-http//lib/net/http.rb#1589
  def verify_mode; end

  # Sets or returns the flags for server the certification verification
  # at the beginning of the SSL/TLS session.
  # OpenSSL::SSL::VERIFY_NONE or OpenSSL::SSL::VERIFY_PEER are acceptable.
  #
  # source://net-http//lib/net/http.rb#1589
  def verify_mode=(_arg0); end

  # Returns the numeric (\Integer or \Float) number of seconds
  # to wait for one block to be written (via one write(2) call);
  # see #write_timeout=.
  #
  # source://net-http//lib/net/http.rb#1383
  def write_timeout; end

  # Sets the write timeout, in seconds, for +self+ to integer +sec+;
  # the initial value is 60.
  #
  # Argument +sec+ must be a non-negative numeric value:
  #
  #   _uri = uri.dup
  #   _uri.path = '/posts'
  #   body = 'bar' * 200000
  #   data = <<EOF
  #   {"title": "foo", "body": "#{body}", "userId": "1"}
  #   EOF
  #   headers = {'content-type': 'application/json'}
  #   http = Net::HTTP.new(hostname)
  #   http.write_timeout # => 60
  #   http.post(_uri.path, data, headers)
  #   # => #<Net::HTTPCreated 201 Created readbody=true>
  #   http.write_timeout = 0
  #   http.post(_uri.path, data, headers) # Raises Net::WriteTimeout.
  #
  # source://net-http//lib/net/http.rb#1444
  def write_timeout=(sec); end

  private

  # Adds a message to debugging output
  #
  # source://net-http//lib/net/http.rb#2559
  def D(msg); end

  # source://net-http//lib/net/http.rb#2545
  def addr_port; end

  # source://net-http//lib/net/http.rb#2462
  def begin_transport(req); end

  # without proxy, obsolete
  #
  # source://net-http//lib/net/http.rb#1932
  def conn_address; end

  # source://net-http//lib/net/http.rb#1936
  def conn_port; end

  # source://net-http//lib/net/http.rb#1647
  def connect; end

  # Adds a message to debugging output
  #
  # source://net-http//lib/net/http.rb#2553
  def debug(msg); end

  # source://net-http//lib/net/http.rb#1781
  def do_finish; end

  # source://net-http//lib/net/http.rb#1641
  def do_start; end

  # source://net-http//lib/net/http.rb#1940
  def edit_path(path); end

  # source://net-http//lib/net/http.rb#2485
  def end_transport(req, res); end

  # @return [Boolean]
  #
  # source://net-http//lib/net/http.rb#2502
  def keep_alive?(req, res); end

  # source://net-http//lib/net/http.rb#1763
  def on_connect; end

  # Executes a request which uses a representation
  # and returns its body.
  #
  # source://net-http//lib/net/http.rb#2396
  def send_entity(path, data, initheader, dest, type, &block); end

  # source://net-http//lib/net/http.rb#2526
  def sspi_auth(req); end

  # @return [Boolean]
  #
  # source://net-http//lib/net/http.rb#2511
  def sspi_auth?(res); end

  # source://net-http//lib/net/http.rb#2407
  def transport_request(req); end

  # source://net-http//lib/net/http.rb#1925
  def unescape(value); end

  class << self
    # Creates an \HTTP proxy class which behaves like \Net::HTTP, but
    # performs all access via the specified proxy.
    #
    # This class is obsolete.  You may pass these same parameters directly to
    # \Net::HTTP.new.  See Net::HTTP.new for details of the arguments.
    #
    # source://net-http//lib/net/http.rb#1808
    def Proxy(p_addr = T.unsafe(nil), p_port = T.unsafe(nil), p_user = T.unsafe(nil), p_pass = T.unsafe(nil), p_use_ssl = T.unsafe(nil)); end

    # Allows to set the default configuration that will be used
    # when creating a new connection.
    #
    # Example:
    #
    #   Net::HTTP.default_configuration = {
    #     read_timeout: 1,
    #     write_timeout: 1
    #   }
    #   http = Net::HTTP.new(hostname)
    #   http.open_timeout   # => 60
    #   http.read_timeout   # => 1
    #   http.write_timeout  # => 1
    #
    # source://net-http//lib/net/http.rb#1148
    def default_configuration; end

    # Allows to set the default configuration that will be used
    # when creating a new connection.
    #
    # Example:
    #
    #   Net::HTTP.default_configuration = {
    #     read_timeout: 1,
    #     write_timeout: 1
    #   }
    #   http = Net::HTTP.new(hostname)
    #   http.open_timeout   # => 60
    #   http.read_timeout   # => 1
    #   http.write_timeout  # => 1
    #
    # source://net-http//lib/net/http.rb#1148
    def default_configuration=(_arg0); end

    # Returns integer +80+, the default port to use for \HTTP requests:
    #
    #   Net::HTTP.default_port # => 80
    #
    # source://net-http//lib/net/http.rb#941
    def default_port; end

    # :call-seq:
    #   Net::HTTP.get(hostname, path, port = 80) -> body
    #   Net::HTTP:get(uri, headers = {}, port = uri.port) -> body
    #
    # Sends a GET request and returns the \HTTP response body as a string.
    #
    # With string arguments +hostname+ and +path+:
    #
    #   hostname = 'jsonplaceholder.typicode.com'
    #   path = '/todos/1'
    #   puts Net::HTTP.get(hostname, path)
    #
    # Output:
    #
    #   {
    #     "userId": 1,
    #     "id": 1,
    #     "title": "delectus aut autem",
    #     "completed": false
    #   }
    #
    # With URI object +uri+ and optional hash argument +headers+:
    #
    #   uri = URI('https://jsonplaceholder.typicode.com/todos/1')
    #   headers = {'Content-type' => 'application/json; charset=UTF-8'}
    #   Net::HTTP.get(uri, headers)
    #
    # Related:
    #
    # - Net::HTTP::Get: request class for \HTTP method +GET+.
    # - Net::HTTP#get: convenience method for \HTTP method +GET+.
    #
    # source://net-http//lib/net/http.rb#810
    def get(uri_or_host, path_or_headers = T.unsafe(nil), port = T.unsafe(nil)); end

    # :call-seq:
    #   Net::HTTP.get_print(hostname, path, port = 80) -> nil
    #   Net::HTTP:get_print(uri, headers = {}, port = uri.port) -> nil
    #
    # Like Net::HTTP.get, but writes the returned body to $stdout;
    # returns +nil+.
    #
    # source://net-http//lib/net/http.rb#769
    def get_print(uri_or_host, path_or_headers = T.unsafe(nil), port = T.unsafe(nil)); end

    # :call-seq:
    #   Net::HTTP.get_response(hostname, path, port = 80) -> http_response
    #   Net::HTTP:get_response(uri, headers = {}, port = uri.port) -> http_response
    #
    # Like Net::HTTP.get, but returns a Net::HTTPResponse object
    # instead of the body string.
    #
    # source://net-http//lib/net/http.rb#820
    def get_response(uri_or_host, path_or_headers = T.unsafe(nil), port = T.unsafe(nil), &block); end

    # Returns integer +80+, the default port to use for \HTTP requests:
    #
    #   Net::HTTP.http_default_port # => 80
    #
    # source://net-http//lib/net/http.rb#949
    def http_default_port; end

    # Returns integer +443+, the default port to use for HTTPS requests:
    #
    #   Net::HTTP.https_default_port # => 443
    #
    # source://net-http//lib/net/http.rb#957
    def https_default_port; end

    # Returns +false+; retained for compatibility.
    #
    # @return [Boolean]
    #
    # source://net-http//lib/net/http.rb#759
    def is_version_1_1?; end

    # Returns +true+; retained for compatibility.
    #
    # @return [Boolean]
    #
    # source://net-http//lib/net/http.rb#760
    def is_version_1_2?; end

    # Returns a new \Net::HTTP object +http+
    # (but does not open a TCP connection or \HTTP session).
    #
    # With only string argument +address+ given
    # (and <tt>ENV['http_proxy']</tt> undefined or +nil+),
    # the returned +http+:
    #
    # - Has the given address.
    # - Has the default port number, Net::HTTP.default_port (80).
    # - Has no proxy.
    #
    # Example:
    #
    #   http = Net::HTTP.new(hostname)
    #   # => #<Net::HTTP jsonplaceholder.typicode.com:80 open=false>
    #   http.address # => "jsonplaceholder.typicode.com"
    #   http.port    # => 80
    #   http.proxy?  # => false
    #
    # With integer argument +port+ also given,
    # the returned +http+ has the given port:
    #
    #   http = Net::HTTP.new(hostname, 8000)
    #   # => #<Net::HTTP jsonplaceholder.typicode.com:8000 open=false>
    #   http.port # => 8000
    #
    # For proxy-defining arguments +p_addr+ through +p_no_proxy+,
    # see {Proxy Server}[rdoc-ref:Net::HTTP@Proxy+Server].
    #
    # source://net-http//lib/net/http.rb#1106
    def new(address, port = T.unsafe(nil), p_addr = T.unsafe(nil), p_port = T.unsafe(nil), p_user = T.unsafe(nil), p_pass = T.unsafe(nil), p_no_proxy = T.unsafe(nil), p_use_ssl = T.unsafe(nil)); end

    # source://net-http//lib/net/http.rb#1074
    def newobj(*_arg0); end

    # Posts data to a host; returns a Net::HTTPResponse object.
    #
    # Argument +url+ must be a URL;
    # argument +data+ must be a string:
    #
    #   _uri = uri.dup
    #   _uri.path = '/posts'
    #   data = '{"title": "foo", "body": "bar", "userId": 1}'
    #   headers = {'content-type': 'application/json'}
    #   res = Net::HTTP.post(_uri, data, headers) # => #<Net::HTTPCreated 201 Created readbody=true>
    #   puts res.body
    #
    # Output:
    #
    #   {
    #     "title": "foo",
    #     "body": "bar",
    #     "userId": 1,
    #     "id": 101
    #   }
    #
    # Related:
    #
    # - Net::HTTP::Post: request class for \HTTP method +POST+.
    # - Net::HTTP#post: convenience method for \HTTP method +POST+.
    #
    # source://net-http//lib/net/http.rb#863
    def post(url, data, header = T.unsafe(nil)); end

    # Posts data to a host; returns a Net::HTTPResponse object.
    #
    # Argument +url+ must be a URI;
    # argument +data+ must be a hash:
    #
    #   _uri = uri.dup
    #   _uri.path = '/posts'
    #   data = {title: 'foo', body: 'bar', userId: 1}
    #   res = Net::HTTP.post_form(_uri, data) # => #<Net::HTTPCreated 201 Created readbody=true>
    #   puts res.body
    #
    # Output:
    #
    #   {
    #     "title": "foo",
    #     "body": "bar",
    #     "userId": "1",
    #     "id": 101
    #   }
    #
    # source://net-http//lib/net/http.rb#890
    def post_form(url, params); end

    # Returns the address of the proxy host, or +nil+ if none;
    # see Net::HTTP@Proxy+Server.
    #
    # source://net-http//lib/net/http.rb#1838
    def proxy_address; end

    # Returns true if self is a class which was created by HTTP::Proxy.
    #
    # @return [Boolean]
    #
    # source://net-http//lib/net/http.rb#1832
    def proxy_class?; end

    # Returns the password for accessing the proxy, or +nil+ if none;
    # see Net::HTTP@Proxy+Server.
    #
    # source://net-http//lib/net/http.rb#1850
    def proxy_pass; end

    # Returns the port number of the proxy host, or +nil+ if none;
    # see Net::HTTP@Proxy+Server.
    #
    # source://net-http//lib/net/http.rb#1842
    def proxy_port; end

    # Use SSL when talking to the proxy. If Net::HTTP does not use a proxy, nil.
    #
    # source://net-http//lib/net/http.rb#1853
    def proxy_use_ssl; end

    # Returns the user name for accessing the proxy, or +nil+ if none;
    # see Net::HTTP@Proxy+Server.
    #
    # source://net-http//lib/net/http.rb#1846
    def proxy_user; end

    # Sends a PUT request to the server; returns a Net::HTTPResponse object.
    #
    # Argument +url+ must be a URL;
    # argument +data+ must be a string:
    #
    #   _uri = uri.dup
    #   _uri.path = '/posts'
    #   data = '{"title": "foo", "body": "bar", "userId": 1}'
    #   headers = {'content-type': 'application/json'}
    #   res = Net::HTTP.put(_uri, data, headers) # => #<Net::HTTPCreated 201 Created readbody=true>
    #   puts res.body
    #
    # Output:
    #
    #   {
    #     "title": "foo",
    #     "body": "bar",
    #     "userId": 1,
    #     "id": 101
    #   }
    #
    # Related:
    #
    # - Net::HTTP::Put: request class for \HTTP method +PUT+.
    # - Net::HTTP#put: convenience method for \HTTP method +PUT+.
    #
    # source://net-http//lib/net/http.rb#926
    def put(url, data, header = T.unsafe(nil)); end

    # source://net-http//lib/net/http.rb#961
    def socket_type; end

    # :call-seq:
    #   HTTP.start(address, port = nil, p_addr = :ENV, p_port = nil, p_user = nil, p_pass = nil, opts) -> http
    #   HTTP.start(address, port = nil, p_addr = :ENV, p_port = nil, p_user = nil, p_pass = nil, opts) {|http| ... } -> object
    #
    # Creates a new \Net::HTTP object, +http+, via \Net::HTTP.new:
    #
    # - For arguments +address+ and +port+, see Net::HTTP.new.
    # - For proxy-defining arguments +p_addr+ through +p_pass+,
    #   see {Proxy Server}[rdoc-ref:Net::HTTP@Proxy+Server].
    # - For argument +opts+, see below.
    #
    # With no block given:
    #
    # - Calls <tt>http.start</tt> with no block (see #start),
    #   which opens a TCP connection and \HTTP session.
    # - Returns +http+.
    # - The caller should call #finish to close the session:
    #
    #     http = Net::HTTP.start(hostname)
    #     http.started? # => true
    #     http.finish
    #     http.started? # => false
    #
    # With a block given:
    #
    # - Calls <tt>http.start</tt> with the block (see #start), which:
    #
    #   - Opens a TCP connection and \HTTP session.
    #   - Calls the block,
    #     which may make any number of requests to the host.
    #   - Closes the \HTTP session and TCP connection on block exit.
    #   - Returns the block's value +object+.
    #
    # - Returns +object+.
    #
    # Example:
    #
    #   hostname = 'jsonplaceholder.typicode.com'
    #   Net::HTTP.start(hostname) do |http|
    #     puts http.get('/todos/1').body
    #     puts http.get('/todos/2').body
    #   end
    #
    # Output:
    #
    #   {
    #     "userId": 1,
    #     "id": 1,
    #     "title": "delectus aut autem",
    #     "completed": false
    #   }
    #   {
    #     "userId": 1,
    #     "id": 2,
    #     "title": "quis ut nam facilis et officia qui",
    #     "completed": false
    #   }
    #
    # If the last argument given is a hash, it is the +opts+ hash,
    # where each key is a method or accessor to be called,
    # and its value is the value to be set.
    #
    # The keys may include:
    #
    # - #ca_file
    # - #ca_path
    # - #cert
    # - #cert_store
    # - #ciphers
    # - #close_on_empty_response
    # - +ipaddr+ (calls #ipaddr=)
    # - #keep_alive_timeout
    # - #key
    # - #open_timeout
    # - #read_timeout
    # - #ssl_timeout
    # - #ssl_version
    # - +use_ssl+ (calls #use_ssl=)
    # - #verify_callback
    # - #verify_depth
    # - #verify_mode
    # - #write_timeout
    #
    # Note: If +port+ is +nil+ and <tt>opts[:use_ssl]</tt> is a truthy value,
    # the value passed to +new+ is Net::HTTP.https_default_port, not +port+.
    #
    # source://net-http//lib/net/http.rb#1051
    def start(address, *arg, &block); end

    # Returns +false+; retained for compatibility.
    #
    # @return [Boolean]
    #
    # source://net-http//lib/net/http.rb#754
    def version_1_1?; end

    # Returns +true+; retained for compatibility.
    #
    # source://net-http//lib/net/http.rb#744
    def version_1_2; end

    # Returns +true+; retained for compatibility.
    #
    # @return [Boolean]
    #
    # source://net-http//lib/net/http.rb#749
    def version_1_2?; end
  end
end

# source://net-http//lib/net/http/proxy_delta.rb#2
module Net::HTTP::ProxyDelta
  private

  # source://net-http//lib/net/http/proxy_delta.rb#5
  def conn_address; end

  # source://net-http//lib/net/http/proxy_delta.rb#9
  def conn_port; end

  # source://net-http//lib/net/http/proxy_delta.rb#13
  def edit_path(path); end
end

# :stopdoc:
#
# source://net-http//lib/net/http.rb#733
Net::HTTP::VERSION = T.let(T.unsafe(nil), String)

# Response class for <tt>Already Reported (WebDAV)</tt> responses (status code 208).
#
# The <tt>Already Reported (WebDAV)</tt> response indicates that the server
# has received the request,
# and that the members of a DAV binding have already been enumerated
# in a preceding part of the (multi-status) response,
# and are not being included again.
#
# :include: doc/net-http/included_getters.rdoc
#
# References:
#
# - {RFC 5842}[https://www.rfc-editor.org/rfc/rfc5842.html#section-7.1].
# - {Wikipedia}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#208].
#
# source://net-http//lib/net/http/responses.rb#306
class Net::HTTPAlreadyReported < ::Net::HTTPSuccess; end

# source://net-http//lib/net/http/responses.rb#307
Net::HTTPAlreadyReported::HAS_BODY = T.let(T.unsafe(nil), TrueClass)

# source://net-http//lib/net/http/responses.rb#67
Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPClientException

# source://net-http//lib/net/http/exceptions.rb#23
class Net::HTTPClientException < ::Net::ProtoServerError
  include ::Net::HTTPExceptions
end

# Response class for <tt>Early Hints</tt> responses (status code 103).
#
# The <tt>Early Hints</tt> indicates that the server has received
# and is processing the request, and contains certain headers;
# the final response is not available yet.
#
# :include: doc/net-http/included_getters.rdoc
#
# References:
#
# - {Mozilla}[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/103].
# - {RFC 8297}[https://www.rfc-editor.org/rfc/rfc8297.html#section-2].
# - {Wikipedia}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#103].
#
# source://net-http//lib/net/http/responses.rb#147
class Net::HTTPEarlyHints < ::Net::HTTPInformation; end

# source://net-http//lib/net/http/responses.rb#148
Net::HTTPEarlyHints::HAS_BODY = T.let(T.unsafe(nil), FalseClass)

# source://net-http//lib/net/http/exceptions.rb#15
class Net::HTTPError < ::Net::ProtocolError
  include ::Net::HTTPExceptions
end

# Net::HTTP exception class.
# You cannot use Net::HTTPExceptions directly; instead, you must use
# its subclasses.
#
# source://net-http//lib/net/http/exceptions.rb#6
module Net::HTTPExceptions
  # source://net-http//lib/net/http/exceptions.rb#7
  def initialize(msg, res); end

  # Returns the value of attribute response.
  #
  # source://net-http//lib/net/http/exceptions.rb#12
  def data; end

  # Returns the value of attribute response.
  #
  # source://net-http//lib/net/http/exceptions.rb#11
  def response; end
end

# source://net-http//lib/net/http/exceptions.rb#27
class Net::HTTPFatalError < ::Net::ProtoFatalError
  include ::Net::HTTPExceptions
end

# \HTTPGenericRequest is the parent of the Net::HTTPRequest class.
#
# Do not use this directly; instead, use a subclass of Net::HTTPRequest.
#
# == About the Examples
#
# :include: doc/net-http/examples.rdoc
#
# source://net-http//lib/net/http/generic_request.rb#11
class Net::HTTPGenericRequest
  include ::Net::HTTPHeader

  # @return [HTTPGenericRequest] a new instance of HTTPGenericRequest
  #
  # source://net-http//lib/net/http/generic_request.rb#15
  def initialize(m, reqbody, resbody, uri_or_path, initheader = T.unsafe(nil)); end

  # Don't automatically decode response content-encoding if the user indicates
  # they want to handle it.
  #
  # source://net-http//lib/net/http/generic_request.rb#109
  def []=(key, val); end

  # Returns the string body for the request, or +nil+ if there is none:
  #
  #   req = Net::HTTP::Post.new(uri)
  #   req.body # => nil
  #   req.body = '{"title": "foo","body": "bar","userId": 1}'
  #   req.body # => "{\"title\": \"foo\",\"body\": \"bar\",\"userId\": 1}"
  #
  # source://net-http//lib/net/http/generic_request.rb#145
  def body; end

  # Sets the body for the request:
  #
  #   req = Net::HTTP::Post.new(uri)
  #   req.body # => nil
  #   req.body = '{"title": "foo","body": "bar","userId": 1}'
  #   req.body # => "{\"title\": \"foo\",\"body\": \"bar\",\"userId\": 1}"
  #
  # source://net-http//lib/net/http/generic_request.rb#154
  def body=(str); end

  # @return [Boolean]
  #
  # source://net-http//lib/net/http/generic_request.rb#133
  def body_exist?; end

  # Returns the body stream object for the request, or +nil+ if there is none:
  #
  #   req = Net::HTTP::Post.new(uri)          # => #<Net::HTTP::Post POST>
  #   req.body_stream                         # => nil
  #   require 'stringio'
  #   req.body_stream = StringIO.new('xyzzy') # => #<StringIO:0x0000027d1e5affa8>
  #   req.body_stream                         # => #<StringIO:0x0000027d1e5affa8>
  #
  # source://net-http//lib/net/http/generic_request.rb#169
  def body_stream; end

  # Sets the body stream for the request:
  #
  #   req = Net::HTTP::Post.new(uri)          # => #<Net::HTTP::Post POST>
  #   req.body_stream                         # => nil
  #   require 'stringio'
  #   req.body_stream = StringIO.new('xyzzy') # => #<StringIO:0x0000027d1e5affa8>
  #   req.body_stream                         # => #<StringIO:0x0000027d1e5affa8>
  #
  # source://net-http//lib/net/http/generic_request.rb#179
  def body_stream=(input); end

  # Returns +false+ if the request's header <tt>'Accept-Encoding'</tt>
  # has been set manually or deleted
  # (indicating that the user intends to handle encoding in the response),
  # +true+ otherwise:
  #
  #   req = Net::HTTP::Get.new(uri) # => #<Net::HTTP::Get GET>
  #   req['Accept-Encoding']        # => "gzip;q=1.0,deflate;q=0.6,identity;q=0.3"
  #   req.decode_content            # => true
  #   req['Accept-Encoding'] = 'foo'
  #   req.decode_content            # => false
  #   req.delete('Accept-Encoding')
  #   req.decode_content            # => false
  #
  # source://net-http//lib/net/http/generic_request.rb#95
  def decode_content; end

  # write
  #
  # source://net-http//lib/net/http/generic_request.rb#198
  def exec(sock, ver, path); end

  # Returns a string representation of the request:
  #
  #   Net::HTTP::Post.new(uri).inspect # => "#<Net::HTTP::Post POST>"
  #
  # source://net-http//lib/net/http/generic_request.rb#101
  def inspect; end

  # Returns the string method name for the request:
  #
  #   Net::HTTP::Get.new(uri).method  # => "GET"
  #   Net::HTTP::Post.new(uri).method # => "POST"
  #
  # source://net-http//lib/net/http/generic_request.rb#65
  def method; end

  # Returns the string path for the request:
  #
  #   Net::HTTP::Get.new(uri).path # => "/"
  #   Net::HTTP::Post.new('example.com').path # => "example.com"
  #
  # source://net-http//lib/net/http/generic_request.rb#72
  def path; end

  # Returns whether the request may have a body:
  #
  #   Net::HTTP::Post.new(uri).request_body_permitted? # => true
  #   Net::HTTP::Get.new(uri).request_body_permitted?  # => false
  #
  # @return [Boolean]
  #
  # source://net-http//lib/net/http/generic_request.rb#120
  def request_body_permitted?; end

  # Returns whether the response may have a body:
  #
  #   Net::HTTP::Post.new(uri).response_body_permitted? # => true
  #   Net::HTTP::Head.new(uri).response_body_permitted? # => false
  #
  # @return [Boolean]
  #
  # source://net-http//lib/net/http/generic_request.rb#129
  def response_body_permitted?; end

  # @raise [ArgumentError]
  #
  # source://net-http//lib/net/http/generic_request.rb#186
  def set_body_internal(str); end

  # source://net-http//lib/net/http/generic_request.rb#376
  def supply_default_content_type; end

  # source://net-http//lib/net/http/generic_request.rb#210
  def update_uri(addr, port, ssl); end

  # Returns the URI object for the request, or +nil+ if none:
  #
  #   Net::HTTP::Get.new(uri).uri
  #   # => #<URI::HTTPS https://jsonplaceholder.typicode.com/>
  #   Net::HTTP::Get.new('example.com').uri # => nil
  #
  # source://net-http//lib/net/http/generic_request.rb#80
  def uri; end

  private

  # source://net-http//lib/net/http/generic_request.rb#312
  def encode_multipart_form_data(out, params, opt); end

  # source://net-http//lib/net/http/generic_request.rb#368
  def flush_buffer(out, buf, chunked_p); end

  # source://net-http//lib/net/http/generic_request.rb#363
  def quote_string(str, charset); end

  # source://net-http//lib/net/http/generic_request.rb#260
  def send_request_with_body(sock, ver, path, body); end

  # source://net-http//lib/net/http/generic_request.rb#286
  def send_request_with_body_data(sock, ver, path, params); end

  # source://net-http//lib/net/http/generic_request.rb#269
  def send_request_with_body_stream(sock, ver, path, f); end

  # Waits up to the continue timeout for a response from the server provided
  # we're speaking HTTP 1.1 and are expecting a 100-continue response.
  #
  # source://net-http//lib/net/http/generic_request.rb#386
  def wait_for_continue(sock, ver); end

  # source://net-http//lib/net/http/generic_request.rb#399
  def write_header(sock, ver, path); end
end

# source://net-http//lib/net/http/generic_request.rb#242
class Net::HTTPGenericRequest::Chunker
  # @return [Chunker] a new instance of Chunker
  #
  # source://net-http//lib/net/http/generic_request.rb#243
  def initialize(sock); end

  # source://net-http//lib/net/http/generic_request.rb#255
  def finish; end

  # source://net-http//lib/net/http/generic_request.rb#248
  def write(buf); end
end

# The \HTTPHeader module provides access to \HTTP headers.
#
# The module is included in:
#
# - Net::HTTPGenericRequest (and therefore Net::HTTPRequest).
# - Net::HTTPResponse.
#
# The headers are a hash-like collection of key/value pairs called _fields_.
#
# == Request and Response Fields
#
# Headers may be included in:
#
# - A Net::HTTPRequest object:
#   the object's headers will be sent with the request.
#   Any fields may be defined in the request;
#   see {Setters}[rdoc-ref:Net::HTTPHeader@Setters].
# - A Net::HTTPResponse object:
#   the objects headers are usually those returned from the host.
#   Fields may be retrieved from the object;
#   see {Getters}[rdoc-ref:Net::HTTPHeader@Getters]
#   and {Iterators}[rdoc-ref:Net::HTTPHeader@Iterators].
#
# Exactly which fields should be sent or expected depends on the host;
# see:
#
# - {Request fields}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Request_fields].
# - {Response fields}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Response_fields].
#
# == About the Examples
#
# :include: doc/net-http/examples.rdoc
#
# == Fields
#
# A header field is a key/value pair.
#
# === Field Keys
#
# A field key may be:
#
# - A string: Key <tt>'Accept'</tt> is treated as if it were
#   <tt>'Accept'.downcase</tt>;  i.e., <tt>'accept'</tt>.
# - A symbol: Key <tt>:Accept</tt> is treated as if it were
#   <tt>:Accept.to_s.downcase</tt>;  i.e., <tt>'accept'</tt>.
#
# Examples:
#
#   req = Net::HTTP::Get.new(uri)
#   req[:accept]  # => "*/*"
#   req['Accept'] # => "*/*"
#   req['ACCEPT'] # => "*/*"
#
#   req['accept'] = 'text/html'
#   req[:accept] = 'text/html'
#   req['ACCEPT'] = 'text/html'
#
# === Field Values
#
# A field value may be returned as an array of strings or as a string:
#
# - These methods return field values as arrays:
#
#   - #get_fields: Returns the array value for the given key,
#     or +nil+ if it does not exist.
#   - #to_hash: Returns a hash of all header fields:
#     each key is a field name; its value is the array value for the field.
#
# - These methods return field values as string;
#   the string value for a field is equivalent to
#   <tt>self[key.downcase.to_s].join(', '))</tt>:
#
#   - #[]: Returns the string value for the given key,
#     or +nil+ if it does not exist.
#   - #fetch: Like #[], but accepts a default value
#     to be returned if the key does not exist.
#
# The field value may be set:
#
# - #[]=: Sets the value for the given key;
#   the given value may be a string, a symbol, an array, or a hash.
# - #add_field: Adds a given value to a value for the given key
#   (not overwriting the existing value).
# - #delete: Deletes the field for the given key.
#
# Example field values:
#
# - \String:
#
#     req['Accept'] = 'text/html' # => "text/html"
#     req['Accept']               # => "text/html"
#     req.get_fields('Accept')    # => ["text/html"]
#
# - \Symbol:
#
#     req['Accept'] = :text    # => :text
#     req['Accept']            # => "text"
#     req.get_fields('Accept') # => ["text"]
#
# - Simple array:
#
#     req[:foo] = %w[bar baz bat]
#     req[:foo]            # => "bar, baz, bat"
#     req.get_fields(:foo) # => ["bar", "baz", "bat"]
#
# - Simple hash:
#
#     req[:foo] = {bar: 0, baz: 1, bat: 2}
#     req[:foo]            # => "bar, 0, baz, 1, bat, 2"
#     req.get_fields(:foo) # => ["bar", "0", "baz", "1", "bat", "2"]
#
# - Nested:
#
#     req[:foo] = [%w[bar baz], {bat: 0, bam: 1}]
#     req[:foo]            # => "bar, baz, bat, 0, bam, 1"
#     req.get_fields(:foo) # => ["bar", "baz", "bat", "0", "bam", "1"]
#
#     req[:foo] = {bar: %w[baz bat], bam: {bah: 0, bad: 1}}
#     req[:foo]            # => "bar, baz, bat, bam, bah, 0, bad, 1"
#     req.get_fields(:foo) # => ["bar", "baz", "bat", "bam", "bah", "0", "bad", "1"]
#
# == Convenience Methods
#
# Various convenience methods retrieve values, set values, query values,
# set form values, or iterate over fields.
#
# === Setters
#
# \Method #[]= can set any field, but does little to validate the new value;
# some of the other setter methods provide some validation:
#
# - #[]=: Sets the string or array value for the given key.
# - #add_field: Creates or adds to the array value for the given key.
# - #basic_auth: Sets the string authorization header for <tt>'Authorization'</tt>.
# - #content_length=: Sets the integer length for field <tt>'Content-Length</tt>.
# - #content_type=: Sets the string value for field <tt>'Content-Type'</tt>.
# - #proxy_basic_auth: Sets the string authorization header for <tt>'Proxy-Authorization'</tt>.
# - #set_range: Sets the value for field <tt>'Range'</tt>.
#
# === Form Setters
#
# - #set_form: Sets an HTML form data set.
# - #set_form_data: Sets header fields and a body from HTML form data.
#
# === Getters
#
# \Method #[] can retrieve the value of any field that exists,
# but always as a string;
# some of the other getter methods return something different
# from the simple string value:
#
# - #[]: Returns the string field value for the given key.
# - #content_length: Returns the integer value of field <tt>'Content-Length'</tt>.
# - #content_range: Returns the Range value of field <tt>'Content-Range'</tt>.
# - #content_type: Returns the string value of field <tt>'Content-Type'</tt>.
# - #fetch: Returns the string field value for the given key.
# - #get_fields: Returns the array field value for the given +key+.
# - #main_type: Returns first part of the string value of field <tt>'Content-Type'</tt>.
# - #sub_type: Returns second part of the string value of field <tt>'Content-Type'</tt>.
# - #range: Returns an array of Range objects of field <tt>'Range'</tt>, or +nil+.
# - #range_length: Returns the integer length of the range given in field <tt>'Content-Range'</tt>.
# - #type_params: Returns the string parameters for <tt>'Content-Type'</tt>.
#
# === Queries
#
# - #chunked?: Returns whether field <tt>'Transfer-Encoding'</tt> is set to <tt>'chunked'</tt>.
# - #connection_close?: Returns whether field <tt>'Connection'</tt> is set to <tt>'close'</tt>.
# - #connection_keep_alive?: Returns whether field <tt>'Connection'</tt> is set to <tt>'keep-alive'</tt>.
# - #key?: Returns whether a given key exists.
#
# === Iterators
#
# - #each_capitalized: Passes each field capitalized-name/value pair to the block.
# - #each_capitalized_name: Passes each capitalized field name to the block.
# - #each_header: Passes each field name/value pair to the block.
# - #each_name: Passes each field name to the block.
# - #each_value: Passes each string field value to the block.
#
# source://net-http//lib/net/http/header.rb#181
module Net::HTTPHeader
  # Returns the string field value for the case-insensitive field +key+,
  # or +nil+ if there is no such key;
  # see {Fields}[rdoc-ref:Net::HTTPHeader@Fields]:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res['Connection'] # => "keep-alive"
  #   res['Nosuch']     # => nil
  #
  # Note that some field values may be retrieved via convenience methods;
  # see {Getters}[rdoc-ref:Net::HTTPHeader@Getters].
  #
  # source://net-http//lib/net/http/header.rb#224
  def [](key); end

  # Sets the value for the case-insensitive +key+ to +val+,
  # overwriting the previous value if the field exists;
  # see {Fields}[rdoc-ref:Net::HTTPHeader@Fields]:
  #
  #   req = Net::HTTP::Get.new(uri)
  #   req['Accept'] # => "*/*"
  #   req['Accept'] = 'text/html'
  #   req['Accept'] # => "text/html"
  #
  # Note that some field values may be set via convenience methods;
  # see {Setters}[rdoc-ref:Net::HTTPHeader@Setters].
  #
  # source://net-http//lib/net/http/header.rb#240
  def []=(key, val); end

  # Adds value +val+ to the value array for field +key+ if the field exists;
  # creates the field with the given +key+ and +val+ if it does not exist.
  # see {Fields}[rdoc-ref:Net::HTTPHeader@Fields]:
  #
  #   req = Net::HTTP::Get.new(uri)
  #   req.add_field('Foo', 'bar')
  #   req['Foo']            # => "bar"
  #   req.add_field('Foo', 'baz')
  #   req['Foo']            # => "bar, baz"
  #   req.add_field('Foo', %w[baz bam])
  #   req['Foo']            # => "bar, baz, baz, bam"
  #   req.get_fields('Foo') # => ["bar", "baz", "baz", "bam"]
  #
  # source://net-http//lib/net/http/header.rb#261
  def add_field(key, val); end

  # Sets header <tt>'Authorization'</tt> using the given
  # +account+ and +password+ strings:
  #
  #   req.basic_auth('my_account', 'my_password')
  #   req['Authorization']
  #   # => "Basic bXlfYWNjb3VudDpteV9wYXNzd29yZA=="
  #
  # source://net-http//lib/net/http/header.rb#945
  def basic_auth(account, password); end

  # Like #each_header, but the keys are returned in capitalized form.
  #
  # Net::HTTPHeader#canonical_each is an alias for Net::HTTPHeader#each_capitalized.
  #
  # source://net-http//lib/net/http/header.rb#491
  def canonical_each; end

  # Returns +true+ if field <tt>'Transfer-Encoding'</tt>
  # exists and has value <tt>'chunked'</tt>,
  # +false+ otherwise;
  # see {Transfer-Encoding response header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#transfer-encoding-response-header]:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res['Transfer-Encoding'] # => "chunked"
  #   res.chunked?             # => true
  #
  # @return [Boolean]
  #
  # source://net-http//lib/net/http/header.rb#654
  def chunked?; end

  # Returns whether the HTTP session is to be closed.
  #
  # @return [Boolean]
  #
  # source://net-http//lib/net/http/header.rb#966
  def connection_close?; end

  # Returns whether the HTTP session is to be kept alive.
  #
  # @return [Boolean]
  #
  # source://net-http//lib/net/http/header.rb#974
  def connection_keep_alive?; end

  # Returns the value of field <tt>'Content-Length'</tt> as an integer,
  # or +nil+ if there is no such field;
  # see {Content-Length request header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-length-request-header]:
  #
  #   res = Net::HTTP.get_response(hostname, '/nosuch/1')
  #   res.content_length # => 2
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res.content_length # => nil
  #
  # source://net-http//lib/net/http/header.rb#616
  def content_length; end

  # Sets the value of field <tt>'Content-Length'</tt> to the given numeric;
  # see {Content-Length response header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-length-response-header]:
  #
  #   _uri = uri.dup
  #   hostname = _uri.hostname           # => "jsonplaceholder.typicode.com"
  #   _uri.path = '/posts'               # => "/posts"
  #   req = Net::HTTP::Post.new(_uri)    # => #<Net::HTTP::Post POST>
  #   req.body = '{"title": "foo","body": "bar","userId": 1}'
  #   req.content_length = req.body.size # => 42
  #   req.content_type = 'application/json'
  #   res = Net::HTTP.start(hostname) do |http|
  #     http.request(req)
  #   end # => #<Net::HTTPCreated 201 Created readbody=true>
  #
  # source://net-http//lib/net/http/header.rb#637
  def content_length=(len); end

  # Returns a Range object representing the value of field
  # <tt>'Content-Range'</tt>, or +nil+ if no such field exists;
  # see {Content-Range response header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-range-response-header]:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res['Content-Range'] # => nil
  #   res['Content-Range'] = 'bytes 0-499/1000'
  #   res['Content-Range'] # => "bytes 0-499/1000"
  #   res.content_range    # => 0..499
  #
  # source://net-http//lib/net/http/header.rb#670
  def content_range; end

  # Returns the {media type}[https://en.wikipedia.org/wiki/Media_type]
  # from the value of field <tt>'Content-Type'</tt>,
  # or +nil+ if no such field exists;
  # see {Content-Type response header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-response-header]:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res['content-type'] # => "application/json; charset=utf-8"
  #   res.content_type    # => "application/json"
  #
  # source://net-http//lib/net/http/header.rb#701
  def content_type; end

  # Sets the value of field <tt>'Content-Type'</tt>;
  # returns the new value;
  # see {Content-Type request header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-request-header]:
  #
  #   req = Net::HTTP::Get.new(uri)
  #   req.set_content_type('application/json') # => ["application/json"]
  #
  # Net::HTTPHeader#content_type= is an alias for Net::HTTPHeader#set_content_type.
  #
  # source://net-http//lib/net/http/header.rb#776
  def content_type=(type, params = T.unsafe(nil)); end

  # Removes the header for the given case-insensitive +key+
  # (see {Fields}[rdoc-ref:Net::HTTPHeader@Fields]);
  # returns the deleted value, or +nil+ if no such field exists:
  #
  #   req = Net::HTTP::Get.new(uri)
  #   req.delete('Accept') # => ["*/*"]
  #   req.delete('Nosuch') # => nil
  #
  # source://net-http//lib/net/http/header.rb#453
  def delete(key); end

  # Calls the block with each key/value pair:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res.each_header do |key, value|
  #     p [key, value] if key.start_with?('c')
  #   end
  #
  # Output:
  #
  #   ["content-type", "application/json; charset=utf-8"]
  #   ["connection", "keep-alive"]
  #   ["cache-control", "max-age=43200"]
  #   ["cf-cache-status", "HIT"]
  #   ["cf-ray", "771d17e9bc542cf5-ORD"]
  #
  # Returns an enumerator if no block is given.
  #
  # Net::HTTPHeader#each is an alias for Net::HTTPHeader#each_header.
  #
  # source://net-http//lib/net/http/header.rb#371
  def each; end

  # Like #each_header, but the keys are returned in capitalized form.
  #
  # Net::HTTPHeader#canonical_each is an alias for Net::HTTPHeader#each_capitalized.
  #
  # source://net-http//lib/net/http/header.rb#484
  def each_capitalized; end

  # Calls the block with each capitalized field name:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res.each_capitalized_name do |key|
  #     p key if key.start_with?('C')
  #   end
  #
  # Output:
  #
  #   "Content-Type"
  #   "Connection"
  #   "Cache-Control"
  #   "Cf-Cache-Status"
  #   "Cf-Ray"
  #
  # The capitalization is system-dependent;
  # see {Case Mapping}[https://docs.ruby-lang.org/en/master/case_mapping_rdoc.html].
  #
  # Returns an enumerator if no block is given.
  #
  # source://net-http//lib/net/http/header.rb#417
  def each_capitalized_name; end

  # Calls the block with each key/value pair:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res.each_header do |key, value|
  #     p [key, value] if key.start_with?('c')
  #   end
  #
  # Output:
  #
  #   ["content-type", "application/json; charset=utf-8"]
  #   ["connection", "keep-alive"]
  #   ["cache-control", "max-age=43200"]
  #   ["cf-cache-status", "HIT"]
  #   ["cf-ray", "771d17e9bc542cf5-ORD"]
  #
  # Returns an enumerator if no block is given.
  #
  # Net::HTTPHeader#each is an alias for Net::HTTPHeader#each_header.
  #
  # source://net-http//lib/net/http/header.rb#364
  def each_header; end

  # Calls the block with each field key:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res.each_key do |key|
  #     p key if key.start_with?('c')
  #   end
  #
  # Output:
  #
  #   "content-type"
  #   "connection"
  #   "cache-control"
  #   "cf-cache-status"
  #   "cf-ray"
  #
  # Returns an enumerator if no block is given.
  #
  # Net::HTTPHeader#each_name is an alias for Net::HTTPHeader#each_key.
  #
  # source://net-http//lib/net/http/header.rb#396
  def each_key(&block); end

  # Calls the block with each field key:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res.each_key do |key|
  #     p key if key.start_with?('c')
  #   end
  #
  # Output:
  #
  #   "content-type"
  #   "connection"
  #   "cache-control"
  #   "cf-cache-status"
  #   "cf-ray"
  #
  # Returns an enumerator if no block is given.
  #
  # Net::HTTPHeader#each_name is an alias for Net::HTTPHeader#each_key.
  #
  # source://net-http//lib/net/http/header.rb#391
  def each_name(&block); end

  # Calls the block with each string field value:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res.each_value do |value|
  #     p value if value.start_with?('c')
  #   end
  #
  # Output:
  #
  #   "chunked"
  #   "cf-q-config;dur=6.0000002122251e-06"
  #   "cloudflare"
  #
  # Returns an enumerator if no block is given.
  #
  # source://net-http//lib/net/http/header.rb#438
  def each_value; end

  # call-seq:
  #   fetch(key, default_val = nil) {|key| ... } -> object
  #   fetch(key, default_val = nil) -> value or default_val
  #
  # With a block, returns the string value for +key+ if it exists;
  # otherwise returns the value of the block;
  # ignores the +default_val+;
  # see {Fields}[rdoc-ref:Net::HTTPHeader@Fields]:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #
  #   # Field exists; block not called.
  #   res.fetch('Connection') do |value|
  #     fail 'Cannot happen'
  #   end # => "keep-alive"
  #
  #   # Field does not exist; block called.
  #   res.fetch('Nosuch') do |value|
  #     value.downcase
  #   end # => "nosuch"
  #
  # With no block, returns the string value for +key+ if it exists;
  # otherwise, returns +default_val+ if it was given;
  # otherwise raises an exception:
  #
  #   res.fetch('Connection', 'Foo') # => "keep-alive"
  #   res.fetch('Nosuch', 'Foo')     # => "Foo"
  #   res.fetch('Nosuch')            # Raises KeyError.
  #
  # source://net-http//lib/net/http/header.rb#341
  def fetch(key, *args, &block); end

  # Sets the request body to a URL-encoded string derived from argument +params+,
  # and sets request header field <tt>'Content-Type'</tt>
  # to <tt>'application/x-www-form-urlencoded'</tt>.
  #
  # The resulting request is suitable for HTTP request +POST+ or +PUT+.
  #
  # Argument +params+ must be suitable for use as argument +enum+ to
  # {URI.encode_www_form}[https://docs.ruby-lang.org/en/master/URI.html#method-c-encode_www_form].
  #
  # With only argument +params+ given,
  # sets the body to a URL-encoded string with the default separator <tt>'&'</tt>:
  #
  #   req = Net::HTTP::Post.new('example.com')
  #
  #   req.set_form_data(q: 'ruby', lang: 'en')
  #   req.body            # => "q=ruby&lang=en"
  #   req['Content-Type'] # => "application/x-www-form-urlencoded"
  #
  #   req.set_form_data([['q', 'ruby'], ['lang', 'en']])
  #   req.body            # => "q=ruby&lang=en"
  #
  #   req.set_form_data(q: ['ruby', 'perl'], lang: 'en')
  #   req.body            # => "q=ruby&q=perl&lang=en"
  #
  #   req.set_form_data([['q', 'ruby'], ['q', 'perl'], ['lang', 'en']])
  #   req.body            # => "q=ruby&q=perl&lang=en"
  #
  # With string argument +sep+ also given,
  # uses that string as the separator:
  #
  #   req.set_form_data({q: 'ruby', lang: 'en'}, '|')
  #   req.body # => "q=ruby|lang=en"
  #
  # Net::HTTPHeader#form_data= is an alias for Net::HTTPHeader#set_form_data.
  #
  # source://net-http//lib/net/http/header.rb#819
  def form_data=(params, sep = T.unsafe(nil)); end

  # Returns the array field value for the given +key+,
  # or +nil+ if there is no such field;
  # see {Fields}[rdoc-ref:Net::HTTPHeader@Fields]:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res.get_fields('Connection') # => ["keep-alive"]
  #   res.get_fields('Nosuch')     # => nil
  #
  # source://net-http//lib/net/http/header.rb#306
  def get_fields(key); end

  # source://net-http//lib/net/http/header.rb#185
  def initialize_http_header(initheader); end

  # Returns +true+ if the field for the case-insensitive +key+ exists, +false+ otherwise:
  #
  #   req = Net::HTTP::Get.new(uri)
  #   req.key?('Accept') # => true
  #   req.key?('Nosuch') # => false
  #
  # @return [Boolean]
  #
  # source://net-http//lib/net/http/header.rb#463
  def key?(key); end

  # source://net-http//lib/net/http/header.rb#212
  def length; end

  # Returns the leading ('type') part of the
  # {media type}[https://en.wikipedia.org/wiki/Media_type]
  # from the value of field <tt>'Content-Type'</tt>,
  # or +nil+ if no such field exists;
  # see {Content-Type response header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-response-header]:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res['content-type'] # => "application/json; charset=utf-8"
  #   res.main_type       # => "application"
  #
  # source://net-http//lib/net/http/header.rb#723
  def main_type; end

  # Sets header <tt>'Proxy-Authorization'</tt> using the given
  # +account+ and +password+ strings:
  #
  #   req.proxy_basic_auth('my_account', 'my_password')
  #   req['Proxy-Authorization']
  #   # => "Basic bXlfYWNjb3VudDpteV9wYXNzd29yZA=="
  #
  # source://net-http//lib/net/http/header.rb#956
  def proxy_basic_auth(account, password); end

  # Returns an array of Range objects that represent
  # the value of field <tt>'Range'</tt>,
  # or +nil+ if there is no such field;
  # see {Range request header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#range-request-header]:
  #
  #   req = Net::HTTP::Get.new(uri)
  #   req['Range'] = 'bytes=0-99,200-299,400-499'
  #   req.range # => [0..99, 200..299, 400..499]
  #   req.delete('Range')
  #   req.range # # => nil
  #
  # source://net-http//lib/net/http/header.rb#509
  def range; end

  # call-seq:
  #   set_range(length) -> length
  #   set_range(offset, length) -> range
  #   set_range(begin..length) -> range
  #
  # Sets the value for field <tt>'Range'</tt>;
  # see {Range request header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#range-request-header]:
  #
  # With argument +length+:
  #
  #   req = Net::HTTP::Get.new(uri)
  #   req.set_range(100)      # => 100
  #   req['Range']            # => "bytes=0-99"
  #
  # With arguments +offset+ and +length+:
  #
  #   req.set_range(100, 100) # => 100...200
  #   req['Range']            # => "bytes=100-199"
  #
  # With argument +range+:
  #
  #   req.set_range(100..199) # => 100..199
  #   req['Range']            # => "bytes=100-199"
  #
  # Net::HTTPHeader#range= is an alias for Net::HTTPHeader#set_range.
  #
  # source://net-http//lib/net/http/header.rb#605
  def range=(r, e = T.unsafe(nil)); end

  # Returns the integer representing length of the value of field
  # <tt>'Content-Range'</tt>, or +nil+ if no such field exists;
  # see {Content-Range response header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-range-response-header]:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res['Content-Range'] # => nil
  #   res['Content-Range'] = 'bytes 0-499/1000'
  #   res.range_length     # => 500
  #
  # source://net-http//lib/net/http/header.rb#687
  def range_length; end

  # Sets the value of field <tt>'Content-Type'</tt>;
  # returns the new value;
  # see {Content-Type request header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-request-header]:
  #
  #   req = Net::HTTP::Get.new(uri)
  #   req.set_content_type('application/json') # => ["application/json"]
  #
  # Net::HTTPHeader#content_type= is an alias for Net::HTTPHeader#set_content_type.
  #
  # source://net-http//lib/net/http/header.rb#772
  def set_content_type(type, params = T.unsafe(nil)); end

  # Stores form data to be used in a +POST+ or +PUT+ request.
  #
  # The form data given in +params+ consists of zero or more fields;
  # each field is:
  #
  # - A scalar value.
  # - A name/value pair.
  # - An IO stream opened for reading.
  #
  # Argument +params+ should be an
  # {Enumerable}[https://docs.ruby-lang.org/en/master/Enumerable.html#module-Enumerable-label-Enumerable+in+Ruby+Classes]
  # (method <tt>params.map</tt> will be called),
  # and is often an array or hash.
  #
  # First, we set up a request:
  #
  #   _uri = uri.dup
  #   _uri.path ='/posts'
  #   req = Net::HTTP::Post.new(_uri)
  #
  # <b>Argument +params+ As an Array</b>
  #
  # When +params+ is an array,
  # each of its elements is a subarray that defines a field;
  # the subarray may contain:
  #
  # - One string:
  #
  #     req.set_form([['foo'], ['bar'], ['baz']])
  #
  # - Two strings:
  #
  #     req.set_form([%w[foo 0], %w[bar 1], %w[baz 2]])
  #
  # - When argument +enctype+ (see below) is given as
  #   <tt>'multipart/form-data'</tt>:
  #
  #   - A string name and an IO stream opened for reading:
  #
  #       require 'stringio'
  #       req.set_form([['file', StringIO.new('Ruby is cool.')]])
  #
  #   - A string name, an IO stream opened for reading,
  #     and an options hash, which may contain these entries:
  #
  #     - +:filename+: The name of the file to use.
  #     - +:content_type+: The content type of the uploaded file.
  #
  #     Example:
  #
  #       req.set_form([['file', file, {filename: "other-filename.foo"}]]
  #
  # The various forms may be mixed:
  #
  #   req.set_form(['foo', %w[bar 1], ['file', file]])
  #
  # <b>Argument +params+ As a Hash</b>
  #
  # When +params+ is a hash,
  # each of its entries is a name/value pair that defines a field:
  #
  # - The name is a string.
  # - The value may be:
  #
  #   - +nil+.
  #   - Another string.
  #   - An IO stream opened for reading
  #     (only when argument +enctype+ -- see below -- is given as
  #     <tt>'multipart/form-data'</tt>).
  #
  # Examples:
  #
  #   # Nil-valued fields.
  #   req.set_form({'foo' => nil, 'bar' => nil, 'baz' => nil})
  #
  #   # String-valued fields.
  #   req.set_form({'foo' => 0, 'bar' => 1, 'baz' => 2})
  #
  #   # IO-valued field.
  #   require 'stringio'
  #   req.set_form({'file' => StringIO.new('Ruby is cool.')})
  #
  #   # Mixture of fields.
  #   req.set_form({'foo' => nil, 'bar' => 1, 'file' => file})
  #
  # Optional argument +enctype+ specifies the value to be given
  # to field <tt>'Content-Type'</tt>, and must be one of:
  #
  # - <tt>'application/x-www-form-urlencoded'</tt> (the default).
  # - <tt>'multipart/form-data'</tt>;
  #   see {RFC 7578}[https://www.rfc-editor.org/rfc/rfc7578].
  #
  # Optional argument +formopt+ is a hash of options
  # (applicable only when argument +enctype+
  # is <tt>'multipart/form-data'</tt>)
  # that may include the following entries:
  #
  # - +:boundary+: The value is the boundary string for the multipart message.
  #   If not given, the boundary is a random string.
  #   See {Boundary}[https://www.rfc-editor.org/rfc/rfc7578#section-4.1].
  # - +:charset+: Value is the character set for the form submission.
  #   Field names and values of non-file fields should be encoded with this charset.
  #
  # source://net-http//lib/net/http/header.rb#924
  def set_form(params, enctype = T.unsafe(nil), formopt = T.unsafe(nil)); end

  # Sets the request body to a URL-encoded string derived from argument +params+,
  # and sets request header field <tt>'Content-Type'</tt>
  # to <tt>'application/x-www-form-urlencoded'</tt>.
  #
  # The resulting request is suitable for HTTP request +POST+ or +PUT+.
  #
  # Argument +params+ must be suitable for use as argument +enum+ to
  # {URI.encode_www_form}[https://docs.ruby-lang.org/en/master/URI.html#method-c-encode_www_form].
  #
  # With only argument +params+ given,
  # sets the body to a URL-encoded string with the default separator <tt>'&'</tt>:
  #
  #   req = Net::HTTP::Post.new('example.com')
  #
  #   req.set_form_data(q: 'ruby', lang: 'en')
  #   req.body            # => "q=ruby&lang=en"
  #   req['Content-Type'] # => "application/x-www-form-urlencoded"
  #
  #   req.set_form_data([['q', 'ruby'], ['lang', 'en']])
  #   req.body            # => "q=ruby&lang=en"
  #
  #   req.set_form_data(q: ['ruby', 'perl'], lang: 'en')
  #   req.body            # => "q=ruby&q=perl&lang=en"
  #
  #   req.set_form_data([['q', 'ruby'], ['q', 'perl'], ['lang', 'en']])
  #   req.body            # => "q=ruby&q=perl&lang=en"
  #
  # With string argument +sep+ also given,
  # uses that string as the separator:
  #
  #   req.set_form_data({q: 'ruby', lang: 'en'}, '|')
  #   req.body # => "q=ruby|lang=en"
  #
  # Net::HTTPHeader#form_data= is an alias for Net::HTTPHeader#set_form_data.
  #
  # source://net-http//lib/net/http/header.rb#812
  def set_form_data(params, sep = T.unsafe(nil)); end

  # call-seq:
  #   set_range(length) -> length
  #   set_range(offset, length) -> range
  #   set_range(begin..length) -> range
  #
  # Sets the value for field <tt>'Range'</tt>;
  # see {Range request header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#range-request-header]:
  #
  # With argument +length+:
  #
  #   req = Net::HTTP::Get.new(uri)
  #   req.set_range(100)      # => 100
  #   req['Range']            # => "bytes=0-99"
  #
  # With arguments +offset+ and +length+:
  #
  #   req.set_range(100, 100) # => 100...200
  #   req['Range']            # => "bytes=100-199"
  #
  # With argument +range+:
  #
  #   req.set_range(100..199) # => 100..199
  #   req['Range']            # => "bytes=100-199"
  #
  # Net::HTTPHeader#range= is an alias for Net::HTTPHeader#set_range.
  #
  # source://net-http//lib/net/http/header.rb#576
  def set_range(r, e = T.unsafe(nil)); end

  # source://net-http//lib/net/http/header.rb#208
  def size; end

  # Returns the trailing ('subtype') part of the
  # {media type}[https://en.wikipedia.org/wiki/Media_type]
  # from the value of field <tt>'Content-Type'</tt>,
  # or +nil+ if no such field exists;
  # see {Content-Type response header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-response-header]:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res['content-type'] # => "application/json; charset=utf-8"
  #   res.sub_type        # => "json"
  #
  # source://net-http//lib/net/http/header.rb#738
  def sub_type; end

  # Returns a hash of the key/value pairs:
  #
  #   req = Net::HTTP::Get.new(uri)
  #   req.to_hash
  #   # =>
  #   {"accept-encoding"=>["gzip;q=1.0,deflate;q=0.6,identity;q=0.3"],
  #    "accept"=>["*/*"],
  #    "user-agent"=>["Ruby"],
  #    "host"=>["jsonplaceholder.typicode.com"]}
  #
  # source://net-http//lib/net/http/header.rb#477
  def to_hash; end

  # Returns the trailing ('parameters') part of the value of field <tt>'Content-Type'</tt>,
  # or +nil+ if no such field exists;
  # see {Content-Type response header}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-response-header]:
  #
  #   res = Net::HTTP.get_response(hostname, '/todos/1')
  #   res['content-type'] # => "application/json; charset=utf-8"
  #   res.type_params     # => {"charset"=>"utf-8"}
  #
  # source://net-http//lib/net/http/header.rb#753
  def type_params; end

  private

  # source://net-http//lib/net/http/header.rb#285
  def append_field_value(ary, val); end

  # source://net-http//lib/net/http/header.rb#960
  def basic_encode(account, password); end

  # source://net-http//lib/net/http/header.rb#493
  def capitalize(name); end

  # source://net-http//lib/net/http/header.rb#270
  def set_field(key, val); end
end

# source://net-http//lib/net/http/header.rb#183
Net::HTTPHeader::MAX_FIELD_LENGTH = T.let(T.unsafe(nil), Integer)

# source://net-http//lib/net/http/header.rb#182
Net::HTTPHeader::MAX_KEY_LENGTH = T.let(T.unsafe(nil), Integer)

# source://net-http//lib/net/http/responses.rb#23
Net::HTTPInformation::EXCEPTION_TYPE = Net::HTTPError

# Response class for <tt>Loop Detected (WebDAV)</tt> responses (status code 508).
#
# The server detected an infinite loop while processing the request.
#
# :include: doc/net-http/included_getters.rdoc
#
# References:
#
# - {Mozilla}[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/508].
# - {RFC 5942}[https://www.rfc-editor.org/rfc/rfc5842.html#section-7.2].
# - {Wikipedia}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#508].
#
# source://net-http//lib/net/http/responses.rb#1061
class Net::HTTPLoopDetected < ::Net::HTTPServerError; end

# source://net-http//lib/net/http/responses.rb#1062
Net::HTTPLoopDetected::HAS_BODY = T.let(T.unsafe(nil), TrueClass)

# Response class for <tt>Misdirected Request</tt> responses (status code 421).
#
# The request was directed at a server that is not able to produce a response.
#
# :include: doc/net-http/included_getters.rdoc
#
# References:
#
# - {RFC 9110}[https://www.rfc-editor.org/rfc/rfc9110.html#name-421-misdirected-request].
# - {Wikipedia}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#421].
#
# source://net-http//lib/net/http/responses.rb#776
class Net::HTTPMisdirectedRequest < ::Net::HTTPClientError; end

# source://net-http//lib/net/http/responses.rb#777
Net::HTTPMisdirectedRequest::HAS_BODY = T.let(T.unsafe(nil), TrueClass)

# source://net-http//lib/net/http/responses.rb#378
Net::HTTPMovedTemporarily = Net::HTTPFound

# source://net-http//lib/net/http/responses.rb#343
Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

# Response class for <tt>Not Extended</tt> responses (status code 510).
#
# Further extensions to the request are required for the server to fulfill it.
#
# :include: doc/net-http/included_getters.rdoc
#
# References:
#
# - {Mozilla}[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/510].
# - {RFC 2774}[https://www.rfc-editor.org/rfc/rfc2774.html#section-7].
# - {Wikipedia}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#510].
#
# source://net-http//lib/net/http/responses.rb#1078
class Net::HTTPNotExtended < ::Net::HTTPServerError; end

# source://net-http//lib/net/http/responses.rb#1079
Net::HTTPNotExtended::HAS_BODY = T.let(T.unsafe(nil), TrueClass)

# Response class for <tt>Payload Too Large</tt> responses (status code 413).
#
# The request is larger than the server is willing or able to process.
#
# :include: doc/net-http/included_getters.rdoc
#
# References:
#
# - {Mozilla}[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413].
# - {RFC 9110}[https://www.rfc-editor.org/rfc/rfc9110.html#name-413-content-too-large].
# - {Wikipedia}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#413].
#
# source://net-http//lib/net/http/responses.rb#688
class Net::HTTPPayloadTooLarge < ::Net::HTTPClientError; end

# source://net-http//lib/net/http/responses.rb#689
Net::HTTPPayloadTooLarge::HAS_BODY = T.let(T.unsafe(nil), TrueClass)

# Response class for +Processing+ responses (status code 102).
#
# The +Processing+ response indicates that the server has received
# and is processing the request, but no response is available yet.
#
# :include: doc/net-http/included_getters.rdoc
#
# References:
#
# - {RFC 2518}[https://www.rfc-editor.org/rfc/rfc2518#section-10.1].
# - {Wikipedia}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#102].
#
# source://net-http//lib/net/http/responses.rb#129
class Net::HTTPProcessing < ::Net::HTTPInformation; end

# source://net-http//lib/net/http/responses.rb#130
Net::HTTPProcessing::HAS_BODY = T.let(T.unsafe(nil), FalseClass)

# Response class for <tt>Range Not Satisfiable</tt> responses (status code 416).
#
# The request entity has a media type which the server or resource does not support.
#
# :include: doc/net-http/included_getters.rdoc
#
# References:
#
# - {Mozilla}[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/416].
# - {RFC 9110}[https://www.rfc-editor.org/rfc/rfc9110.html#name-416-range-not-satisfiable].
# - {Wikipedia}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#416].
#
# source://net-http//lib/net/http/responses.rb#739
class Net::HTTPRangeNotSatisfiable < ::Net::HTTPClientError; end

# source://net-http//lib/net/http/responses.rb#740
Net::HTTPRangeNotSatisfiable::HAS_BODY = T.let(T.unsafe(nil), TrueClass)

# source://net-http//lib/net/http/responses.rb#53
Net::HTTPRedirection::EXCEPTION_TYPE = Net::HTTPRetriableError

# This class is the base class for \Net::HTTP request classes.
# The class should not be used directly;
# instead you should use its subclasses, listed below.
#
# == Creating a Request
#
# An request object may be created with either a URI or a string hostname:
#
#   require 'net/http'
#   uri = URI('https://jsonplaceholder.typicode.com/')
#   req = Net::HTTP::Get.new(uri)          # => #<Net::HTTP::Get GET>
#   req = Net::HTTP::Get.new(uri.hostname) # => #<Net::HTTP::Get GET>
#
# And with any of the subclasses:
#
#   req = Net::HTTP::Head.new(uri) # => #<Net::HTTP::Head HEAD>
#   req = Net::HTTP::Post.new(uri) # => #<Net::HTTP::Post POST>
#   req = Net::HTTP::Put.new(uri)  # => #<Net::HTTP::Put PUT>
#   # ...
#
# The new instance is suitable for use as the argument to Net::HTTP#request.
#
# == Request Headers
#
# A new request object has these header fields by default:
#
#   req.to_hash
#   # =>
#   {"accept-encoding"=>["gzip;q=1.0,deflate;q=0.6,identity;q=0.3"],
#   "accept"=>["*/*"],
#   "user-agent"=>["Ruby"],
#   "host"=>["jsonplaceholder.typicode.com"]}
#
# See:
#
# - {Request header Accept-Encoding}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Accept-Encoding]
#   and {Compression and Decompression}[rdoc-ref:Net::HTTP@Compression+and+Decompression].
# - {Request header Accept}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#accept-request-header].
# - {Request header User-Agent}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#user-agent-request-header].
# - {Request header Host}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#host-request-header].
#
# You can add headers or override default headers:
#
#   #   res = Net::HTTP::Get.new(uri, {'foo' => '0', 'bar' => '1'})
#
# This class (and therefore its subclasses) also includes (indirectly)
# module Net::HTTPHeader, which gives access to its
# {methods for setting headers}[rdoc-ref:Net::HTTPHeader@Setters].
#
# == Request Subclasses
#
# Subclasses for HTTP requests:
#
# - Net::HTTP::Get
# - Net::HTTP::Head
# - Net::HTTP::Post
# - Net::HTTP::Put
# - Net::HTTP::Delete
# - Net::HTTP::Options
# - Net::HTTP::Trace
# - Net::HTTP::Patch
#
# Subclasses for WebDAV requests:
#
# - Net::HTTP::Propfind
# - Net::HTTP::Proppatch
# - Net::HTTP::Mkcol
# - Net::HTTP::Copy
# - Net::HTTP::Move
# - Net::HTTP::Lock
# - Net::HTTP::Unlock
#
# source://net-http//lib/net/http/request.rb#75
class Net::HTTPRequest < ::Net::HTTPGenericRequest
  # Creates an HTTP request object for +path+.
  #
  # +initheader+ are the default headers to use.  Net::HTTP adds
  # Accept-Encoding to enable compression of the response body unless
  # Accept-Encoding or Range are supplied in +initheader+.
  #
  # @return [HTTPRequest] a new instance of HTTPRequest
  #
  # source://net-http//lib/net/http/request.rb#82
  def initialize(path, initheader = T.unsafe(nil)); end
end

# source://net-http//lib/net/http/responses.rb#709
Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

# This class is the base class for \Net::HTTP response classes.
#
# == About the Examples
#
# :include: doc/net-http/examples.rdoc
#
# == Returned Responses
#
# \Method Net::HTTP.get_response returns
# an instance of one of the subclasses of \Net::HTTPResponse:
#
#   Net::HTTP.get_response(uri)
#   # => #<Net::HTTPOK 200 OK readbody=true>
#   Net::HTTP.get_response(hostname, '/nosuch')
#   # => #<Net::HTTPNotFound 404 Not Found readbody=true>
#
# As does method Net::HTTP#request:
#
#   req = Net::HTTP::Get.new(uri)
#   Net::HTTP.start(hostname) do |http|
#     http.request(req)
#   end # => #<Net::HTTPOK 200 OK readbody=true>
#
# \Class \Net::HTTPResponse includes module Net::HTTPHeader,
# which provides access to response header values via (among others):
#
# - \Hash-like method <tt>[]</tt>.
# - Specific reader methods, such as +content_type+.
#
# Examples:
#
#   res = Net::HTTP.get_response(uri) # => #<Net::HTTPOK 200 OK readbody=true>
#   res['Content-Type']               # => "text/html; charset=UTF-8"
#   res.content_type                  # => "text/html"
#
# == Response Subclasses
#
# \Class \Net::HTTPResponse has a subclass for each
# {HTTP status code}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes].
# You can look up the response class for a given code:
#
#   Net::HTTPResponse::CODE_TO_OBJ['200'] # => Net::HTTPOK
#   Net::HTTPResponse::CODE_TO_OBJ['400'] # => Net::HTTPBadRequest
#   Net::HTTPResponse::CODE_TO_OBJ['404'] # => Net::HTTPNotFound
#
# And you can retrieve the status code for a response object:
#
#   Net::HTTP.get_response(uri).code                 # => "200"
#   Net::HTTP.get_response(hostname, '/nosuch').code # => "404"
#
# The response subclasses (indentation shows class hierarchy):
#
# - Net::HTTPUnknownResponse (for unhandled \HTTP extensions).
#
# - Net::HTTPInformation:
#
#   - Net::HTTPContinue (100)
#   - Net::HTTPSwitchProtocol (101)
#   - Net::HTTPProcessing (102)
#   - Net::HTTPEarlyHints (103)
#
# - Net::HTTPSuccess:
#
#   - Net::HTTPOK (200)
#   - Net::HTTPCreated (201)
#   - Net::HTTPAccepted (202)
#   - Net::HTTPNonAuthoritativeInformation (203)
#   - Net::HTTPNoContent (204)
#   - Net::HTTPResetContent (205)
#   - Net::HTTPPartialContent (206)
#   - Net::HTTPMultiStatus (207)
#   - Net::HTTPAlreadyReported (208)
#   - Net::HTTPIMUsed (226)
#
# - Net::HTTPRedirection:
#
#   - Net::HTTPMultipleChoices (300)
#   - Net::HTTPMovedPermanently (301)
#   - Net::HTTPFound (302)
#   - Net::HTTPSeeOther (303)
#   - Net::HTTPNotModified (304)
#   - Net::HTTPUseProxy (305)
#   - Net::HTTPTemporaryRedirect (307)
#   - Net::HTTPPermanentRedirect (308)
#
# - Net::HTTPClientError:
#
#   - Net::HTTPBadRequest (400)
#   - Net::HTTPUnauthorized (401)
#   - Net::HTTPPaymentRequired (402)
#   - Net::HTTPForbidden (403)
#   - Net::HTTPNotFound (404)
#   - Net::HTTPMethodNotAllowed (405)
#   - Net::HTTPNotAcceptable (406)
#   - Net::HTTPProxyAuthenticationRequired (407)
#   - Net::HTTPRequestTimeOut (408)
#   - Net::HTTPConflict (409)
#   - Net::HTTPGone (410)
#   - Net::HTTPLengthRequired (411)
#   - Net::HTTPPreconditionFailed (412)
#   - Net::HTTPRequestEntityTooLarge (413)
#   - Net::HTTPRequestURITooLong (414)
#   - Net::HTTPUnsupportedMediaType (415)
#   - Net::HTTPRequestedRangeNotSatisfiable (416)
#   - Net::HTTPExpectationFailed (417)
#   - Net::HTTPMisdirectedRequest (421)
#   - Net::HTTPUnprocessableEntity (422)
#   - Net::HTTPLocked (423)
#   - Net::HTTPFailedDependency (424)
#   - Net::HTTPUpgradeRequired (426)
#   - Net::HTTPPreconditionRequired (428)
#   - Net::HTTPTooManyRequests (429)
#   - Net::HTTPRequestHeaderFieldsTooLarge (431)
#   - Net::HTTPUnavailableForLegalReasons (451)
#
# - Net::HTTPServerError:
#
#   - Net::HTTPInternalServerError (500)
#   - Net::HTTPNotImplemented (501)
#   - Net::HTTPBadGateway (502)
#   - Net::HTTPServiceUnavailable (503)
#   - Net::HTTPGatewayTimeOut (504)
#   - Net::HTTPVersionNotSupported (505)
#   - Net::HTTPVariantAlsoNegotiates (506)
#   - Net::HTTPInsufficientStorage (507)
#   - Net::HTTPLoopDetected (508)
#   - Net::HTTPNotExtended (510)
#   - Net::HTTPNetworkAuthenticationRequired (511)
#
# There is also the Net::HTTPBadResponse exception which is raised when
# there is a protocol error.
#
# source://net-http//lib/net/http/response.rb#135
class Net::HTTPResponse
  include ::Net::HTTPHeader

  # @return [HTTPResponse] a new instance of HTTPResponse
  #
  # source://net-http//lib/net/http/response.rb#194
  def initialize(httpv, code, msg); end

  # Returns the string response body;
  # note that repeated calls for the unmodified body return a cached string:
  #
  #   path = '/todos/1'
  #   Net::HTTP.start(hostname) do |http|
  #     res = http.get(path)
  #     p res.body
  #     p http.head(path).body # No body.
  #   end
  #
  # Output:
  #
  #   "{\n  \"userId\": 1,\n  \"id\": 1,\n  \"title\": \"delectus aut autem\",\n  \"completed\": false\n}"
  #   nil
  #
  # source://net-http//lib/net/http/response.rb#400
  def body; end

  # Sets the body of the response to the given value.
  #
  # source://net-http//lib/net/http/response.rb#405
  def body=(value); end

  # Returns the value set by body_encoding=, or +false+ if none;
  # see #body_encoding=.
  #
  # source://net-http//lib/net/http/response.rb#229
  def body_encoding; end

  # Sets the encoding that should be used when reading the body:
  #
  # - If the given value is an Encoding object, that encoding will be used.
  # - Otherwise if the value is a string, the value of
  #   {Encoding#find(value)}[https://docs.ruby-lang.org/en/master/Encoding.html#method-c-find]
  #   will be used.
  # - Otherwise an encoding will be deduced from the body itself.
  #
  # Examples:
  #
  #   http = Net::HTTP.new(hostname)
  #   req = Net::HTTP::Get.new('/')
  #
  #   http.request(req) do |res|
  #     p res.body.encoding # => #<Encoding:ASCII-8BIT>
  #   end
  #
  #   http.request(req) do |res|
  #     res.body_encoding = "UTF-8"
  #     p res.body.encoding # => #<Encoding:UTF-8>
  #   end
  #
  # source://net-http//lib/net/http/response.rb#253
  def body_encoding=(value); end

  # The HTTP result code string. For example, '302'.  You can also
  # determine the response type by examining which response subclass
  # the response object is an instance of.
  #
  # source://net-http//lib/net/http/response.rb#213
  def code; end

  # response <-> exception relationship
  #
  # source://net-http//lib/net/http/response.rb#270
  def code_type; end

  # Set to true automatically when the request did not contain an
  # Accept-Encoding header from the user.
  #
  # source://net-http//lib/net/http/response.rb#225
  def decode_content; end

  # Set to true automatically when the request did not contain an
  # Accept-Encoding header from the user.
  #
  # source://net-http//lib/net/http/response.rb#225
  def decode_content=(_arg0); end

  # Returns the string response body;
  # note that repeated calls for the unmodified body return a cached string:
  #
  #   path = '/todos/1'
  #   Net::HTTP.start(hostname) do |http|
  #     res = http.get(path)
  #     p res.body
  #     p http.head(path).body # No body.
  #   end
  #
  # Output:
  #
  #   "{\n  \"userId\": 1,\n  \"id\": 1,\n  \"title\": \"delectus aut autem\",\n  \"completed\": false\n}"
  #   nil
  #
  # source://net-http//lib/net/http/response.rb#409
  def entity; end

  # @raise [error_type()]
  #
  # source://net-http//lib/net/http/response.rb#274
  def error!; end

  # source://net-http//lib/net/http/response.rb#280
  def error_type; end

  # source://net-http//lib/net/http/response.rb#302
  def header; end

  # The HTTP version supported by the server.
  #
  # source://net-http//lib/net/http/response.rb#208
  def http_version; end

  # Whether to ignore EOF when reading bodies with a specified Content-Length
  # header.
  #
  # source://net-http//lib/net/http/response.rb#260
  def ignore_eof; end

  # Whether to ignore EOF when reading bodies with a specified Content-Length
  # header.
  #
  # source://net-http//lib/net/http/response.rb#260
  def ignore_eof=(_arg0); end

  # source://net-http//lib/net/http/response.rb#262
  def inspect; end

  # The HTTP result message sent by the server. For example, 'Not Found'.
  #
  # source://net-http//lib/net/http/response.rb#216
  def message; end

  # The HTTP result message sent by the server. For example, 'Not Found'.
  #
  # source://net-http//lib/net/http/response.rb#217
  def msg; end

  # Gets the entity body returned by the remote HTTP server.
  #
  # If a block is given, the body is passed to the block, and
  # the body is provided in fragments, as it is read in from the socket.
  #
  # If +dest+ argument is given, response is read into that variable,
  # with <code>dest#<<</code> method (it could be String or IO, or any
  # other object responding to <code><<</code>).
  #
  # Calling this method a second or subsequent time for the same
  # HTTPResponse object will return the value already read.
  #
  #   http.request_get('/index.html') {|res|
  #     puts res.read_body
  #   }
  #
  #   http.request_get('/index.html') {|res|
  #     p res.read_body.object_id   # 538149362
  #     p res.read_body.object_id   # 538149362
  #   }
  #
  #   # using iterator
  #   http.request_get('/index.html') {|res|
  #     res.read_body do |segment|
  #       print segment
  #     end
  #   }
  #
  # source://net-http//lib/net/http/response.rb#355
  def read_body(dest = T.unsafe(nil), &block); end

  # source://net-http//lib/net/http/response.rb#307
  def read_header; end

  # body
  #
  # source://net-http//lib/net/http/response.rb#316
  def reading_body(sock, reqmethodallowbody); end

  # header (for backward compatibility only; DO NOT USE)
  #
  # source://net-http//lib/net/http/response.rb#297
  def response; end

  # The URI used to fetch this response.  The response URI is only available
  # if a URI was used to create the request.
  #
  # source://net-http//lib/net/http/response.rb#221
  def uri; end

  # source://net-http//lib/net/http/response.rb#289
  def uri=(uri); end

  # Raises an HTTP error if the response is not 2xx (success).
  #
  # source://net-http//lib/net/http/response.rb#285
  def value; end

  private

  # source://net-http//lib/net/http/response.rb#450
  def check_bom(str); end

  # source://net-http//lib/net/http/response.rb#414
  def detect_encoding(str, encoding = T.unsafe(nil)); end

  # source://net-http//lib/net/http/response.rb#540
  def extracting_encodings_from_meta_elements(value); end

  # source://net-http//lib/net/http/response.rb#505
  def get_attribute(ss); end

  # Checks for a supported Content-Encoding header and yields an Inflate
  # wrapper for this response's socket when zlib is present.  If the
  # Content-Encoding is not supported or zlib is missing, the plain socket is
  # yielded.
  #
  # If a Content-Range header is present, a plain socket is yielded as the
  # bytes in the range may not be a complete deflate block.
  #
  # source://net-http//lib/net/http/response.rb#557
  def inflater; end

  # @raise [ArgumentError]
  #
  # source://net-http//lib/net/http/response.rb#646
  def procdest(dest, block); end

  # source://net-http//lib/net/http/response.rb#592
  def read_body_0(dest); end

  # read_chunked reads from +@socket+ for chunk-size, chunk-extension, CRLF,
  # etc. and +chunk_data_io+ for chunk-data which may be deflate or gzip
  # encoded.
  #
  # See RFC 2616 section 3.6.1 for definitions
  #
  # source://net-http//lib/net/http/response.rb#622
  def read_chunked(dest, chunk_data_io); end

  # source://net-http//lib/net/http/response.rb#464
  def scanning_meta(str); end

  # source://net-http//lib/net/http/response.rb#434
  def sniff_encoding(str, encoding = T.unsafe(nil)); end

  # @raise [IOError]
  #
  # source://net-http//lib/net/http/response.rb#642
  def stream_check; end

  class << self
    # true if the response has a body.
    #
    # @return [Boolean]
    #
    # source://net-http//lib/net/http/response.rb#138
    def body_permitted?; end

    # source://net-http//lib/net/http/response.rb#142
    def exception_type; end

    # source://net-http//lib/net/http/response.rb#146
    def read_new(sock); end

    private

    # @yield [key, value]
    #
    # source://net-http//lib/net/http/response.rb#170
    def each_response_header(sock); end

    # source://net-http//lib/net/http/response.rb#157
    def read_status_line(sock); end

    # source://net-http//lib/net/http/response.rb#164
    def response_class(code); end
  end
end

# Inflater is a wrapper around Net::BufferedIO that transparently inflates
# zlib and gzip streams.
#
# source://net-http//lib/net/http/response.rb#660
class Net::HTTPResponse::Inflater
  # Creates a new Inflater wrapping +socket+
  #
  # @return [Inflater] a new instance of Inflater
  #
  # source://net-http//lib/net/http/response.rb#665
  def initialize(socket); end

  # The number of bytes inflated, used to update the Content-Length of
  # the response.
  #
  # source://net-http//lib/net/http/response.rb#683
  def bytes_inflated; end

  # Finishes the inflate stream.
  #
  # source://net-http//lib/net/http/response.rb#674
  def finish; end

  # Returns a Net::ReadAdapter that inflates each read chunk into +dest+.
  #
  # This allows a large response body to be inflated without storing the
  # entire body in memory.
  #
  # source://net-http//lib/net/http/response.rb#693
  def inflate_adapter(dest); end

  # Reads +clen+ bytes from the socket, inflates them, then writes them to
  # +dest+.  +ignore_eof+ is passed down to Net::BufferedIO#read
  #
  # Unlike Net::BufferedIO#read, this method returns more than +clen+ bytes.
  # At this time there is no way for a user of Net::HTTPResponse to read a
  # specific number of bytes from the HTTP response body, so this internal
  # API does not return the same number of bytes as were requested.
  #
  # See https://bugs.ruby-lang.org/issues/6492 for further discussion.
  #
  # source://net-http//lib/net/http/response.rb#720
  def read(clen, dest, ignore_eof = T.unsafe(nil)); end

  # Reads the rest of the socket, inflates it, then writes it to +dest+.
  #
  # source://net-http//lib/net/http/response.rb#729
  def read_all(dest); end
end

# source://net-http//lib/net/http/exceptions.rb#19
class Net::HTTPRetriableError < ::Net::ProtoRetriableError
  include ::Net::HTTPExceptions
end

# source://net-http//lib/net/http/responses.rb#81
Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

# for backward compatibility until Ruby 3.5
# https://bugs.ruby-lang.org/issues/20900
# https://github.com/bblimke/webmock/pull/1081
#
# source://net-http//lib/net/http.rb#2565
Net::HTTPSession = Net::HTTP

# source://net-http//lib/net/http/responses.rb#38
Net::HTTPSuccess::EXCEPTION_TYPE = Net::HTTPError

# Response class for <tt>URI Too Long</tt> responses (status code 414).
#
# The URI provided was too long for the server to process.
#
# :include: doc/net-http/included_getters.rdoc
#
# References:
#
# - {Mozilla}[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/414].
# - {RFC 9110}[https://www.rfc-editor.org/rfc/rfc9110.html#name-414-uri-too-long].
# - {Wikipedia}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#414].
#
# source://net-http//lib/net/http/responses.rb#705
class Net::HTTPURITooLong < ::Net::HTTPClientError; end

# source://net-http//lib/net/http/responses.rb#706
Net::HTTPURITooLong::HAS_BODY = T.let(T.unsafe(nil), TrueClass)

# source://net-http//lib/net/http/responses.rb#9
Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

# Response class for <tt>Variant Also Negotiates</tt> responses (status code 506).
#
# Transparent content negotiation for the request results in a circular reference.
#
# :include: doc/net-http/included_getters.rdoc
#
# References:
#
# - {Mozilla}[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/506].
# - {RFC 2295}[https://www.rfc-editor.org/rfc/rfc2295#section-8.1].
# - {Wikipedia}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#506].
#
# source://net-http//lib/net/http/responses.rb#1029
class Net::HTTPVariantAlsoNegotiates < ::Net::HTTPServerError; end

# source://net-http//lib/net/http/responses.rb#1030
Net::HTTPVariantAlsoNegotiates::HAS_BODY = T.let(T.unsafe(nil), TrueClass)
