# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubyzip` gem.
# Please instead update this file by running `bin/tapioca gem rubyzip`.

# source://rubyzip//lib/zip/constants.rb#1
module Zip
  extend ::Zip

  # Returns the value of attribute case_insensitive_match.
  #
  # source://rubyzip//lib/zip.rb#38
  def case_insensitive_match; end

  # Sets the attribute case_insensitive_match
  #
  # @param value the value to set the attribute case_insensitive_match to.
  #
  # source://rubyzip//lib/zip.rb#38
  def case_insensitive_match=(_arg0); end

  # Returns the value of attribute continue_on_exists_proc.
  #
  # source://rubyzip//lib/zip.rb#38
  def continue_on_exists_proc; end

  # Sets the attribute continue_on_exists_proc
  #
  # @param value the value to set the attribute continue_on_exists_proc to.
  #
  # source://rubyzip//lib/zip.rb#38
  def continue_on_exists_proc=(_arg0); end

  # Returns the value of attribute default_compression.
  #
  # source://rubyzip//lib/zip.rb#38
  def default_compression; end

  # Sets the attribute default_compression
  #
  # @param value the value to set the attribute default_compression to.
  #
  # source://rubyzip//lib/zip.rb#38
  def default_compression=(_arg0); end

  # Returns the value of attribute force_entry_names_encoding.
  #
  # source://rubyzip//lib/zip.rb#38
  def force_entry_names_encoding; end

  # Sets the attribute force_entry_names_encoding
  #
  # @param value the value to set the attribute force_entry_names_encoding to.
  #
  # source://rubyzip//lib/zip.rb#38
  def force_entry_names_encoding=(_arg0); end

  # Returns the value of attribute on_exists_proc.
  #
  # source://rubyzip//lib/zip.rb#38
  def on_exists_proc; end

  # Sets the attribute on_exists_proc
  #
  # @param value the value to set the attribute on_exists_proc to.
  #
  # source://rubyzip//lib/zip.rb#38
  def on_exists_proc=(_arg0); end

  # source://rubyzip//lib/zip.rb#49
  def reset!; end

  # @yield [_self]
  # @yieldparam _self [Zip] the object that the method was called on
  #
  # source://rubyzip//lib/zip.rb#62
  def setup; end

  # Returns the value of attribute sort_entries.
  #
  # source://rubyzip//lib/zip.rb#38
  def sort_entries; end

  # Sets the attribute sort_entries
  #
  # @param value the value to set the attribute sort_entries to.
  #
  # source://rubyzip//lib/zip.rb#38
  def sort_entries=(_arg0); end

  # Returns the value of attribute unicode_names.
  #
  # source://rubyzip//lib/zip.rb#38
  def unicode_names; end

  # Sets the attribute unicode_names
  #
  # @param value the value to set the attribute unicode_names to.
  #
  # source://rubyzip//lib/zip.rb#38
  def unicode_names=(_arg0); end

  # Returns the value of attribute validate_entry_sizes.
  #
  # source://rubyzip//lib/zip.rb#38
  def validate_entry_sizes; end

  # Sets the attribute validate_entry_sizes
  #
  # @param value the value to set the attribute validate_entry_sizes to.
  #
  # source://rubyzip//lib/zip.rb#38
  def validate_entry_sizes=(_arg0); end

  # Returns the value of attribute warn_invalid_date.
  #
  # source://rubyzip//lib/zip.rb#38
  def warn_invalid_date; end

  # Sets the attribute warn_invalid_date
  #
  # @param value the value to set the attribute warn_invalid_date to.
  #
  # source://rubyzip//lib/zip.rb#38
  def warn_invalid_date=(_arg0); end

  # Returns the value of attribute write_zip64_support.
  #
  # source://rubyzip//lib/zip.rb#38
  def write_zip64_support; end

  # Sets the attribute write_zip64_support
  #
  # @param value the value to set the attribute write_zip64_support to.
  #
  # source://rubyzip//lib/zip.rb#38
  def write_zip64_support=(_arg0); end
end

# source://rubyzip//lib/zip/constants.rb#5
Zip::CDIR_ENTRY_STATIC_HEADER_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#4
Zip::CENTRAL_DIRECTORY_ENTRY_SIGNATURE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#89
Zip::COMPRESSION_METHODS = T.let(T.unsafe(nil), Hash)

# source://rubyzip//lib/zip/constants.rb#87
Zip::COMPRESSION_METHOD_AES = T.let(T.unsafe(nil), Integer)

# RESERVED = 11
#
# source://rubyzip//lib/zip/constants.rb#76
Zip::COMPRESSION_METHOD_BZIP2 = T.let(T.unsafe(nil), Integer)

# RESERVED = 7
#
# source://rubyzip//lib/zip/constants.rb#72
Zip::COMPRESSION_METHOD_DEFLATE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#73
Zip::COMPRESSION_METHOD_DEFLATE_64 = T.let(T.unsafe(nil), Integer)

# RESERVED = 15
#
# source://rubyzip//lib/zip/constants.rb#80
Zip::COMPRESSION_METHOD_IBM_CMPSC = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#83
Zip::COMPRESSION_METHOD_IBM_LZ77 = T.let(T.unsafe(nil), Integer)

# RESERVED = 17
#
# source://rubyzip//lib/zip/constants.rb#82
Zip::COMPRESSION_METHOD_IBM_TERSE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#70
Zip::COMPRESSION_METHOD_IMPLODE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#84
Zip::COMPRESSION_METHOD_JPEG = T.let(T.unsafe(nil), Integer)

# RESERVED = 13
#
# source://rubyzip//lib/zip/constants.rb#78
Zip::COMPRESSION_METHOD_LZMA = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#74
Zip::COMPRESSION_METHOD_PKWARE_DCLI = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#86
Zip::COMPRESSION_METHOD_PPMD = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#66
Zip::COMPRESSION_METHOD_REDUCE_1 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#67
Zip::COMPRESSION_METHOD_REDUCE_2 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#68
Zip::COMPRESSION_METHOD_REDUCE_3 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#69
Zip::COMPRESSION_METHOD_REDUCE_4 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#65
Zip::COMPRESSION_METHOD_SHRINK = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#64
Zip::COMPRESSION_METHOD_STORE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#85
Zip::COMPRESSION_METHOD_WAVPACK = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#2
class Zip::CentralDirectory
  include ::Enumerable

  # @return [CentralDirectory] a new instance of CentralDirectory
  #
  # source://rubyzip//lib/zip/central_directory.rb#18
  def initialize(entries = T.unsafe(nil), comment = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/central_directory.rb#202
  def ==(other); end

  # Returns the value of attribute comment.
  #
  # source://rubyzip//lib/zip/central_directory.rb#11
  def comment; end

  # For iterating over the entries.
  #
  # source://rubyzip//lib/zip/central_directory.rb#184
  def each(&a_proc); end

  # Returns an Enumerable containing the entries.
  #
  # source://rubyzip//lib/zip/central_directory.rb#14
  def entries; end

  # @raise [Error]
  #
  # source://rubyzip//lib/zip/central_directory.rb#167
  def get_64_e_o_c_d(buf); end

  # @raise [Error]
  #
  # source://rubyzip//lib/zip/central_directory.rb#141
  def get_e_o_c_d(buf); end

  # @raise [Error]
  #
  # source://rubyzip//lib/zip/central_directory.rb#87
  def read_64_e_o_c_d(buf); end

  # source://rubyzip//lib/zip/central_directory.rb#119
  def read_central_directory_entries(io); end

  # @raise [Error]
  #
  # source://rubyzip//lib/zip/central_directory.rb#102
  def read_e_o_c_d(buf); end

  # source://rubyzip//lib/zip/central_directory.rb#131
  def read_from_stream(io); end

  # Returns the number of entries in the central directory (and
  # consequently in the zip archive).
  #
  # source://rubyzip//lib/zip/central_directory.rb#190
  def size; end

  # source://rubyzip//lib/zip/central_directory.rb#158
  def start_buf(io); end

  # source://rubyzip//lib/zip/central_directory.rb#24
  def write_to_stream(io); end

  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/central_directory.rb#154
  def zip64_file?(buf); end

  private

  # source://rubyzip//lib/zip/central_directory.rb#57
  def write_64_e_o_c_d(io, offset, cdir_size); end

  # source://rubyzip//lib/zip/central_directory.rb#75
  def write_64_eocd_locator(io, zip64_eocd_offset); end

  # source://rubyzip//lib/zip/central_directory.rb#40
  def write_e_o_c_d(io, offset, cdir_size); end

  class << self
    # source://rubyzip//lib/zip/central_directory.rb#194
    def read_from_stream(io); end
  end
end

# source://rubyzip//lib/zip/central_directory.rb#5
Zip::CentralDirectory::END_OF_CDS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#8
Zip::CentralDirectory::MAX_END_OF_CDS_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#9
Zip::CentralDirectory::STATIC_EOCD_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#6
Zip::CentralDirectory::ZIP64_END_OF_CDS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/central_directory.rb#7
Zip::CentralDirectory::ZIP64_EOCD_LOCATOR = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/errors.rb#5
class Zip::CompressionMethodError < ::Zip::Error; end

# source://rubyzip//lib/zip/compressor.rb#2
class Zip::Compressor
  # source://rubyzip//lib/zip/compressor.rb#3
  def finish; end
end

# source://rubyzip//lib/zip/dos_time.rb#3
class Zip::DOSTime < ::Time
  # Dos time is only stored with two seconds accuracy
  #
  # source://rubyzip//lib/zip/dos_time.rb#28
  def dos_equals(other); end

  # source://rubyzip//lib/zip/dos_time.rb#21
  def to_binary_dos_date; end

  # Register DX, the Date:
  # Bits 0-4 day (1-31)
  # bits 5-8 month (1-12)
  # bits 9-15 year (four digit year minus 1980)
  #
  # source://rubyzip//lib/zip/dos_time.rb#15
  def to_binary_dos_time; end

  class << self
    # Create a DOSTime instance from a vanilla Time instance.
    #
    # source://rubyzip//lib/zip/dos_time.rb#33
    def from_time(time); end

    # source://rubyzip//lib/zip/dos_time.rb#37
    def parse_binary_dos_format(bin_dos_date, bin_dos_time); end
  end
end

# source://rubyzip//lib/zip/errors.rb#10
class Zip::DecompressionError < ::Zip::Error; end

# source://rubyzip//lib/zip/decompressor.rb#2
class Zip::Decompressor
  # @return [Decompressor] a new instance of Decompressor
  #
  # source://rubyzip//lib/zip/decompressor.rb#20
  def initialize(input_stream, decompressed_size = T.unsafe(nil)); end

  # Returns the value of attribute decompressed_size.
  #
  # source://rubyzip//lib/zip/decompressor.rb#18
  def decompressed_size; end

  # Returns the value of attribute input_stream.
  #
  # source://rubyzip//lib/zip/decompressor.rb#17
  def input_stream; end

  class << self
    # source://rubyzip//lib/zip/decompressor.rb#5
    def decompressor_classes; end

    # source://rubyzip//lib/zip/decompressor.rb#13
    def find_by_compression_method(compression_method); end

    # source://rubyzip//lib/zip/decompressor.rb#9
    def register(compression_method, decompressor_class); end
  end
end

# source://rubyzip//lib/zip/decompressor.rb#3
Zip::Decompressor::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/crypto/decrypted_io.rb#2
class Zip::DecryptedIo
  # @return [DecryptedIo] a new instance of DecryptedIo
  #
  # source://rubyzip//lib/zip/crypto/decrypted_io.rb#5
  def initialize(io, decrypter); end

  # source://rubyzip//lib/zip/crypto/decrypted_io.rb#10
  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  private

  # source://rubyzip//lib/zip/crypto/decrypted_io.rb#28
  def buffer; end

  # source://rubyzip//lib/zip/crypto/decrypted_io.rb#24
  def eof; end

  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/crypto/decrypted_io.rb#32
  def input_finished?; end

  # source://rubyzip//lib/zip/crypto/decrypted_io.rb#36
  def produce_input; end
end

# source://rubyzip//lib/zip/crypto/decrypted_io.rb#3
Zip::DecryptedIo::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/crypto/encryption.rb#5
class Zip::Decrypter; end

# source://rubyzip//lib/zip/deflater.rb#2
class Zip::Deflater < ::Zip::Compressor
  # @return [Deflater] a new instance of Deflater
  #
  # source://rubyzip//lib/zip/deflater.rb#3
  def initialize(output_stream, level = T.unsafe(nil), encrypter = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/deflater.rb#12
  def <<(data); end

  # Returns the value of attribute crc.
  #
  # source://rubyzip//lib/zip/deflater.rb#28
  def crc; end

  # source://rubyzip//lib/zip/deflater.rb#24
  def finish; end

  # Returns the value of attribute size.
  #
  # source://rubyzip//lib/zip/deflater.rb#28
  def size; end
end

# source://rubyzip//lib/zip/errors.rb#4
class Zip::DestinationFileExistsError < ::Zip::Error; end

# source://rubyzip//lib/zip/crypto/encryption.rb#2
class Zip::Encrypter; end

# source://rubyzip//lib/zip/entry.rb#3
class Zip::Entry
  # @return [Entry] a new instance of Entry
  #
  # source://rubyzip//lib/zip/entry.rb#55
  def initialize(*args); end

  # source://rubyzip//lib/zip/entry.rb#512
  def <=>(other); end

  # source://rubyzip//lib/zip/entry.rb#502
  def ==(other); end

  # source://rubyzip//lib/zip/entry.rb#151
  def calculate_local_header_size; end

  # source://rubyzip//lib/zip/entry.rb#164
  def cdir_header_size; end

  # @raise [::Zip::Error]
  #
  # source://rubyzip//lib/zip/entry.rb#376
  def check_c_dir_entry_comment_size; end

  # @raise [Error]
  #
  # source://rubyzip//lib/zip/entry.rb#370
  def check_c_dir_entry_signature; end

  # @raise [Error]
  #
  # source://rubyzip//lib/zip/entry.rb#364
  def check_c_dir_entry_static_header_length(buf); end

  # @raise [::Zip::EntryNameError]
  #
  # source://rubyzip//lib/zip/entry.rb#49
  def check_name(name); end

  # source://rubyzip//lib/zip/entry.rb#603
  def clean_up; end

  # Returns the value of attribute comment.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def comment; end

  # Sets the attribute comment
  #
  # @param value the value to set the attribute comment to.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def comment=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#147
  def comment_size; end

  # Returns the value of attribute compressed_size.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def compressed_size; end

  # Sets the attribute compressed_size
  #
  # @param value the value to set the attribute compressed_size to.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def compressed_size=(_arg0); end

  # Returns the value of attribute compression_method.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def compression_method; end

  # Sets the attribute compression_method
  #
  # @param value the value to set the attribute compression_method to.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def compression_method=(_arg0); end

  # Returns the value of attribute crc.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def crc; end

  # Sets the attribute crc
  #
  # @param value the value to set the attribute crc to.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def crc=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#114
  def directory?; end

  # Returns the value of attribute dirty.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def dirty; end

  # Sets the attribute dirty
  #
  # @param value the value to set the attribute dirty to.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def dirty=(_arg0); end

  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/entry.rb#76
  def encrypted?; end

  # Returns the value of attribute external_file_attributes.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def external_file_attributes; end

  # Sets the attribute external_file_attributes
  #
  # @param value the value to set the attribute external_file_attributes to.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def external_file_attributes=(_arg0); end

  # Returns the value of attribute extra.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def extra; end

  # Sets the attribute extra
  #
  # @param value the value to set the attribute extra to.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def extra=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#143
  def extra_size; end

  # Extracts entry to file dest_path (defaults to @name).
  # NB: The caller is responsible for making sure dest_path is safe, if it
  # is passed.
  #
  # source://rubyzip//lib/zip/entry.rb#176
  def extract(dest_path = T.unsafe(nil), &block); end

  # source://rubyzip//lib/zip/entry.rb#114
  def file?; end

  # source://rubyzip//lib/zip/entry.rb#407
  def file_stat(path); end

  # @raise [InternalError]
  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/entry.rb#106
  def file_type_is?(type); end

  # source://rubyzip//lib/zip/entry.rb#16
  def filepath; end

  # Returns the value of attribute follow_symlinks.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def follow_symlinks; end

  # Sets the attribute follow_symlinks
  #
  # @param value the value to set the attribute follow_symlinks to.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def follow_symlinks=(_arg0); end

  # Returns the value of attribute fstype.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def fstype; end

  # Sets the attribute fstype
  #
  # @param value the value to set the attribute fstype to.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def fstype=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#16
  def ftype; end

  # source://rubyzip//lib/zip/entry.rb#550
  def gather_fileinfo_from_srcpath(src_path); end

  # source://rubyzip//lib/zip/entry.rb#415
  def get_extra_attributes_from_path(path); end

  # Returns an IO like object for the given ZipEntry.
  # Warning: may behave weird with symlinks.
  #
  # source://rubyzip//lib/zip/entry.rb#518
  def get_input_stream(&block); end

  # source://rubyzip//lib/zip/entry.rb#595
  def get_raw_input_stream(&block); end

  # Returns the value of attribute gp_flags.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def gp_flags; end

  # Sets the attribute gp_flags
  #
  # @param value the value to set the attribute gp_flags to.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def gp_flags=(_arg0); end

  # Returns the value of attribute header_signature.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def header_signature; end

  # Sets the attribute header_signature
  #
  # @param value the value to set the attribute header_signature to.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def header_signature=(_arg0); end

  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/entry.rb#80
  def incomplete?; end

  # Returns the value of attribute internal_file_attributes.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def internal_file_attributes; end

  # Sets the attribute internal_file_attributes
  #
  # @param value the value to set the attribute internal_file_attributes to.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def internal_file_attributes=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#135
  def local_entry_offset; end

  # Returns the value of attribute local_header_offset.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def local_header_offset; end

  # Sets the attribute local_header_offset
  #
  # @param value the value to set the attribute local_header_offset to.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def local_header_offset=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#84
  def mtime; end

  # Returns the value of attribute name.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def name=(_arg0); end

  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/entry.rb#119
  def name_is_directory?; end

  # Is the name a relative path, free of `..` patterns that could lead to
  # path traversal attacks? This does NOT handle symlinks; if the path
  # contains symlinks, this check is NOT enough to guarantee safety.
  #
  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/entry.rb#126
  def name_safe?; end

  # source://rubyzip//lib/zip/entry.rb#139
  def name_size; end

  # source://rubyzip//lib/zip/entry.rb#169
  def next_header_offset; end

  # source://rubyzip//lib/zip/entry.rb#447
  def pack_c_dir_entry; end

  # source://rubyzip//lib/zip/entry.rb#284
  def pack_local_entry; end

  # source://rubyzip//lib/zip/entry.rb#589
  def parent_as_string; end

  # source://rubyzip//lib/zip/entry.rb#390
  def read_c_dir_entry(io); end

  # source://rubyzip//lib/zip/entry.rb#382
  def read_c_dir_extra_field(io); end

  # source://rubyzip//lib/zip/entry.rb#245
  def read_local_entry(io); end

  # Returns the value of attribute restore_ownership.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def restore_ownership; end

  # Sets the attribute restore_ownership
  #
  # @param value the value to set the attribute restore_ownership to.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def restore_ownership=(_arg0); end

  # Returns the value of attribute restore_permissions.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def restore_permissions; end

  # Sets the attribute restore_permissions
  #
  # @param value the value to set the attribute restore_permissions to.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def restore_permissions=(_arg0); end

  # Returns the value of attribute restore_times.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def restore_times; end

  # Sets the attribute restore_times
  #
  # @param value the value to set the attribute restore_times to.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def restore_times=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#18
  def set_default_vars_values; end

  # source://rubyzip//lib/zip/entry.rb#438
  def set_extra_attributes_on_path(dest_path); end

  # source://rubyzip//lib/zip/entry.rb#335
  def set_ftype_from_c_dir_entry; end

  # source://rubyzip//lib/zip/entry.rb#425
  def set_unix_attributes_on_path(dest_path); end

  # Returns the value of attribute size.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def size; end

  # Sets the attribute size
  #
  # @param value the value to set the attribute size to.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def size=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#114
  def symlink?; end

  # source://rubyzip//lib/zip/entry.rb#84
  def time; end

  # source://rubyzip//lib/zip/entry.rb#98
  def time=(value); end

  # source://rubyzip//lib/zip/entry.rb#191
  def to_s; end

  # Returns the value of attribute unix_gid.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def unix_gid; end

  # Sets the attribute unix_gid
  #
  # @param value the value to set the attribute unix_gid to.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def unix_gid=(_arg0); end

  # Returns the value of attribute unix_perms.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def unix_perms; end

  # Sets the attribute unix_perms
  #
  # @param value the value to set the attribute unix_perms to.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def unix_perms=(_arg0); end

  # Returns the value of attribute unix_uid.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def unix_uid; end

  # Sets the attribute unix_uid
  #
  # @param value the value to set the attribute unix_uid to.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def unix_uid=(_arg0); end

  # source://rubyzip//lib/zip/entry.rb#311
  def unpack_c_dir_entry(buf); end

  # source://rubyzip//lib/zip/entry.rb#230
  def unpack_local_entry(buf); end

  # check before rewriting an entry (after file sizes are known)
  # that we didn't change the header size (and thus clobber file data or something)
  #
  # @raise [Error]
  #
  # source://rubyzip//lib/zip/entry.rb#157
  def verify_local_header_size!; end

  # source://rubyzip//lib/zip/entry.rb#474
  def write_c_dir_entry(io); end

  # source://rubyzip//lib/zip/entry.rb#299
  def write_local_entry(io, rewrite = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/entry.rb#578
  def write_to_zip_output_stream(zip_output_stream); end

  # Returns the value of attribute zipfile.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def zipfile; end

  # Sets the attribute zipfile
  #
  # @param value the value to set the attribute zipfile to.
  #
  # source://rubyzip//lib/zip/entry.rb#9
  def zipfile=(_arg0); end

  private

  # source://rubyzip//lib/zip/entry.rb#642
  def create_directory(dest_path); end

  # source://rubyzip//lib/zip/entry.rb#615
  def create_file(dest_path, _continue_on_exists_proc = T.unsafe(nil)); end

  # BUG: create_symlink() does not use &block
  #
  # source://rubyzip//lib/zip/entry.rb#659
  def create_symlink(dest_path); end

  # source://rubyzip//lib/zip/entry.rb#677
  def data_descriptor_size; end

  # apply missing data from the zip64 extra information field, if present
  # (required when file sizes exceed 2**32, but can be used for all files)
  #
  # source://rubyzip//lib/zip/entry.rb#667
  def parse_zip64_extra(for_local_header); end

  # create a zip64 extra information field if we need one
  #
  # source://rubyzip//lib/zip/entry.rb#682
  def prep_zip64_extra(for_local_header); end

  # source://rubyzip//lib/zip/entry.rb#609
  def set_time(binary_dos_date, binary_dos_time); end

  class << self
    # source://rubyzip//lib/zip/entry.rb#208
    def read_c_dir_entry(io); end

    # source://rubyzip//lib/zip/entry.rb#221
    def read_local_entry(io); end

    # source://rubyzip//lib/zip/entry.rb#204
    def read_zip_64_long(io); end

    # source://rubyzip//lib/zip/entry.rb#200
    def read_zip_long(io); end

    # source://rubyzip//lib/zip/entry.rb#196
    def read_zip_short(io); end
  end
end

# source://rubyzip//lib/zip/entry.rb#5
Zip::Entry::DEFLATED = T.let(T.unsafe(nil), Integer)

# Language encoding flag (EFS) bit
#
# source://rubyzip//lib/zip/entry.rb#7
Zip::Entry::EFS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/entry.rb#4
Zip::Entry::STORED = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/errors.rb#3
class Zip::EntryExistsError < ::Zip::Error; end

# source://rubyzip//lib/zip/errors.rb#6
class Zip::EntryNameError < ::Zip::Error; end

# source://rubyzip//lib/zip/entry_set.rb#2
class Zip::EntrySet
  include ::Enumerable

  # @return [EntrySet] a new instance of EntrySet
  #
  # source://rubyzip//lib/zip/entry_set.rb#6
  def initialize(an_enumerable = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/entry_set.rb#20
  def <<(entry); end

  # source://rubyzip//lib/zip/entry_set.rb#51
  def ==(other); end

  # source://rubyzip//lib/zip/entry_set.rb#32
  def delete(entry); end

  # deep clone
  #
  # source://rubyzip//lib/zip/entry_set.rb#47
  def dup; end

  # source://rubyzip//lib/zip/entry_set.rb#36
  def each; end

  # source://rubyzip//lib/zip/entry_set.rb#42
  def entries; end

  # Returns the value of attribute entry_order.
  #
  # source://rubyzip//lib/zip/entry_set.rb#4
  def entry_order; end

  # Sets the attribute entry_order
  #
  # @param value the value to set the attribute entry_order to.
  #
  # source://rubyzip//lib/zip/entry_set.rb#4
  def entry_order=(_arg0); end

  # Returns the value of attribute entry_set.
  #
  # source://rubyzip//lib/zip/entry_set.rb#4
  def entry_set; end

  # Sets the attribute entry_set
  #
  # @param value the value to set the attribute entry_set to.
  #
  # source://rubyzip//lib/zip/entry_set.rb#4
  def entry_set=(_arg0); end

  # source://rubyzip//lib/zip/entry_set.rb#16
  def find_entry(entry); end

  # source://rubyzip//lib/zip/entry_set.rb#61
  def glob(pattern, flags = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/entry_set.rb#12
  def include?(entry); end

  # source://rubyzip//lib/zip/entry_set.rb#26
  def length; end

  # source://rubyzip//lib/zip/entry_set.rb#57
  def parent(entry); end

  # source://rubyzip//lib/zip/entry_set.rb#20
  def push(entry); end

  # source://rubyzip//lib/zip/entry_set.rb#26
  def size; end

  protected

  # source://rubyzip//lib/zip/entry_set.rb#72
  def sorted_entries; end

  private

  # source://rubyzip//lib/zip/entry_set.rb#78
  def to_key(entry); end
end

# source://rubyzip//lib/zip/errors.rb#7
class Zip::EntrySizeError < ::Zip::Error; end

# source://rubyzip//lib/zip/errors.rb#2
class Zip::Error < ::StandardError; end

# source://rubyzip//lib/zip/extra_field.rb#2
class Zip::ExtraField < ::Hash
  # @return [ExtraField] a new instance of ExtraField
  #
  # source://rubyzip//lib/zip/extra_field.rb#5
  def initialize(binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field.rb#80
  def c_dir_size; end

  # source://rubyzip//lib/zip/extra_field.rb#54
  def create(name); end

  # source://rubyzip//lib/zip/extra_field.rb#28
  def create_unknown_item; end

  # source://rubyzip//lib/zip/extra_field.rb#9
  def extra_field_type_exist(binstr, id, len, index); end

  # source://rubyzip//lib/zip/extra_field.rb#19
  def extra_field_type_unknown(binstr, len, index); end

  # source://rubyzip//lib/zip/extra_field.rb#84
  def length; end

  # source://rubyzip//lib/zip/extra_field.rb#84
  def local_size; end

  # source://rubyzip//lib/zip/extra_field.rb#37
  def merge(binstr); end

  # place Unknown last, so "extra" data that is missing the proper signature/size
  # does not prevent known fields from being read back in
  #
  # source://rubyzip//lib/zip/extra_field.rb#64
  def ordered_values; end

  # source://rubyzip//lib/zip/extra_field.rb#84
  def size; end

  # source://rubyzip//lib/zip/extra_field.rb#76
  def to_c_dir_bin; end

  # source://rubyzip//lib/zip/extra_field.rb#70
  def to_local_bin; end

  # source://rubyzip//lib/zip/extra_field.rb#70
  def to_s; end
end

# source://rubyzip//lib/zip/extra_field/generic.rb#2
class Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/generic.rb#25
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/generic.rb#14
  def initial_parse(binstr); end

  # source://rubyzip//lib/zip/extra_field/generic.rb#39
  def to_c_dir_bin; end

  # source://rubyzip//lib/zip/extra_field/generic.rb#34
  def to_local_bin; end

  class << self
    # source://rubyzip//lib/zip/extra_field/generic.rb#9
    def name; end

    # source://rubyzip//lib/zip/extra_field/generic.rb#3
    def register_map; end
  end
end

# source://rubyzip//lib/zip/extra_field.rb#3
Zip::ExtraField::ID_MAP = T.let(T.unsafe(nil), Hash)

# source://rubyzip//lib/zip/extra_field/unix.rb#3
class Zip::ExtraField::IUnix < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/unix.rb#7
  def initialize(binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/unix.rb#27
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/unix.rb#13
  def gid; end

  # source://rubyzip//lib/zip/extra_field/unix.rb#13
  def gid=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/unix.rb#15
  def merge(binstr); end

  # source://rubyzip//lib/zip/extra_field/unix.rb#35
  def pack_for_c_dir; end

  # source://rubyzip//lib/zip/extra_field/unix.rb#31
  def pack_for_local; end

  # source://rubyzip//lib/zip/extra_field/unix.rb#13
  def uid; end

  # source://rubyzip//lib/zip/extra_field/unix.rb#13
  def uid=(_arg0); end
end

# source://rubyzip//lib/zip/extra_field/unix.rb#4
Zip::ExtraField::IUnix::HEADER_ID = T.let(T.unsafe(nil), String)

# source://rubyzip//lib/zip/extra_field/ntfs.rb#4
class Zip::ExtraField::NTFS < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/ntfs.rb#11
  def initialize(binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#38
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#18
  def atime; end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#18
  def atime=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#18
  def ctime; end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#18
  def ctime=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#20
  def merge(binstr); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#18
  def mtime; end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#18
  def mtime=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#50
  def pack_for_c_dir; end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#45
  def pack_for_local; end

  private

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#86
  def from_ntfs_time(ntfs_time); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#68
  def parse_tags(content); end

  # source://rubyzip//lib/zip/extra_field/ntfs.rb#90
  def to_ntfs_time(time); end
end

# source://rubyzip//lib/zip/extra_field/ntfs.rb#5
Zip::ExtraField::NTFS::HEADER_ID = T.let(T.unsafe(nil), String)

# source://rubyzip//lib/zip/extra_field/ntfs.rb#9
Zip::ExtraField::NTFS::SEC_TO_UNIX_EPOCH = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/extra_field/ntfs.rb#8
Zip::ExtraField::NTFS::WINDOWS_TICK = T.let(T.unsafe(nil), Float)

# source://rubyzip//lib/zip/extra_field/old_unix.rb#3
class Zip::ExtraField::OldUnix < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/old_unix.rb#7
  def initialize(binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#31
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#15
  def atime; end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#15
  def atime=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#15
  def gid; end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#15
  def gid=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#17
  def merge(binstr); end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#15
  def mtime; end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#15
  def mtime=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#42
  def pack_for_c_dir; end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#38
  def pack_for_local; end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#15
  def uid; end

  # source://rubyzip//lib/zip/extra_field/old_unix.rb#15
  def uid=(_arg0); end
end

# source://rubyzip//lib/zip/extra_field/old_unix.rb#4
Zip::ExtraField::OldUnix::HEADER_ID = T.let(T.unsafe(nil), String)

# source://rubyzip//lib/zip/extra_field/universal_time.rb#3
class Zip::ExtraField::UniversalTime < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/universal_time.rb#11
  def initialize(binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#57
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#20
  def atime; end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#22
  def atime=(time); end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#20
  def ctime; end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#27
  def ctime=(time); end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#20
  def flag; end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#37
  def merge(binstr); end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#20
  def mtime; end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#32
  def mtime=(time); end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#71
  def pack_for_c_dir; end

  # source://rubyzip//lib/zip/extra_field/universal_time.rb#63
  def pack_for_local; end
end

# source://rubyzip//lib/zip/extra_field/universal_time.rb#7
Zip::ExtraField::UniversalTime::ATIME_MASK = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/extra_field/universal_time.rb#8
Zip::ExtraField::UniversalTime::CTIME_MASK = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/extra_field/universal_time.rb#4
Zip::ExtraField::UniversalTime::HEADER_ID = T.let(T.unsafe(nil), String)

# source://rubyzip//lib/zip/extra_field/universal_time.rb#9
Zip::ExtraField::UniversalTime::MTIME_MASK = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/extra_field/zip64.rb#3
class Zip::ExtraField::Zip64 < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/zip64.rb#8
  def initialize(binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#20
  def ==(other); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#4
  def compressed_size; end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#4
  def compressed_size=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#4
  def disk_start_number; end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#4
  def disk_start_number=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#27
  def merge(binstr); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#4
  def original_size; end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#4
  def original_size=(_arg0); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#60
  def pack_for_c_dir; end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#53
  def pack_for_local; end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#36
  def parse(original_size, compressed_size, relative_header_offset = T.unsafe(nil), disk_start_number = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#4
  def relative_header_offset; end

  # source://rubyzip//lib/zip/extra_field/zip64.rb#4
  def relative_header_offset=(_arg0); end

  private

  # source://rubyzip//lib/zip/extra_field/zip64.rb#48
  def extract(size, format); end
end

# source://rubyzip//lib/zip/extra_field/zip64.rb#5
Zip::ExtraField::Zip64::HEADER_ID = T.let(T.unsafe(nil), String)

# source://rubyzip//lib/zip/extra_field/zip64_placeholder.rb#5
class Zip::ExtraField::Zip64Placeholder < ::Zip::ExtraField::Generic
  # source://rubyzip//lib/zip/extra_field/zip64_placeholder.rb#9
  def initialize(_binstr = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/extra_field/zip64_placeholder.rb#11
  def pack_for_local; end
end

# source://rubyzip//lib/zip/extra_field/zip64_placeholder.rb#6
Zip::ExtraField::Zip64Placeholder::HEADER_ID = T.let(T.unsafe(nil), String)

# source://rubyzip//lib/zip/constants.rb#15
Zip::FILE_TYPE_DIR = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#14
Zip::FILE_TYPE_FILE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#16
Zip::FILE_TYPE_SYMLINK = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#40
Zip::FSTYPES = T.let(T.unsafe(nil), Hash)

# source://rubyzip//lib/zip/constants.rb#31
Zip::FSTYPE_ACORN = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#19
Zip::FSTYPE_AMIGA = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#23
Zip::FSTYPE_ATARI = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#38
Zip::FSTYPE_ATHEOS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#34
Zip::FSTYPE_BEOS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#27
Zip::FSTYPE_CPM = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#18
Zip::FSTYPE_FAT = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#24
Zip::FSTYPE_HPFS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#25
Zip::FSTYPE_MAC = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#37
Zip::FSTYPE_MAC_OSX = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#33
Zip::FSTYPE_MVS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#29
Zip::FSTYPE_NTFS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#30
Zip::FSTYPE_QDOS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#35
Zip::FSTYPE_TANDEM = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#36
Zip::FSTYPE_THEOS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#28
Zip::FSTYPE_TOPS20 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#21
Zip::FSTYPE_UNIX = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#32
Zip::FSTYPE_VFAT = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#20
Zip::FSTYPE_VMS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#22
Zip::FSTYPE_VM_CMS = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#26
Zip::FSTYPE_Z_SYSTEM = T.let(T.unsafe(nil), Integer)

# ZipFile is modeled after java.util.zip.ZipFile from the Java SDK.
# The most important methods are those inherited from
# ZipCentralDirectory for accessing information about the entries in
# the archive and methods such as get_input_stream and
# get_output_stream for reading from and writing entries to the
# archive. The class includes a few convenience methods such as
# #extract for extracting entries to the filesystem, and #remove,
# #replace, #rename and #mkdir for making simple modifications to
# the archive.
#
# Modifications to a zip archive are not committed until #commit or
# #close is called. The method #open accepts a block following
# the pattern from File.open offering a simple way to
# automatically close the archive when the block returns.
#
# The following example opens zip archive <code>my.zip</code>
# (creating it if it doesn't exist) and adds an entry
# <code>first.txt</code> and a directory entry <code>a_dir</code>
# to it.
#
#   require 'zip'
#
#   Zip::File.open("my.zip", Zip::File::CREATE) {
#    |zipfile|
#     zipfile.get_output_stream("first.txt") { |f| f.puts "Hello from ZipFile" }
#     zipfile.mkdir("a_dir")
#   }
#
# The next example reopens <code>my.zip</code> writes the contents of
# <code>first.txt</code> to standard out and deletes the entry from
# the archive.
#
#   require 'zip'
#
#   Zip::File.open("my.zip", Zip::File::CREATE) {
#     |zipfile|
#     puts zipfile.read("first.txt")
#     zipfile.remove("first.txt")
#   }
#
# ZipFileSystem offers an alternative API that emulates ruby's
# interface for accessing the filesystem, ie. the File and Dir classes.
#
# source://rubyzip//lib/zip/file.rb#45
class Zip::File < ::Zip::CentralDirectory
  # Opens a zip archive. Pass true as the second parameter to create
  # a new archive if it doesn't exist already.
  #
  # @return [File] a new instance of File
  #
  # source://rubyzip//lib/zip/file.rb#76
  def initialize(path_or_io, create = T.unsafe(nil), buffer = T.unsafe(nil), options = T.unsafe(nil)); end

  # Convenience method for adding the contents of a file to the archive
  #
  # source://rubyzip//lib/zip/file.rb#299
  def add(entry, src_path, &continue_on_exists_proc); end

  # Convenience method for adding the contents of a file to the archive
  # in Stored format (uncompressed)
  #
  # source://rubyzip//lib/zip/file.rb#310
  def add_stored(entry, src_path, &continue_on_exists_proc); end

  # Closes the zip file committing any changes that has been made.
  #
  # source://rubyzip//lib/zip/file.rb#372
  def close; end

  # Returns the zip files comment, if it has one
  #
  # source://rubyzip//lib/zip/file.rb#72
  def comment; end

  # Returns the zip files comment, if it has one
  #
  # source://rubyzip//lib/zip/file.rb#72
  def comment=(_arg0); end

  # Commits changes that has been made since the previous commit to
  # the zip archive.
  #
  # source://rubyzip//lib/zip/file.rb#346
  def commit; end

  # Returns true if any changes has been made to this archive since
  # the previous commit
  #
  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/file.rb#378
  def commit_required?; end

  # Extracts entry to file dest_path.
  #
  # source://rubyzip//lib/zip/file.rb#338
  def extract(entry, dest_path, &block); end

  # Searches for entry with the specified name. Returns nil if
  # no entry is found. See also get_entry
  #
  # source://rubyzip//lib/zip/file.rb#387
  def find_entry(entry_name); end

  # Searches for an entry just as find_entry, but throws Errno::ENOENT
  # if no entry is found.
  #
  # @raise [Errno::ENOENT]
  #
  # source://rubyzip//lib/zip/file.rb#404
  def get_entry(entry); end

  # Returns an input stream to the specified entry. If a block is passed
  # the stream object is passed to the block and the stream is automatically
  # closed afterwards just as with ruby's builtin File.open method.
  #
  # source://rubyzip//lib/zip/file.rb#258
  def get_input_stream(entry, &a_proc); end

  # Returns an output stream to the specified entry. If entry is not an instance
  # of Zip::Entry, a new Zip::Entry will be initialized using the arguments
  # specified. If a block is passed the stream object is passed to the block and
  # the stream is automatically closed afterwards just as with ruby's builtin
  # File.open method.
  #
  # source://rubyzip//lib/zip/file.rb#267
  def get_output_stream(entry, permission_int = T.unsafe(nil), comment = T.unsafe(nil), extra = T.unsafe(nil), compressed_size = T.unsafe(nil), crc = T.unsafe(nil), compression_method = T.unsafe(nil), size = T.unsafe(nil), time = T.unsafe(nil), &a_proc); end

  # Searches for entries given a glob
  #
  # source://rubyzip//lib/zip/file.rb#398
  def glob(*args, &block); end

  # Creates a directory
  #
  # @raise [Errno::EEXIST]
  #
  # source://rubyzip//lib/zip/file.rb#412
  def mkdir(entry_name, permission = T.unsafe(nil)); end

  # Returns the value of attribute name.
  #
  # source://rubyzip//lib/zip/file.rb#60
  def name; end

  # Returns a string containing the contents of the specified entry
  #
  # source://rubyzip//lib/zip/file.rb#294
  def read(entry); end

  # Removes the specified entry.
  #
  # source://rubyzip//lib/zip/file.rb#316
  def remove(entry); end

  # Renames the specified entry.
  #
  # source://rubyzip//lib/zip/file.rb#321
  def rename(entry, new_name, &continue_on_exists_proc); end

  # Replaces the specified entry with the contents of src_path (from
  # the file system).
  #
  # source://rubyzip//lib/zip/file.rb#331
  def replace(entry, src_path); end

  # default -> false.
  #
  # source://rubyzip//lib/zip/file.rb#63
  def restore_ownership; end

  # default -> false.
  #
  # source://rubyzip//lib/zip/file.rb#63
  def restore_ownership=(_arg0); end

  # default -> false, but will be set to true in a future version.
  #
  # source://rubyzip//lib/zip/file.rb#66
  def restore_permissions; end

  # default -> false, but will be set to true in a future version.
  #
  # source://rubyzip//lib/zip/file.rb#66
  def restore_permissions=(_arg0); end

  # default -> false, but will be set to true in a future version.
  #
  # source://rubyzip//lib/zip/file.rb#69
  def restore_times; end

  # default -> false, but will be set to true in a future version.
  #
  # source://rubyzip//lib/zip/file.rb#69
  def restore_times=(_arg0); end

  # Returns the name of the zip archive
  #
  # source://rubyzip//lib/zip/file.rb#289
  def to_s; end

  # Write buffer write changes to buffer and return
  #
  # source://rubyzip//lib/zip/file.rb#364
  def write_buffer(io = T.unsafe(nil)); end

  private

  # source://rubyzip//lib/zip/file.rb#434
  def check_entry_exists(entry_name, continue_on_exists_proc, proc_name); end

  # @raise [Errno::ENOENT]
  #
  # source://rubyzip//lib/zip/file.rb#446
  def check_file(path); end

  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/file.rb#422
  def directory?(new_entry, src_path); end

  # source://rubyzip//lib/zip/file.rb#450
  def on_success_replace; end

  class << self
    # Same as #open. But outputs data to a buffer instead of a file
    #
    # @yield [zf]
    #
    # source://rubyzip//lib/zip/file.rb#132
    def add_buffer; end

    # Iterates over the contents of the ZipFile. This is more efficient
    # than using a ZipInputStream since this methods simply iterates
    # through the entries in the central directory structure in the archive
    # whereas ZipInputStream jumps through the entire archive accessing the
    # local entry headers (which contain the same information as the
    # central directory).
    #
    # source://rubyzip//lib/zip/file.rb#171
    def foreach(zip_file_name, &block); end

    # source://rubyzip//lib/zip/file.rb#187
    def get_partial_zip_file_name(zip_file_name, partial_zip_file_name); end

    # source://rubyzip//lib/zip/file.rb#196
    def get_segment_count_for_split(zip_file_size, segment_size); end

    # source://rubyzip//lib/zip/file.rb#177
    def get_segment_size_for_split(segment_size); end

    # Similar to ::new. If a block is passed the Zip::File object is passed
    # to the block and is automatically closed afterwards, just as with
    # ruby's builtin File::open method.
    #
    # source://rubyzip//lib/zip/file.rb#120
    def open(file_name, create = T.unsafe(nil), options = T.unsafe(nil)); end

    # Like #open, but reads zip archive contents from a String or open IO
    # stream, and outputs data to a buffer.
    # (This can be used to extract data from a
    # downloaded zip archive without first saving it to disk.)
    #
    # @yield [zf]
    #
    # source://rubyzip//lib/zip/file.rb#143
    def open_buffer(io, options = T.unsafe(nil)); end

    # source://rubyzip//lib/zip/file.rb#200
    def put_split_signature(szip_file, segment_size); end

    # TODO: Make the code more understandable
    #
    # source://rubyzip//lib/zip/file.rb#209
    def save_splited_part(zip_file, partial_zip_file_name, zip_file_size, szip_file_index, segment_size, segment_count); end

    # Splits an archive into parts with segment size
    #
    # @raise [Error]
    #
    # source://rubyzip//lib/zip/file.rb#231
    def split(zip_file_name, segment_size = T.unsafe(nil), delete_zip_file = T.unsafe(nil), partial_zip_file_name = T.unsafe(nil)); end
  end
end

# source://rubyzip//lib/zip/file.rb#46
Zip::File::CREATE = T.let(T.unsafe(nil), TrueClass)

# source://rubyzip//lib/zip/file.rb#51
Zip::File::DATA_BUFFER_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/file.rb#54
Zip::File::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://rubyzip//lib/zip/file.rb#52
Zip::File::IO_METHODS = T.let(T.unsafe(nil), Array)

# source://rubyzip//lib/zip/file.rb#49
Zip::File::MAX_SEGMENT_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/file.rb#50
Zip::File::MIN_SEGMENT_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/file.rb#47
Zip::File::SPLIT_SIGNATURE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/file.rb#48
Zip::File::ZIP64_EOCD_SIGNATURE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/errors.rb#9
class Zip::GPFBit3Error < ::Zip::Error; end

# source://rubyzip//lib/zip/ioextras.rb#2
module Zip::IOExtras
  class << self
    # source://rubyzip//lib/zip/ioextras.rb#8
    def copy_stream(ostream, istream); end

    # source://rubyzip//lib/zip/ioextras.rb#12
    def copy_stream_n(ostream, istream, nbytes); end
  end
end

# Implements many of the convenience methods of IO
# such as gets, getc, readline and readlines
# depends on: input_finished?, produce_input and read
#
# source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#6
module Zip::IOExtras::AbstractInputStream
  include ::Enumerable
  include ::Zip::IOExtras::FakeIO

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#10
  def initialize; end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#107
  def each(a_sep_string = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#107
  def each_line(a_sep_string = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#115
  def eof; end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#115
  def eof?; end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#94
  def flush; end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#58
  def gets(a_sep_string = T.unsafe(nil), number_of_bytes = T.unsafe(nil)); end

  # Returns the value of attribute lineno.
  #
  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#17
  def lineno; end

  # Sets the attribute lineno
  #
  # @param value the value to set the attribute lineno to.
  #
  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#17
  def lineno=(_arg0); end

  # Returns the value of attribute pos.
  #
  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#18
  def pos; end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#20
  def read(number_of_bytes = T.unsafe(nil), buf = T.unsafe(nil)); end

  # @raise [EOFError]
  #
  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#100
  def readline(a_sep_string = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#52
  def readlines(a_sep_string = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/ioextras/abstract_input_stream.rb#90
  def ungetc(byte); end
end

# Implements many of the output convenience methods of IO.
# relies on <<
#
# source://rubyzip//lib/zip/ioextras/abstract_output_stream.rb#5
module Zip::IOExtras::AbstractOutputStream
  include ::Zip::IOExtras::FakeIO

  # source://rubyzip//lib/zip/ioextras/abstract_output_stream.rb#13
  def print(*params); end

  # source://rubyzip//lib/zip/ioextras/abstract_output_stream.rb#17
  def printf(a_format_string, *params); end

  # source://rubyzip//lib/zip/ioextras/abstract_output_stream.rb#21
  def putc(an_object); end

  # source://rubyzip//lib/zip/ioextras/abstract_output_stream.rb#33
  def puts(*params); end

  # source://rubyzip//lib/zip/ioextras/abstract_output_stream.rb#8
  def write(data); end
end

# source://rubyzip//lib/zip/ioextras.rb#3
Zip::IOExtras::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# Implements kind_of? in order to pretend to be an IO object
#
# source://rubyzip//lib/zip/ioextras.rb#23
module Zip::IOExtras::FakeIO
  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/ioextras.rb#24
  def kind_of?(object); end
end

# source://rubyzip//lib/zip/ioextras.rb#5
Zip::IOExtras::RANGE_ALL = T.let(T.unsafe(nil), Range)

# source://rubyzip//lib/zip/inflater.rb#2
class Zip::Inflater < ::Zip::Decompressor
  # @return [Inflater] a new instance of Inflater
  #
  # source://rubyzip//lib/zip/inflater.rb#3
  def initialize(*args); end

  # source://rubyzip//lib/zip/inflater.rb#22
  def eof; end

  # source://rubyzip//lib/zip/inflater.rb#22
  def eof?; end

  # source://rubyzip//lib/zip/inflater.rb#10
  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/inflater.rb#44
  def input_finished?; end

  # source://rubyzip//lib/zip/inflater.rb#30
  def produce_input; end
end

# InputStream is the basic class for reading zip entries in a
# zip file. It is possible to create a InputStream object directly,
# passing the zip file name to the constructor, but more often than not
# the InputStream will be obtained from a File (perhaps using the
# ZipFileSystem interface) object for a particular entry in the zip
# archive.
#
# A InputStream inherits IOExtras::AbstractInputStream in order
# to provide an IO-like interface for reading from a single zip
# entry. Beyond methods for mimicking an IO-object it contains
# the method get_next_entry for iterating through the entries of
# an archive. get_next_entry returns a Entry object that describes
# the zip entry the InputStream is currently reading from.
#
# Example that creates a zip archive with ZipOutputStream and reads it
# back again with a InputStream.
#
#   require 'zip'
#
#   Zip::OutputStream.open("my.zip") do |io|
#
#     io.put_next_entry("first_entry.txt")
#     io.write "Hello world!"
#
#     io.put_next_entry("adir/first_entry.txt")
#     io.write "Hello again!"
#   end
#
#
#   Zip::InputStream.open("my.zip") do |io|
#
#     while (entry = io.get_next_entry)
#       puts "Contents of #{entry.name}: '#{io.read}'"
#     end
#   end
#
# java.util.zip.ZipInputStream is the original inspiration for this
# class.
#
# source://rubyzip//lib/zip/input_stream.rb#41
class Zip::InputStream
  include ::Enumerable
  include ::Zip::IOExtras::FakeIO
  include ::Zip::IOExtras::AbstractInputStream

  # Opens the indicated zip file. An exception is thrown
  # if the specified offset in the specified filename is
  # not a local zip entry header.
  #
  # @param context [String||IO||StringIO] file path or IO/StringIO object
  # @param offset [Integer] offset in the IO/StringIO
  # @return [InputStream] a new instance of InputStream
  #
  # source://rubyzip//lib/zip/input_stream.rb#52
  def initialize(context, offset = T.unsafe(nil), decrypter = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/input_stream.rb#60
  def close; end

  # Returns a Entry object. It is necessary to call this
  # method on a newly created InputStream before reading from
  # the first entry in the archive. Returns nil when there are
  # no more entries.
  #
  # source://rubyzip//lib/zip/input_stream.rb#68
  def get_next_entry; end

  # Rewinds the stream to the beginning of the current entry
  #
  # source://rubyzip//lib/zip/input_stream.rb#74
  def rewind; end

  # Modeled after IO.sysread
  #
  # source://rubyzip//lib/zip/input_stream.rb#84
  def sysread(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  protected

  # source://rubyzip//lib/zip/input_stream.rb#149
  def get_decompressor; end

  # source://rubyzip//lib/zip/input_stream.rb#142
  def get_decrypted_io; end

  # source://rubyzip//lib/zip/input_stream.rb#111
  def get_io(io_or_file, offset = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubyzip//lib/zip/input_stream.rb#172
  def input_finished?; end

  # source://rubyzip//lib/zip/input_stream.rb#123
  def open_entry; end

  # source://rubyzip//lib/zip/input_stream.rb#168
  def produce_input; end

  class << self
    # Same as #initialize but if a block is passed the opened
    # stream is passed to the block and closed when the block
    # returns.
    #
    # source://rubyzip//lib/zip/input_stream.rb#92
    def open(filename_or_io, offset = T.unsafe(nil), decrypter = T.unsafe(nil)); end

    # source://rubyzip//lib/zip/input_stream.rb#103
    def open_buffer(filename_or_io, offset = T.unsafe(nil)); end
  end
end

# source://rubyzip//lib/zip/input_stream.rb#42
Zip::InputStream::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/errors.rb#8
class Zip::InternalError < ::Zip::Error; end

# source://rubyzip//lib/zip/constants.rb#7
Zip::LOCAL_ENTRY_SIGNATURE = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#8
Zip::LOCAL_ENTRY_STATIC_HEADER_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#9
Zip::LOCAL_ENTRY_TRAILING_DESCRIPTOR_LENGTH = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/null_compressor.rb#2
class Zip::NullCompressor < ::Zip::Compressor
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # @raise [IOError]
  #
  # source://rubyzip//lib/zip/null_compressor.rb#5
  def <<(_data); end

  # Returns the value of attribute compressed_size.
  #
  # source://rubyzip//lib/zip/null_compressor.rb#9
  def compressed_size; end

  # Returns the value of attribute size.
  #
  # source://rubyzip//lib/zip/null_compressor.rb#9
  def size; end

  class << self
    private

    def allocate; end
    def new(*_arg0); end
  end
end

# source://rubyzip//lib/zip/null_decompressor.rb#2
module Zip::NullDecompressor
  private

  # source://rubyzip//lib/zip/null_decompressor.rb#9
  def eof; end

  # source://rubyzip//lib/zip/null_decompressor.rb#9
  def eof?; end

  # source://rubyzip//lib/zip/null_decompressor.rb#5
  def read(_length = T.unsafe(nil), _outbuf = T.unsafe(nil)); end

  class << self
    # source://rubyzip//lib/zip/null_decompressor.rb#9
    def eof; end

    # source://rubyzip//lib/zip/null_decompressor.rb#5
    def read(_length = T.unsafe(nil), _outbuf = T.unsafe(nil)); end
  end
end

# source://rubyzip//lib/zip/crypto/null_encryption.rb#30
class Zip::NullDecrypter < ::Zip::Decrypter
  include ::Zip::NullEncryption

  # source://rubyzip//lib/zip/crypto/null_encryption.rb#33
  def decrypt(data); end

  # source://rubyzip//lib/zip/crypto/null_encryption.rb#37
  def reset!(_header); end
end

# source://rubyzip//lib/zip/crypto/null_encryption.rb#12
class Zip::NullEncrypter < ::Zip::Encrypter
  include ::Zip::NullEncryption

  # source://rubyzip//lib/zip/crypto/null_encryption.rb#23
  def data_descriptor(_crc32, _compressed_size, _uncomprssed_size); end

  # source://rubyzip//lib/zip/crypto/null_encryption.rb#19
  def encrypt(data); end

  # source://rubyzip//lib/zip/crypto/null_encryption.rb#15
  def header(_mtime); end

  # source://rubyzip//lib/zip/crypto/null_encryption.rb#27
  def reset!; end
end

# source://rubyzip//lib/zip/crypto/null_encryption.rb#2
module Zip::NullEncryption
  # source://rubyzip//lib/zip/crypto/null_encryption.rb#7
  def gp_flags; end

  # source://rubyzip//lib/zip/crypto/null_encryption.rb#3
  def header_bytesize; end
end

# source://rubyzip//lib/zip/null_input_stream.rb#2
module Zip::NullInputStream
  include ::Zip::NullDecompressor
  include ::Enumerable
  include ::Zip::IOExtras::FakeIO
  include ::Zip::IOExtras::AbstractInputStream
end

# ZipOutputStream is the basic class for writing zip files. It is
# possible to create a ZipOutputStream object directly, passing
# the zip file name to the constructor, but more often than not
# the ZipOutputStream will be obtained from a ZipFile (perhaps using the
# ZipFileSystem interface) object for a particular entry in the zip
# archive.
#
# A ZipOutputStream inherits IOExtras::AbstractOutputStream in order
# to provide an IO-like interface for writing to a single zip
# entry. Beyond methods for mimicking an IO-object it contains
# the method put_next_entry that closes the current entry
# and creates a new.
#
# Please refer to ZipInputStream for example code.
#
# java.util.zip.ZipOutputStream is the original inspiration for this
# class.
#
# source://rubyzip//lib/zip/output_stream.rb#20
class Zip::OutputStream
  include ::Zip::IOExtras::FakeIO
  include ::Zip::IOExtras::AbstractOutputStream

  # Opens the indicated zip file. If a file with that name already
  # exists it will be overwritten.
  #
  # @return [OutputStream] a new instance of OutputStream
  #
  # source://rubyzip//lib/zip/output_stream.rb#27
  def initialize(file_name, stream = T.unsafe(nil), encrypter = T.unsafe(nil)); end

  # Modeled after IO.<<
  #
  # source://rubyzip//lib/zip/output_stream.rb#189
  def <<(data); end

  # Closes the stream and writes the central directory to the zip file
  #
  # source://rubyzip//lib/zip/output_stream.rb#69
  def close; end

  # Closes the stream and writes the central directory to the zip file
  #
  # source://rubyzip//lib/zip/output_stream.rb#80
  def close_buffer; end

  # Returns the value of attribute comment.
  #
  # source://rubyzip//lib/zip/output_stream.rb#23
  def comment; end

  # Sets the attribute comment
  #
  # @param value the value to set the attribute comment to.
  #
  # source://rubyzip//lib/zip/output_stream.rb#23
  def comment=(_arg0); end

  # @raise [Error]
  #
  # source://rubyzip//lib/zip/output_stream.rb#109
  def copy_raw_entry(entry); end

  # Closes the current entry and opens a new for writing.
  # +entry+ can be a ZipEntry object or a string.
  #
  # @raise [Error]
  #
  # source://rubyzip//lib/zip/output_stream.rb#92
  def put_next_entry(entry_name, comment = T.unsafe(nil), extra = T.unsafe(nil), compression_method = T.unsafe(nil), level = T.unsafe(nil)); end

  protected

  # source://rubyzip//lib/zip/output_stream.rb#182
  def finish; end

  private

  # source://rubyzip//lib/zip/output_stream.rb#130
  def finalize_current_entry; end

  # source://rubyzip//lib/zip/output_stream.rb#154
  def get_compressor(entry, level); end

  # source://rubyzip//lib/zip/output_stream.rb#145
  def init_next_entry(entry, level = T.unsafe(nil)); end

  # source://rubyzip//lib/zip/output_stream.rb#166
  def update_local_headers; end

  # source://rubyzip//lib/zip/output_stream.rb#175
  def write_central_directory; end

  class << self
    # source://rubyzip//lib/zip/output_stream.rb#50
    def open(file_name, encrypter = T.unsafe(nil)); end

    # Same as #open but writes to a filestream instead
    #
    # @yield [zos]
    #
    # source://rubyzip//lib/zip/output_stream.rb#60
    def write_buffer(io = T.unsafe(nil), encrypter = T.unsafe(nil)); end
  end
end

# source://rubyzip//lib/zip/pass_thru_compressor.rb#2
class Zip::PassThruCompressor < ::Zip::Compressor
  # @return [PassThruCompressor] a new instance of PassThruCompressor
  #
  # source://rubyzip//lib/zip/pass_thru_compressor.rb#3
  def initialize(output_stream); end

  # source://rubyzip//lib/zip/pass_thru_compressor.rb#10
  def <<(data); end

  # Returns the value of attribute crc.
  #
  # source://rubyzip//lib/zip/pass_thru_compressor.rb#17
  def crc; end

  # Returns the value of attribute size.
  #
  # source://rubyzip//lib/zip/pass_thru_compressor.rb#17
  def size; end
end

# source://rubyzip//lib/zip/pass_thru_decompressor.rb#2
class Zip::PassThruDecompressor < ::Zip::Decompressor
  # @return [PassThruDecompressor] a new instance of PassThruDecompressor
  #
  # source://rubyzip//lib/zip/pass_thru_decompressor.rb#3
  def initialize(*args); end

  # source://rubyzip//lib/zip/pass_thru_decompressor.rb#19
  def eof; end

  # source://rubyzip//lib/zip/pass_thru_decompressor.rb#19
  def eof?; end

  # source://rubyzip//lib/zip/pass_thru_decompressor.rb#8
  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end
end

# source://rubyzip//lib/zip/constants.rb#2
Zip::RUNNING_ON_WINDOWS = T.let(T.unsafe(nil), T.untyped)

# source://rubyzip//lib/zip/streamable_directory.rb#2
class Zip::StreamableDirectory < ::Zip::Entry
  # @return [StreamableDirectory] a new instance of StreamableDirectory
  #
  # source://rubyzip//lib/zip/streamable_directory.rb#3
  def initialize(zipfile, entry, src_path = T.unsafe(nil), permission = T.unsafe(nil)); end
end

# source://rubyzip//lib/zip/streamable_stream.rb#2
class Zip::StreamableStream
  # @return [StreamableStream] a new instance of StreamableStream
  #
  # source://rubyzip//lib/zip/streamable_stream.rb#3
  def initialize(entry); end

  # source://rubyzip//lib/zip/streamable_stream.rb#44
  def clean_up; end

  # source://rubyzip//lib/zip/streamable_stream.rb#21
  def get_input_stream; end

  # source://rubyzip//lib/zip/streamable_stream.rb#9
  def get_output_stream; end

  # source://rubyzip//lib/zip/streamable_stream.rb#39
  def write_to_zip_output_stream(output_stream); end
end

# source://rubyzip//lib/zip/crypto/traditional_encryption.rb#73
class Zip::TraditionalDecrypter < ::Zip::Decrypter
  include ::Zip::TraditionalEncryption

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#76
  def decrypt(data); end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#80
  def reset!(header); end

  private

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#89
  def decode(num); end
end

# source://rubyzip//lib/zip/crypto/traditional_encryption.rb#39
class Zip::TraditionalEncrypter < ::Zip::Encrypter
  include ::Zip::TraditionalEncryption

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#56
  def data_descriptor(crc32, compressed_size, uncomprssed_size); end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#52
  def encrypt(data); end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#42
  def header(mtime); end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#60
  def reset!; end

  private

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#66
  def encode(num); end
end

# source://rubyzip//lib/zip/crypto/traditional_encryption.rb#2
module Zip::TraditionalEncryption
  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#3
  def initialize(password); end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#12
  def gp_flags; end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#8
  def header_bytesize; end

  protected

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#33
  def decrypt_byte; end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#18
  def reset_keys!; end

  # source://rubyzip//lib/zip/crypto/traditional_encryption.rb#27
  def update_keys(num); end
end

# this library's version
#
# source://rubyzip//lib/zip/constants.rb#10
Zip::VERSION_MADE_BY = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#11
Zip::VERSION_NEEDED_TO_EXTRACT = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/constants.rb#12
Zip::VERSION_NEEDED_TO_EXTRACT_ZIP64 = T.let(T.unsafe(nil), Integer)

# source://rubyzip//lib/zip/errors.rb#16
Zip::ZipCompressionMethodError = Zip::CompressionMethodError

# source://rubyzip//lib/zip/errors.rb#15
Zip::ZipDestinationFileExistsError = Zip::DestinationFileExistsError

# source://rubyzip//lib/zip/errors.rb#14
Zip::ZipEntryExistsError = Zip::EntryExistsError

# source://rubyzip//lib/zip/errors.rb#17
Zip::ZipEntryNameError = Zip::EntryNameError

# Backwards compatibility with v1 (delete in v2)
#
# source://rubyzip//lib/zip/errors.rb#13
Zip::ZipError = Zip::Error

# source://rubyzip//lib/zip/errors.rb#18
Zip::ZipInternalError = Zip::InternalError
