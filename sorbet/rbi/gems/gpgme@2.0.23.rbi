# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `gpgme` gem.
# Please instead update this file by running `bin/tapioca gem gpgme`.

# TODO: Find why is this needed. I guess the name compat means it's just
# backwards compatibility. Consider removing?
#
# source://gpgme//lib/gpgme/constants.rb#1
module GPGME
  private

  def gpgme_check_version(_arg0); end
  def gpgme_ctx_get_engine_info(_arg0, _arg1); end
  def gpgme_ctx_set_engine_info(_arg0, _arg1, _arg2, _arg3); end
  def gpgme_data_get_encoding(_arg0); end
  def gpgme_data_get_file_name(_arg0); end
  def gpgme_data_new(_arg0); end
  def gpgme_data_new_from_cbs(_arg0, _arg1, _arg2); end
  def gpgme_data_new_from_fd(_arg0, _arg1); end
  def gpgme_data_new_from_mem(_arg0, _arg1, _arg2); end
  def gpgme_data_read(_arg0, _arg1); end
  def gpgme_data_seek(_arg0, _arg1, _arg2); end
  def gpgme_data_set_encoding(_arg0, _arg1); end
  def gpgme_data_set_file_name(_arg0, _arg1); end
  def gpgme_data_write(_arg0, _arg1, _arg2); end
  def gpgme_engine_check_version(_arg0); end
  def gpgme_err_code(_arg0); end
  def gpgme_err_source(_arg0); end
  def gpgme_get_armor(_arg0); end
  def gpgme_get_dirinfo(_arg0); end
  def gpgme_get_engine_info(_arg0); end
  def gpgme_get_include_certs(_arg0); end
  def gpgme_get_key(_arg0, _arg1, _arg2, _arg3); end
  def gpgme_get_keylist_mode(_arg0); end
  def gpgme_get_offline(_arg0); end
  def gpgme_get_passphrase_cb(_arg0, _arg1, _arg2); end
  def gpgme_get_pinentry_mode(_arg0); end
  def gpgme_get_progress_cb(_arg0, _arg1, _arg2); end
  def gpgme_get_protocol(_arg0); end
  def gpgme_get_status_cb(_arg0, _arg1, _arg2); end
  def gpgme_get_textmode(_arg0); end
  def gpgme_hash_algo_name(_arg0); end
  def gpgme_new(_arg0); end
  def gpgme_op_card_edit(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def gpgme_op_card_edit_start(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def gpgme_op_decrypt(_arg0, _arg1, _arg2); end
  def gpgme_op_decrypt_result(_arg0); end
  def gpgme_op_decrypt_start(_arg0, _arg1, _arg2); end
  def gpgme_op_decrypt_verify(_arg0, _arg1, _arg2); end
  def gpgme_op_decrypt_verify_start(_arg0, _arg1, _arg2); end
  def gpgme_op_delete(_arg0, _arg1, _arg2); end
  def gpgme_op_delete_start(_arg0, _arg1, _arg2); end
  def gpgme_op_edit(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def gpgme_op_edit_start(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def gpgme_op_encrypt(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def gpgme_op_encrypt_result(_arg0); end
  def gpgme_op_encrypt_sign(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def gpgme_op_encrypt_sign_start(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def gpgme_op_encrypt_start(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def gpgme_op_export(_arg0, _arg1, _arg2, _arg3); end
  def gpgme_op_export_ext(_arg0, _arg1, _arg2, _arg3); end
  def gpgme_op_export_ext_start(_arg0, _arg1, _arg2, _arg3); end
  def gpgme_op_export_keys(_arg0, _arg1, _arg2, _arg3); end
  def gpgme_op_export_keys_start(_arg0, _arg1, _arg2, _arg3); end
  def gpgme_op_export_start(_arg0, _arg1, _arg2, _arg3); end
  def gpgme_op_genkey(_arg0, _arg1, _arg2, _arg3); end
  def gpgme_op_genkey_start(_arg0, _arg1, _arg2, _arg3); end
  def gpgme_op_import(_arg0, _arg1); end
  def gpgme_op_import_keys(_arg0, _arg1); end
  def gpgme_op_import_keys_start(_arg0, _arg1); end
  def gpgme_op_import_result(_arg0); end
  def gpgme_op_import_start(_arg0, _arg1); end
  def gpgme_op_keylist_end(_arg0); end
  def gpgme_op_keylist_ext_start(_arg0, _arg1, _arg2); end
  def gpgme_op_keylist_next(_arg0, _arg1); end
  def gpgme_op_keylist_start(_arg0, _arg1, _arg2); end
  def gpgme_op_sign(_arg0, _arg1, _arg2, _arg3); end
  def gpgme_op_sign_result(_arg0); end
  def gpgme_op_sign_start(_arg0, _arg1, _arg2, _arg3); end
  def gpgme_op_spawn(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6); end
  def gpgme_op_spawn_start(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6); end
  def gpgme_op_trustlist_end(_arg0); end
  def gpgme_op_trustlist_next(_arg0, _arg1); end
  def gpgme_op_trustlist_start(_arg0, _arg1, _arg2); end
  def gpgme_op_verify(_arg0, _arg1, _arg2, _arg3); end
  def gpgme_op_verify_result(_arg0); end
  def gpgme_op_verify_start(_arg0, _arg1, _arg2, _arg3); end
  def gpgme_pubkey_algo_name(_arg0); end
  def gpgme_release(_arg0); end
  def gpgme_set_armor(_arg0, _arg1); end
  def gpgme_set_engine_info(_arg0, _arg1, _arg2); end
  def gpgme_set_include_certs(_arg0, _arg1); end
  def gpgme_set_keylist_mode(_arg0, _arg1); end
  def gpgme_set_locale(_arg0, _arg1, _arg2); end
  def gpgme_set_offline(_arg0, _arg1); end
  def gpgme_set_passphrase_cb(_arg0, _arg1, _arg2); end
  def gpgme_set_pinentry_mode(_arg0, _arg1); end
  def gpgme_set_progress_cb(_arg0, _arg1, _arg2); end
  def gpgme_set_protocol(_arg0, _arg1); end
  def gpgme_set_status_cb(_arg0, _arg1, _arg2); end
  def gpgme_set_textmode(_arg0, _arg1); end
  def gpgme_signers_add(_arg0, _arg1); end
  def gpgme_signers_clear(_arg0); end
  def gpgme_signers_enum(_arg0, _arg1); end
  def gpgme_strerror(_arg0); end
  def gpgme_wait(_arg0, _arg1, _arg2); end

  class << self
    # TODO find out what it does, can't seem to find a proper parameter that
    # returns something other than nil.
    #
    # source://gpgme//lib/gpgme.rb#95
    def check_version(options = T.unsafe(nil)); end

    # Auxiliary method used by all the library to generate exceptions
    # from error codes returned by the C extension.
    #
    # source://gpgme//lib/gpgme.rb#33
    def error_to_exception(err); end

    def gpgme_check_version(_arg0); end
    def gpgme_ctx_get_engine_info(_arg0, _arg1); end
    def gpgme_ctx_set_engine_info(_arg0, _arg1, _arg2, _arg3); end
    def gpgme_data_get_encoding(_arg0); end
    def gpgme_data_get_file_name(_arg0); end
    def gpgme_data_new(_arg0); end
    def gpgme_data_new_from_cbs(_arg0, _arg1, _arg2); end
    def gpgme_data_new_from_fd(_arg0, _arg1); end
    def gpgme_data_new_from_mem(_arg0, _arg1, _arg2); end
    def gpgme_data_read(_arg0, _arg1); end
    def gpgme_data_seek(_arg0, _arg1, _arg2); end
    def gpgme_data_set_encoding(_arg0, _arg1); end
    def gpgme_data_set_file_name(_arg0, _arg1); end
    def gpgme_data_write(_arg0, _arg1, _arg2); end
    def gpgme_engine_check_version(_arg0); end
    def gpgme_err_code(_arg0); end
    def gpgme_err_source(_arg0); end
    def gpgme_get_armor(_arg0); end
    def gpgme_get_dirinfo(_arg0); end
    def gpgme_get_engine_info(_arg0); end
    def gpgme_get_include_certs(_arg0); end
    def gpgme_get_key(_arg0, _arg1, _arg2, _arg3); end
    def gpgme_get_keylist_mode(_arg0); end
    def gpgme_get_offline(_arg0); end
    def gpgme_get_passphrase_cb(_arg0, _arg1, _arg2); end
    def gpgme_get_pinentry_mode(_arg0); end
    def gpgme_get_progress_cb(_arg0, _arg1, _arg2); end
    def gpgme_get_protocol(_arg0); end
    def gpgme_get_status_cb(_arg0, _arg1, _arg2); end
    def gpgme_get_textmode(_arg0); end
    def gpgme_hash_algo_name(_arg0); end
    def gpgme_new(_arg0); end
    def gpgme_op_card_edit(_arg0, _arg1, _arg2, _arg3, _arg4); end
    def gpgme_op_card_edit_start(_arg0, _arg1, _arg2, _arg3, _arg4); end
    def gpgme_op_decrypt(_arg0, _arg1, _arg2); end
    def gpgme_op_decrypt_result(_arg0); end
    def gpgme_op_decrypt_start(_arg0, _arg1, _arg2); end
    def gpgme_op_decrypt_verify(_arg0, _arg1, _arg2); end
    def gpgme_op_decrypt_verify_start(_arg0, _arg1, _arg2); end
    def gpgme_op_delete(_arg0, _arg1, _arg2); end
    def gpgme_op_delete_start(_arg0, _arg1, _arg2); end
    def gpgme_op_edit(_arg0, _arg1, _arg2, _arg3, _arg4); end
    def gpgme_op_edit_start(_arg0, _arg1, _arg2, _arg3, _arg4); end
    def gpgme_op_encrypt(_arg0, _arg1, _arg2, _arg3, _arg4); end
    def gpgme_op_encrypt_result(_arg0); end
    def gpgme_op_encrypt_sign(_arg0, _arg1, _arg2, _arg3, _arg4); end
    def gpgme_op_encrypt_sign_start(_arg0, _arg1, _arg2, _arg3, _arg4); end
    def gpgme_op_encrypt_start(_arg0, _arg1, _arg2, _arg3, _arg4); end
    def gpgme_op_export(_arg0, _arg1, _arg2, _arg3); end
    def gpgme_op_export_ext(_arg0, _arg1, _arg2, _arg3); end
    def gpgme_op_export_ext_start(_arg0, _arg1, _arg2, _arg3); end
    def gpgme_op_export_keys(_arg0, _arg1, _arg2, _arg3); end
    def gpgme_op_export_keys_start(_arg0, _arg1, _arg2, _arg3); end
    def gpgme_op_export_start(_arg0, _arg1, _arg2, _arg3); end
    def gpgme_op_genkey(_arg0, _arg1, _arg2, _arg3); end
    def gpgme_op_genkey_start(_arg0, _arg1, _arg2, _arg3); end
    def gpgme_op_import(_arg0, _arg1); end
    def gpgme_op_import_keys(_arg0, _arg1); end
    def gpgme_op_import_keys_start(_arg0, _arg1); end
    def gpgme_op_import_result(_arg0); end
    def gpgme_op_import_start(_arg0, _arg1); end
    def gpgme_op_keylist_end(_arg0); end
    def gpgme_op_keylist_ext_start(_arg0, _arg1, _arg2); end
    def gpgme_op_keylist_next(_arg0, _arg1); end
    def gpgme_op_keylist_start(_arg0, _arg1, _arg2); end
    def gpgme_op_sign(_arg0, _arg1, _arg2, _arg3); end
    def gpgme_op_sign_result(_arg0); end
    def gpgme_op_sign_start(_arg0, _arg1, _arg2, _arg3); end
    def gpgme_op_spawn(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6); end
    def gpgme_op_spawn_start(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6); end
    def gpgme_op_trustlist_end(_arg0); end
    def gpgme_op_trustlist_next(_arg0, _arg1); end
    def gpgme_op_trustlist_start(_arg0, _arg1, _arg2); end
    def gpgme_op_verify(_arg0, _arg1, _arg2, _arg3); end
    def gpgme_op_verify_result(_arg0); end
    def gpgme_op_verify_start(_arg0, _arg1, _arg2, _arg3); end
    def gpgme_pubkey_algo_name(_arg0); end
    def gpgme_release(_arg0); end
    def gpgme_set_armor(_arg0, _arg1); end
    def gpgme_set_engine_info(_arg0, _arg1, _arg2); end
    def gpgme_set_include_certs(_arg0, _arg1); end
    def gpgme_set_keylist_mode(_arg0, _arg1); end
    def gpgme_set_locale(_arg0, _arg1, _arg2); end
    def gpgme_set_offline(_arg0, _arg1); end
    def gpgme_set_passphrase_cb(_arg0, _arg1, _arg2); end
    def gpgme_set_pinentry_mode(_arg0, _arg1); end
    def gpgme_set_progress_cb(_arg0, _arg1, _arg2); end
    def gpgme_set_protocol(_arg0, _arg1); end
    def gpgme_set_status_cb(_arg0, _arg1, _arg2); end
    def gpgme_set_textmode(_arg0, _arg1); end
    def gpgme_signers_add(_arg0, _arg1); end
    def gpgme_signers_clear(_arg0); end
    def gpgme_signers_enum(_arg0, _arg1); end
    def gpgme_strerror(_arg0); end
    def gpgme_wait(_arg0, _arg1, _arg2); end
    def hash_algo_name(_arg0); end

    # From the c extension
    def pubkey_algo_name(_arg0); end
  end
end

# source://gpgme//lib/gpgme/constants.rb#3
GPGME::ATTR_ALGO = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#4
GPGME::ATTR_CAN_CERTIFY = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#5
GPGME::ATTR_CAN_ENCRYPT = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#6
GPGME::ATTR_CAN_SIGN = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#7
GPGME::ATTR_CHAINID = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#8
GPGME::ATTR_COMMENT = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#9
GPGME::ATTR_CREATED = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#10
GPGME::ATTR_EMAIL = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#11
GPGME::ATTR_ERRTOK = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#12
GPGME::ATTR_EXPIRE = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#13
GPGME::ATTR_FPR = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#14
GPGME::ATTR_ISSUER = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#15
GPGME::ATTR_IS_SECRET = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#16
GPGME::ATTR_KEYID = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#17
GPGME::ATTR_KEY_CAPS = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#18
GPGME::ATTR_KEY_DISABLED = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#19
GPGME::ATTR_KEY_EXPIRED = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#20
GPGME::ATTR_KEY_INVALID = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#21
GPGME::ATTR_KEY_REVOKED = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#22
GPGME::ATTR_LEN = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#23
GPGME::ATTR_LEVEL = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#24
GPGME::ATTR_NAME = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#25
GPGME::ATTR_OTRUST = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#26
GPGME::ATTR_SERIAL = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#27
GPGME::ATTR_SIG_STATUS = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#28
GPGME::ATTR_SIG_SUMMARY = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#29
GPGME::ATTR_TYPE = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#30
GPGME::ATTR_UID_INVALID = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#31
GPGME::ATTR_UID_REVOKED = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#32
GPGME::ATTR_USERID = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#33
GPGME::ATTR_VALIDITY = T.let(T.unsafe(nil), Integer)

# Different, independent methods providing the simplest possible API to
# execute crypto operations via GPG. All methods accept as options the same
# common options as {GPGME::Ctx.new}. Read the documentation for that class to
# know how to customize things further (like output stuff in ASCII armored
# format, for example).
#
# @example
#   crypto = GPGME::Crypto.new :armor => true
#   encrypted = crypto.encrypt 'Plain text'
#
# source://gpgme//lib/gpgme/crypto.rb#14
class GPGME::Crypto
  # @return [Crypto] a new instance of Crypto
  #
  # source://gpgme//lib/gpgme/crypto.rb#18
  def initialize(options = T.unsafe(nil)); end

  # Clearsigns an element
  #
  #   crypto.clearsign text, options
  #
  # Same functionality of {.sign} only doing clearsigns by default.
  #
  # source://gpgme//lib/gpgme/crypto.rb#330
  def clearsign(text, options = T.unsafe(nil)); end

  # Decrypts a previously encrypted element
  #
  #   crypto.decrypt cipher, options, &block
  #
  # Must have the appropiate key to be able to decrypt, of course. Returns
  # a {GPGME::Data} object which can then be read.
  #
  # @example symmetric encryption, or passwored key
  #   crypto.decrypt encrypted_data, :password => "gpgme"
  # @example Simple decrypt
  #   crypto.decrypt encrypted_data
  # @example Output to file
  #   file = File.open("decrypted.txt", "w+")
  #   crypto.decrypt encrypted_data, :output => file
  # @example Verifying signatures
  #   crypto.decrypt encrypted_data do |signature|
  #   raise "Signature could not be verified" unless signature.valid?
  #   end
  # @param options [Hash] The optional parameters:
  #   * +:output+ if specified, it will write the output into it. It will
  #   me converted to a {GPGME::Data} object, so it can also be a file,
  #   for example.
  #   * If the file was encrypted with symmetric encryption, must provide
  #   a :password option.
  #   * Any other option accepted by {GPGME::Ctx.new}
  # @param cipher Must be something that can be converted into a {GPGME::Data} object,
  #   or a {GPGME::Data} object itself. It is the element that will be
  #   decrypted.
  # @param &block In the block all the signatures are yielded, so one could verify them.
  #   See examples.
  # @raise [GPGME::Error::UnsupportedAlgorithm] when the cipher was encrypted
  #   using an algorithm that's not supported currently.
  # @raise [GPGME::Error::WrongKeyUsage] TODO Don't know when
  # @raise [GPGME::Error::DecryptFailed] when the cipher was encrypted
  #   for a key that's not available currently.
  # @return [GPGME::Data] a {GPGME::Data} that can be read.
  #
  # source://gpgme//lib/gpgme/crypto.rb#164
  def decrypt(cipher, options = T.unsafe(nil)); end

  # Returns the value of attribute default_options.
  #
  # source://gpgme//lib/gpgme/crypto.rb#16
  def default_options; end

  # Creates a detached signature of an element
  #
  #   crypto.detach_sign text, options
  #
  # Same functionality of {.sign} only doing detached signs by default.
  #
  # source://gpgme//lib/gpgme/crypto.rb#340
  def detach_sign(text, options = T.unsafe(nil)); end

  # Encrypts an element
  #
  #  crypto.encrypt something, options
  #
  # Will return a {GPGME::Data} element which can then be read.
  #
  # Must have some key imported, look for {GPGME::Key.import} to know how
  # to import one, or the gpg documentation to know how to create one
  #
  # @example returns a {GPGME::Data} that can be later encrypted
  #   encrypted = crypto.encrypt "Hello world!"
  #   encrypted.read # => Encrypted stuff
  # @example to be decrypted by someone@example.com.
  #   crypto.encrypt "Hello", :recipients => "someone@example.com"
  # @example If I didn't trust any of my keys by default
  #   crypto.encrypt "Hello" # => GPGME::Error::General
  #   crypto.encrypt "Hello", :always_trust => true # => Will work fine
  # @example encrypted string that can be decrypted and/or *verified*
  #   crypto.encrypt "Hello", :sign => true
  # @example multiple signers
  #   crypto.encrypt "Hello", :sign => true, :signers => "extra@example.com"
  # @example writing to a file instead
  #   file = File.open("signed.sec","w+")
  #   crypto.encrypt "Hello", :output => file # output written to signed.sec
  # @param plain Must be something that can be converted into a {GPGME::Data} object, or
  #   a {GPGME::Data} object itself.
  # @param options [Hash] The optional parameters are as follows:
  #   * +:recipients+ for which recipient do you want to encrypt this file. It
  #   will pick the first one available if none specified. Can be an array of
  #   identifiers or just one (a string).
  #   * +:symmetric+ if set to true, will ignore +:recipients+, and will perform
  #   a symmetric encryption. Must provide a password via the +:password+
  #   option.
  #   * +:always_trust+ if set to true specifies all the recipients to be
  #   trusted, thus not requiring confirmation.
  #   * +:sign+ if set to true, performs a combined sign and encrypt operation.
  #   * +:signers+ if +:sign+ specified to true, a list of additional possible
  #   signers. Must be an array of sign identifiers.
  #   * +:output+ if specified, it will write the output into it. It will be
  #   converted to a {GPGME::Data} object, so it could be a file for example.
  #   * Any other option accepted by {GPGME::Ctx.new}
  # @raise [GPGME::Error::General] when trying to encrypt with a key that is
  #   not trusted, and +:always_trust+ wasn't specified
  # @return [GPGME::Data] a {GPGME::Data} object that can be read.
  #
  # source://gpgme//lib/gpgme/crypto.rb#79
  def encrypt(plain, options = T.unsafe(nil)); end

  # Creates a signature of a text
  #
  #   crypto.sign text, options
  #
  # Must have the appropiate key to be able to decrypt, of course. Returns
  # a {GPGME::Data} object which can then be read.
  #
  # @example normal sign
  #   crypto.sign "Hi there"
  # @example outputing to a file
  #   file = File.open("text.sign", "w+")
  #   crypto.sign "Hi there", :options => file
  # @example doing a detached signature
  #   crypto.sign "Hi there", :mode => GPGME::SIG_MODE_DETACH
  # @example specifying the signer
  #   crypto.sign "Hi there", :signer => "mrsimo@example.com"
  # @param text The object that will be signed. Must be something that can be converted
  #   to {GPGME::Data}.
  # @param options [Hash] Optional parameters.
  #   * +:signer+ sign identifier to sign the text with. Will use the first
  #   key it finds if none specified.
  #   * +:output+ if specified, it will write the output into it. It will be
  #   converted to a {GPGME::Data} object, so it could be a file for example.
  #   * +:mode+ Desired type of signature. Options are:
  #   - +GPGME::SIG_MODE_NORMAL+ for a normal signature. The default one if
  #   not specified.
  #   - +GPGME::SIG_MODE_DETACH+ for a detached signature
  #   - +GPGME::SIG_MODE_CLEAR+ for a cleartext signature
  #   * Any other option accepted by {GPGME::Ctx.new}
  # @raise [GPGME::Error::UnusableSecretKey] TODO don't know when
  # @return [GPGME::Data] a {GPGME::Data} that can be read.
  #
  # source://gpgme//lib/gpgme/crypto.rb#235
  def sign(text, options = T.unsafe(nil)); end

  # Verifies a previously signed element
  #
  #   crypto.verify sig, options, &block
  #
  # Must have the proper keys available.
  #
  # @example simple verification
  #   sign = crypto.sign("Hi there")
  #   data = crypto.verify(sign) { |signature| signature.valid? }
  #   data.read # => "Hi there"
  # @example saving output to file
  #   sign = crypto.sign("Hi there")
  #   out  = File.open("test.asc", "w+")
  #   crypto.verify(sign, :output => out) {|signature| signature.valid?}
  #   out.read # => "Hi there"
  # @example verifying a detached signature
  #   sign = crypto.detach_sign("Hi there")
  #   # Will fail
  #   crypto.verify(sign) { |signature| signature.valid? }
  #   # Will succeed
  #   crypto.verify(sign, :signed_text => "hi there") do |signature|
  #   signature.valid?
  #   end
  # @param sig The signature itself. Must be possible to convert into a {GPGME::Data}
  #   object, so can be a file.
  # @param options [Hash] * +:signed_text+ if the sign is detached, then must be the plain text
  #   for which the signature was created.
  #   * +:output+ where to store the result of the signature. Will be
  #   converted to a {GPGME::Data} object.
  #   * Any other option accepted by {GPGME::Ctx.new}
  # @param &block In the block all the signatures are yielded, so one could verify them.
  #   See examples.
  # @return [GPGME::Data] unless the sign is detached, the {GPGME::Data}
  #   object with the plain text. If the sign is detached, will return nil.
  #
  # source://gpgme//lib/gpgme/crypto.rb#304
  def verify(sig, options = T.unsafe(nil)); end

  class << self
    # Allows calling of methods directly in the module without the need to
    # create a new instance.
    #
    # source://gpgme//lib/gpgme/crypto.rb#347
    def method_missing(method, *args, &block); end
  end
end

# A context within which all cryptographic operations are performed.
#
# More operations can be done which are not available in the higher level
# API. Note how to create a new instance of this class in {GPGME::Ctx.new}.
#
# source://gpgme//lib/gpgme/ctx.rb#9
class GPGME::Ctx
  # Add _keys_ to the list of signers.
  #
  # source://gpgme//lib/gpgme/ctx.rb#461
  def add_signer(*keys); end

  # Return true if the output is ASCII armored.
  #
  # source://gpgme//lib/gpgme/ctx.rb#127
  def armor; end

  # Tell whether the output should be ASCII armored.
  #
  # source://gpgme//lib/gpgme/ctx.rb#121
  def armor=(yes); end

  # Edit attributes of the key on the card.
  #
  # source://gpgme//lib/gpgme/ctx.rb#412
  def card_edit(key, editfunc, hook_value = T.unsafe(nil), out = T.unsafe(nil)); end

  # Remove the list of signers from this object.
  #
  # source://gpgme//lib/gpgme/ctx.rb#456
  def clear_signers; end

  # Decrypt the ciphertext and return the plaintext.
  #
  # source://gpgme//lib/gpgme/ctx.rb#425
  def decrypt(cipher, plain = T.unsafe(nil)); end

  # source://gpgme//lib/gpgme/ctx.rb#439
  def decrypt_result; end

  # source://gpgme//lib/gpgme/ctx.rb#432
  def decrypt_verify(cipher, plain = T.unsafe(nil)); end

  # Delete the key from the key ring.
  # If allow_secret is false, only public keys are deleted,
  # otherwise secret keys are deleted as well.
  #
  # source://gpgme//lib/gpgme/ctx.rb#396
  def delete(key, allow_secret = T.unsafe(nil)); end

  # Delete the key from the key ring.
  # If allow_secret is false, only public keys are deleted,
  # otherwise secret keys are deleted as well.
  #
  # source://gpgme//lib/gpgme/ctx.rb#396
  def delete_key(key, allow_secret = T.unsafe(nil)); end

  # Convenient method to iterate over keys.
  #
  # If +pattern+ is +nil+, all available keys are returned. If +secret_only+
  # is +true+, only secret keys are returned.
  #
  # See {GPGME::Key.find} for an example of how to use, or for an easier way
  # to use.
  #
  # source://gpgme//lib/gpgme/ctx.rb#305
  def each_key(pattern = T.unsafe(nil), secret_only = T.unsafe(nil), &block); end

  # Convenient method to iterate over keys.
  #
  # If +pattern+ is +nil+, all available keys are returned. If +secret_only+
  # is +true+, only secret keys are returned.
  #
  # See {GPGME::Key.find} for an example of how to use, or for an easier way
  # to use.
  #
  # source://gpgme//lib/gpgme/ctx.rb#305
  def each_keys(pattern = T.unsafe(nil), secret_only = T.unsafe(nil), &block); end

  # Edit attributes of the key in the local key ring.
  #
  # source://gpgme//lib/gpgme/ctx.rb#404
  def edit(key, editfunc, hook_value = T.unsafe(nil), out = T.unsafe(nil)); end

  # Edit attributes of the key on the card.
  #
  # source://gpgme//lib/gpgme/ctx.rb#412
  def edit_card(key, editfunc, hook_value = T.unsafe(nil), out = T.unsafe(nil)); end

  # Edit attributes of the key on the card.
  #
  # source://gpgme//lib/gpgme/ctx.rb#412
  def edit_card_key(key, editfunc, hook_value = T.unsafe(nil), out = T.unsafe(nil)); end

  # Edit attributes of the key in the local key ring.
  #
  # source://gpgme//lib/gpgme/ctx.rb#404
  def edit_key(key, editfunc, hook_value = T.unsafe(nil), out = T.unsafe(nil)); end

  # Encrypt the plaintext in the data object for the recipients and
  # return the ciphertext.
  #
  # source://gpgme//lib/gpgme/ctx.rb#485
  def encrypt(recp, plain, cipher = T.unsafe(nil), flags = T.unsafe(nil)); end

  # source://gpgme//lib/gpgme/ctx.rb#492
  def encrypt_result; end

  # source://gpgme//lib/gpgme/ctx.rb#496
  def encrypt_sign(recp, plain, cipher = T.unsafe(nil), flags = T.unsafe(nil)); end

  # Extract the public keys that match the +recipients+. Returns a
  # {GPGME::Data} object which is not rewinded (should do +seek(0)+
  # before reading).
  #
  # Private keys cannot be exported due to GPGME restrictions.
  #
  # If passed, the key will be exported to +keydata+, which must be
  # a {GPGME::Data} object.
  #
  # source://gpgme//lib/gpgme/ctx.rb#373
  def export(recipients, keydata = T.unsafe(nil), mode = T.unsafe(nil)); end

  # Extract the public keys that match the +recipients+. Returns a
  # {GPGME::Data} object which is not rewinded (should do +seek(0)+
  # before reading).
  #
  # Private keys cannot be exported due to GPGME restrictions.
  #
  # If passed, the key will be exported to +keydata+, which must be
  # a {GPGME::Data} object.
  #
  # source://gpgme//lib/gpgme/ctx.rb#373
  def export_keys(recipients, keydata = T.unsafe(nil), mode = T.unsafe(nil)); end

  # Generate a new key pair.
  # +parms+ is a string which looks like
  #
  #  <GnupgKeyParms format="internal">
  #  Key-Type: DSA
  #  Key-Length: 1024
  #  Subkey-Type: ELG-E
  #  Subkey-Length: 1024
  #  Name-Real: Joe Tester
  #  Name-Comment: with stupid passphrase
  #  Name-Email: joe@foo.bar
  #  Expire-Date: 0
  #  Passphrase: abc
  #  </GnupgKeyParms>
  #
  # If +pubkey+ and +seckey+ are both set to +nil+, it stores the generated
  # key pair into your key ring.
  #
  # source://gpgme//lib/gpgme/ctx.rb#358
  def generate_key(parms, pubkey = T.unsafe(nil), seckey = T.unsafe(nil)); end

  # Generate a new key pair.
  # +parms+ is a string which looks like
  #
  #  <GnupgKeyParms format="internal">
  #  Key-Type: DSA
  #  Key-Length: 1024
  #  Subkey-Type: ELG-E
  #  Subkey-Length: 1024
  #  Name-Real: Joe Tester
  #  Name-Comment: with stupid passphrase
  #  Name-Email: joe@foo.bar
  #  Expire-Date: 0
  #  Passphrase: abc
  #  </GnupgKeyParms>
  #
  # If +pubkey+ and +seckey+ are both set to +nil+, it stores the generated
  # key pair into your key ring.
  #
  # source://gpgme//lib/gpgme/ctx.rb#358
  def genkey(parms, pubkey = T.unsafe(nil), seckey = T.unsafe(nil)); end

  # Get the key with the +fingerprint+.
  # If +secret+ is +true+, secret key is returned.
  #
  # source://gpgme//lib/gpgme/ctx.rb#329
  def get_key(fingerprint, secret = T.unsafe(nil)); end

  # Add the keys in the data buffer to the key ring.
  #
  # source://gpgme//lib/gpgme/ctx.rb#382
  def import(keydata); end

  # Add the keys in the data buffer to the key ring.
  #
  # source://gpgme//lib/gpgme/ctx.rb#382
  def import_keys(keydata); end

  # source://gpgme//lib/gpgme/ctx.rb#389
  def import_result; end

  # source://gpgme//lib/gpgme/ctx.rb#510
  def inspect; end

  # End a pending key list operation.
  #
  # Used by {GPGME::Ctx#each_key}
  #
  # source://gpgme//lib/gpgme/ctx.rb#292
  def keylist_end; end

  # Return the current key listing mode.
  #
  # source://gpgme//lib/gpgme/ctx.rb#149
  def keylist_mode; end

  # Change the default behaviour of the key listing functions.
  #
  # source://gpgme//lib/gpgme/ctx.rb#143
  def keylist_mode=(mode); end

  # Advance to the next key in the key listing operation.
  #
  # Used by {GPGME::Ctx#each_key}
  #
  # source://gpgme//lib/gpgme/ctx.rb#281
  def keylist_next; end

  # Initiate a key listing operation for given pattern. If +pattern+ is
  # +nil+, all available keys are returned. If +secret_only<+ is +true+,
  # only secret keys are returned.
  #
  # Used by {GPGME::Ctx#each_key}
  #
  # source://gpgme//lib/gpgme/ctx.rb#272
  def keylist_start(pattern = T.unsafe(nil), secret_only = T.unsafe(nil)); end

  # Returns the keys that match the +pattern+, or all if +pattern+ is nil.
  # Returns only secret keys if +secret_only+ is true.
  #
  # source://gpgme//lib/gpgme/ctx.rb#319
  def keys(pattern = T.unsafe(nil), secret_only = T.unsafe(nil)); end

  # Return the current offline mode.
  #
  # source://gpgme//lib/gpgme/ctx.rb#172
  def offline; end

  # Change the default behaviour of the dirmngr that might require
  # connections to external services.
  #
  # source://gpgme//lib/gpgme/ctx.rb#166
  def offline=(mode); end

  # Return the current pinentry mode.
  #
  # source://gpgme//lib/gpgme/ctx.rb#160
  def pinentry_mode; end

  # Change the default behaviour of the pinentry invocation.
  #
  # source://gpgme//lib/gpgme/ctx.rb#154
  def pinentry_mode=(mode); end

  # Return the +protocol+ used within this context.
  #
  # source://gpgme//lib/gpgme/ctx.rb#116
  def protocol; end

  # Set the +protocol+ used within this context. See {GPGME::Ctx.new} for
  # possible values.
  #
  # source://gpgme//lib/gpgme/ctx.rb#108
  def protocol=(proto); end

  # Releases the Ctx instance. Must be called if it was initialized without
  # a block.
  #
  # @example
  #   ctx = GPGME::Ctx.new
  #   # operate on ctx
  #   ctx.release
  #
  # source://gpgme//lib/gpgme/ctx.rb#98
  def release; end

  # Set the passphrase callback with given hook value.
  # +passfunc+ should respond to +call+ with 5 arguments.
  #
  # * +obj+ the parameter +:passphrase_callback_value+ passed when creating
  #   the {GPGME::Ctx} object.
  # * +uid_hint+ hint as to what key are we asking the password for. Ex:
  #
  #   +CFB3294A50C2CFD7 Albert Llop <mrsimo@example.com>+
  #
  # * +passphrase_info+
  # * +prev_was_bad+ 0 if it's the first time the password is being asked,
  #   1 otherwise.
  # * +fd+ file descriptor where the password must be written too.
  #
  # Expects a Method object which can be obtained by the +method+ method
  # (really..).
  #
  #  ctx.set_passphrase_callback(MyModule.method(:passfunc))
  #
  # Note that this function doesn't work with GnuPG 2.0.  You can
  # use either GnuPG 1.x, which can be installed in parallel with
  # GnuPG 2.0, or GnuPG 2.1, which has loopback pinentry feature (see
  # {#pinentry_mode}).
  #
  # @example this method will simply return +maria+ as password.
  #   def pass_function(obj, uid_hint, passphrase_info, prev_was_bad, fd)
  #   io = IO.for_fd(fd, 'w')
  #   io.puts "maria"
  #   io.flush
  #   end
  # @example this will interactively ask for the password
  #   def passfunc(obj, uid_hint, passphrase_info, prev_was_bad, fd)
  #   $stderr.write("Passphrase for #{uid_hint}: ")
  #   $stderr.flush
  #   begin
  #   system('stty -echo')
  #   io = IO.for_fd(fd, 'w')
  #   io.puts(gets)
  #   io.flush
  #   ensure
  #   (0 ... $_.length).each do |i| $_[i] = ?0 end if $_
  #   system('stty echo')
  #   end
  #   $stderr.puts
  #   end
  #
  # source://gpgme//lib/gpgme/ctx.rb#226
  def set_passphrase_callback(passfunc, hook_value = T.unsafe(nil)); end

  # Set the passphrase callback with given hook value.
  # +passfunc+ should respond to +call+ with 5 arguments.
  #
  # * +obj+ the parameter +:passphrase_callback_value+ passed when creating
  #   the {GPGME::Ctx} object.
  # * +uid_hint+ hint as to what key are we asking the password for. Ex:
  #
  #   +CFB3294A50C2CFD7 Albert Llop <mrsimo@example.com>+
  #
  # * +passphrase_info+
  # * +prev_was_bad+ 0 if it's the first time the password is being asked,
  #   1 otherwise.
  # * +fd+ file descriptor where the password must be written too.
  #
  # Expects a Method object which can be obtained by the +method+ method
  # (really..).
  #
  #  ctx.set_passphrase_callback(MyModule.method(:passfunc))
  #
  # Note that this function doesn't work with GnuPG 2.0.  You can
  # use either GnuPG 1.x, which can be installed in parallel with
  # GnuPG 2.0, or GnuPG 2.1, which has loopback pinentry feature (see
  # {#pinentry_mode}).
  #
  # @example this method will simply return +maria+ as password.
  #   def pass_function(obj, uid_hint, passphrase_info, prev_was_bad, fd)
  #   io = IO.for_fd(fd, 'w')
  #   io.puts "maria"
  #   io.flush
  #   end
  # @example this will interactively ask for the password
  #   def passfunc(obj, uid_hint, passphrase_info, prev_was_bad, fd)
  #   $stderr.write("Passphrase for #{uid_hint}: ")
  #   $stderr.flush
  #   begin
  #   system('stty -echo')
  #   io = IO.for_fd(fd, 'w')
  #   io.puts(gets)
  #   io.flush
  #   ensure
  #   (0 ... $_.length).each do |i| $_[i] = ?0 end if $_
  #   system('stty echo')
  #   end
  #   $stderr.puts
  #   end
  #
  # source://gpgme//lib/gpgme/ctx.rb#226
  def set_passphrase_cb(passfunc, hook_value = T.unsafe(nil)); end

  # Set the progress callback with given hook value.
  # <i>progfunc</i> should respond to <code>call</code> with 5 arguments.
  #
  #  def progfunc(hook, what, type, current, total)
  #    $stderr.write("#{what}: #{current}/#{total}\r")
  #    $stderr.flush
  #  end
  #
  #  ctx.set_progress_callback(method(:progfunc))
  #
  # source://gpgme//lib/gpgme/ctx.rb#241
  def set_progress_callback(progfunc, hook_value = T.unsafe(nil)); end

  # Set the progress callback with given hook value.
  # <i>progfunc</i> should respond to <code>call</code> with 5 arguments.
  #
  #  def progfunc(hook, what, type, current, total)
  #    $stderr.write("#{what}: #{current}/#{total}\r")
  #    $stderr.flush
  #  end
  #
  #  ctx.set_progress_callback(method(:progfunc))
  #
  # source://gpgme//lib/gpgme/ctx.rb#241
  def set_progress_cb(progfunc, hook_value = T.unsafe(nil)); end

  # Set the status callback with given hook value.
  # +statusfunc+ should respond to +call+ with 3 arguments.
  #
  # * +obj+ the parameter +:status_callback_value+ passed when creating
  #   the {GPGME::Ctx} object.
  # * +keyword+ the name of the status message
  # * +args+ any arguments for the status message
  #
  #  def status_function(obj, keyword, args)
  #    $stderr.puts("#{keyword} #{args}")
  #    return 0
  #  end
  #
  # source://gpgme//lib/gpgme/ctx.rb#258
  def set_status_callback(statusfunc, hook_value = T.unsafe(nil)); end

  # Set the status callback with given hook value.
  # +statusfunc+ should respond to +call+ with 3 arguments.
  #
  # * +obj+ the parameter +:status_callback_value+ passed when creating
  #   the {GPGME::Ctx} object.
  # * +keyword+ the name of the status message
  # * +args+ any arguments for the status message
  #
  #  def status_function(obj, keyword, args)
  #    $stderr.puts("#{keyword} #{args}")
  #    return 0
  #  end
  #
  # source://gpgme//lib/gpgme/ctx.rb#258
  def set_status_cb(statusfunc, hook_value = T.unsafe(nil)); end

  # Create a signature for the text.
  # +plain+ is a data object which contains the text.
  # +sig+ is a data object where the generated signature is stored.
  #
  # source://gpgme//lib/gpgme/ctx.rb#472
  def sign(plain, sig = T.unsafe(nil), mode = T.unsafe(nil)); end

  # source://gpgme//lib/gpgme/ctx.rb#479
  def sign_result; end

  # source://gpgme//lib/gpgme/ctx.rb#503
  def spawn(file, argv, datain, dataout, dataerr, flags = T.unsafe(nil)); end

  # Return true if canonical text mode is enabled.
  #
  # source://gpgme//lib/gpgme/ctx.rb#138
  def textmode; end

  # Tell whether canonical text mode should be used.
  #
  # source://gpgme//lib/gpgme/ctx.rb#132
  def textmode=(yes); end

  # Verify that the signature in the data object is a valid signature.
  #
  # source://gpgme//lib/gpgme/ctx.rb#444
  def verify(sig, signed_text = T.unsafe(nil), plain = T.unsafe(nil)); end

  # source://gpgme//lib/gpgme/ctx.rb#451
  def verify_result; end

  class << self
    # Create a new instance from the given +options+. Must be released either
    # executing the operations inside a block, or executing {GPGME::Ctx#release}
    # afterwards.
    #
    # @example
    #   ctx = GPGME::Ctx.new
    #   # operate on ctx
    #   ctx.release
    # @example
    #   GPGME::Ctx.new do |ctx|
    #   # operate on ctx
    #   end
    # @param options [Hash] The optional parameters are as follows:
    #   * +:protocol+ Either +PROTOCOL_OpenPGP+ or +PROTOCOL_CMS+.
    #   * +:armor+ will return ASCII armored outputs if specified true.
    #   * +:textmode+ if +true+, inform the recipient that the input is text.
    #   * +:keylist_mode+ One of: +KEYLIST_MODE_LOCAL+, +KEYLIST_MODE_EXTERN+,
    #   +KEYLIST_MODE_SIGS+ or +KEYLIST_MODE_VALIDATE+.
    #   * +:pinentry_mode+ One of: +PINENTRY_MODE_DEFAULT+,
    #   +PINENTRY_MODE_ASK+, +PINENTRY_MODE_CANCEL+,
    #   +PINENTRY_MODE_ERROR+, or +PINENTRY_MODE_LOOPBACK+.
    #   * +:offline+ if set to true, dirmngr will not contact external services
    #   * +:password+ password of the passphrased password being used.
    #   * +:passphrase_callback+ A callback function. See {#set_passphrase_callback}.
    #   * +:passphrase_callback_value+ An object passed to passphrase_callback.
    #   * +:progress_callback+  A callback function. See {#set_progress_callback}.
    #   * +:progress_callback_value+ An object passed to progress_callback.
    #   * +:status_callback+ A callback function. See {#set_status_callback}.
    #   * +:status_callback_value+ An object passed to status_callback.
    #
    # source://gpgme//lib/gpgme/ctx.rb#45
    def new(options = T.unsafe(nil)); end

    # source://gpgme//lib/gpgme/ctx.rb#518
    def pass_function(pass, uid_hint, passphrase_info, prev_was_bad, fd); end
  end
end

# source://gpgme//lib/gpgme/constants.rb#34
GPGME::DATA_ENCODING_ARMOR = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#35
GPGME::DATA_ENCODING_BASE64 = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#36
GPGME::DATA_ENCODING_BINARY = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#37
GPGME::DATA_ENCODING_NONE = T.let(T.unsafe(nil), Integer)

# A class whose purpose is to unify the way we work with the data (both input
# and output). Most of the calls expect instances of this class, or will try
# to create one from your parameters.
#
# Read the {#read}, {#write} and {#seek} methods for the most commonly used
# methods.
#
# source://gpgme//lib/gpgme/data.rb#10
class GPGME::Data
  # Return the encoding of the underlying data.
  #
  # source://gpgme//lib/gpgme/data.rb#163
  def encoding; end

  # Sets the encoding for this buffer. Accepts only integer values 0 to 7:
  #
  # 0 = GPGME_DATA_ENCODING_NONE   (Not specified)
  # 1 = GPGME_DATA_ENCODING_BINARY
  # 2 = GPGME_DATA_ENCODING_BASE64
  # 3 = GPGME_DATA_ENCODING_ARMOR  (Either PEM or OpenPGP Armor)
  # 4 = GPGME_DATA_ENCODING_URL    (LF delimited URL list)
  # 5 = GPGME_DATA_ENCODING_URLESC (Ditto, but percent escaped)
  # 6 = GPGME_DATA_ENCODING_URL0   (Nul delimited URL list)
  # 7 = GPGME_DATA_ENCODING_MIME   (Data is a MIME part)
  #
  # @raise [GPGME::Error::InvalidValue] if the value isn't accepted.
  #
  # source://gpgme//lib/gpgme/data.rb#180
  def encoding=(encoding); end

  # Return the file name of the underlying data.
  #
  # source://gpgme//lib/gpgme/data.rb#189
  def file_name; end

  # Sets the file name for this buffer.
  #
  # @raise [GPGME::Error::InvalidValue] if the value isn't accepted.
  #
  # source://gpgme//lib/gpgme/data.rb#197
  def file_name=(file_name); end

  # Read at most +length+ bytes from the data object, or to the end
  # of file if +length+ is omitted or is +nil+.
  #
  # @example
  #   data = GPGME::Data.new("From a string")
  #   data.read # => "From a string"
  # @example
  #   data = GPGME::Data.new("From a string")
  #   data.read(4) # => "From"
  #
  # source://gpgme//lib/gpgme/data.rb#112
  def read(length = T.unsafe(nil)); end

  # Seek to a given +offset+ in the data object according to the
  # value of +whence+.
  #
  # @example going to the beginning of the buffer after writing something
  #   data = GPGME::Data.new("Some data")
  #   data.read # => "Some data"
  #   data.read # => ""
  #   data.seek 0
  #   data.read # => "Some data"
  #
  # source://gpgme//lib/gpgme/data.rb#137
  def seek(offset, whence = T.unsafe(nil)); end

  # Return the entire content of the data object as string.
  #
  # source://gpgme//lib/gpgme/data.rb#206
  def to_s; end

  # Writes +length+ bytes from +buffer+ into the data object.
  # Writes the full buffer if no length passed.
  #
  # @example
  #   data = GPGME::Data.new
  #   data.write "hola"
  #   data.seek 0
  #   data.read # => "hola"
  # @example
  #   data = GPGME::Data.new
  #   data.write "hola", 2
  #   data.seek 0
  #   data.read # => "ho"
  #
  # source://gpgme//lib/gpgme/data.rb#157
  def write(buffer, length = T.unsafe(nil)); end

  class << self
    # Create a new instance with an empty buffer.
    #
    # source://gpgme//lib/gpgme/data.rb#60
    def empty!; end

    # Create a new instance from the specified callbacks.
    #
    # source://gpgme//lib/gpgme/data.rb#92
    def from_callbacks(callbacks, hook_value = T.unsafe(nil)); end

    # Create a new instance from the specified file descriptor.
    #
    # source://gpgme//lib/gpgme/data.rb#83
    def from_fd(fd); end

    # Create a new instance associated with a given IO.
    #
    # source://gpgme//lib/gpgme/data.rb#78
    def from_io(io); end

    # Create a new instance with internal buffer.
    #
    # source://gpgme//lib/gpgme/data.rb#69
    def from_str(string); end

    # We implement +self.new+ instead of initialize because objects are actually
    # instantiated through the C API with stuff like +gpgme_data_new+.
    #
    # We try to create a {GPGME::Data} smartly depending on the object passed, and if
    # another {GPGME::Data} object is passed, it just returns it, so when in
    # doubt, you can always pass a {GPGME::Data} object.
    #
    # @example empty
    #   data = GPGME::Data.new
    #   data.write("stuff")
    # @example from a string
    #   data = GPGME::Data.new("From a string")
    # @example from a file
    #   data = GPGME::Data.new(File.open("secure.pass"))
    # @example from a file descriptor
    #   data = GPGME::Data.new(0) # Standard input
    #   data = GPGME::Data.new(1) # Standard output
    #
    #   file = File.open("secure.pass")
    #   data = GPGME::Data.new(file.fileno) # file descriptor
    #
    # source://gpgme//lib/gpgme/data.rb#41
    def new(object = T.unsafe(nil)); end
  end
end

# source://gpgme//lib/gpgme/data.rb#12
GPGME::Data::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/misc.rb#21
class GPGME::DecryptResult
  # Returns the value of attribute file_name.
  #
  # source://gpgme//lib/gpgme/misc.rb#25
  def file_name; end

  # Returns the value of attribute recipients.
  #
  # source://gpgme//lib/gpgme/misc.rb#25
  def recipients; end

  # Returns the value of attribute unsupported_algorithm.
  #
  # source://gpgme//lib/gpgme/misc.rb#24
  def unsupported_algorithm; end

  # Returns the value of attribute wrong_key_usage.
  #
  # source://gpgme//lib/gpgme/misc.rb#24
  def wrong_key_usage; end

  class << self
    private

    def new(*_arg0); end
  end
end

# source://gpgme//lib/gpgme/constants.rb#38
GPGME::ENCRYPT_ALWAYS_TRUST = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#240
GPGME::EXPORT_MODE_EXTERN = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#244
GPGME::EXPORT_MODE_MINIMAL = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#250
GPGME::EXPORT_MODE_PKCS12 = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#249
GPGME::EXPORT_MODE_RAW = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#248
GPGME::EXPORT_MODE_SECRET = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/misc.rb#34
class GPGME::EncryptResult
  # Returns the value of attribute invalid_recipients.
  #
  # source://gpgme//lib/gpgme/misc.rb#37
  def invalid_recipients; end

  class << self
    private

    def new(*_arg0); end
  end
end

# Convenience methods to check different aspects of the gpg system
# installation.
#
# source://gpgme//lib/gpgme/engine.rb#6
module GPGME::Engine
  class << self
    # Verify that the engine implementing the protocol +proto+ is installed in
    # the system. Can be one of +PROTOCOL_OpenPGP+ or +PROTOCOL_CMS+.
    #
    # @example
    #   GPGME::Engine.check_version(GPGME::PROTOCOL_OpenPGP) # => true
    # @return [Boolean] true if the engine is installed.
    #
    # source://gpgme//lib/gpgme/engine.rb#18
    def check_version(proto); end

    # Return the default configuration.
    #
    # @example
    #   GPGME::Engine.dirinfo('homedir')
    #   # => '/home/user/.gnupg"
    #
    # source://gpgme//lib/gpgme/engine.rb#82
    def dirinfo(what); end

    # Sets the home dir for the configuration options. This way one could,
    # for example, load the keys from a customized keychain.
    #
    # @example
    #   GPGME::Engine.home_dir = '/tmp'
    #
    # source://gpgme//lib/gpgme/engine.rb#70
    def home_dir=(home_dir); end

    # Return an array of {GPGME::EngineInfo} structures of enabled engines.
    #
    # @example
    #   GPGME::Engine.info.first
    #   # => #<GPGME::EngineInfo:0x00000100d4fbd8
    #   @file_name="/usr/local/bin/gpg",
    #   @protocol=0,
    #   @req_version="1.3.0",
    #   @version="1.4.11">
    #
    # source://gpgme//lib/gpgme/engine.rb#35
    def info; end

    # Change the default configuration of the crypto engine implementing
    # protocol +proto+.
    #
    # @example
    #   GPGME::Engine.set_info(GPGME::PROTOCOL_OpenPGP, '/usr/local/bin/gpg', home_dir)
    # @param proto Can be one of +PROTOCOL_OpenPGP+ or +PROTOCOL_CMS+.
    # @param file_name The file name of the executable program implementing the protocol.
    # @param home_dir The directory name of the configuration directory.
    #
    # source://gpgme//lib/gpgme/engine.rb#57
    def set_info(proto, file_name, home_dir); end
  end
end

# source://gpgme//lib/gpgme/misc.rb#2
class GPGME::EngineInfo
  # Returns the value of attribute file_name.
  #
  # source://gpgme//lib/gpgme/misc.rb#5
  def file_name; end

  # Returns the value of attribute home_dir.
  #
  # source://gpgme//lib/gpgme/misc.rb#5
  def home_dir; end

  # Returns the value of attribute protocol.
  #
  # source://gpgme//lib/gpgme/misc.rb#5
  def protocol; end

  # Returns the value of attribute req_version.
  #
  # source://gpgme//lib/gpgme/misc.rb#5
  def req_version; end

  # Returns the value of attribute req_version.
  #
  # source://gpgme//lib/gpgme/misc.rb#5
  def required_version; end

  # Returns the value of attribute version.
  #
  # source://gpgme//lib/gpgme/misc.rb#5
  def version; end

  class << self
    private

    def new(*_arg0); end
  end
end

# source://gpgme//lib/gpgme/error.rb#2
class GPGME::Error < ::StandardError
  # @return [Error] a new instance of Error
  #
  # source://gpgme//lib/gpgme/error.rb#3
  def initialize(error); end

  # Return the error code.
  #
  # The error code indicates the type of an error, or the reason why
  # an operation failed.
  #
  # source://gpgme//lib/gpgme/error.rb#12
  def code; end

  # Returns the value of attribute error.
  #
  # source://gpgme//lib/gpgme/error.rb#6
  def error; end

  # Return a description of the error code.
  #
  # source://gpgme//lib/gpgme/error.rb#29
  def message; end

  # Return the error source.
  #
  # The error source has not a precisely defined meaning.  Sometimes
  # it is the place where the error happened, sometimes it is the
  # place where an error was encoded into an error value.  Usually
  # the error source will give an indication to where to look for
  # the problem.  This is not always true, but it is attempted to
  # achieve this goal.
  #
  # source://gpgme//lib/gpgme/error.rb#24
  def source; end
end

# source://gpgme//lib/gpgme/error.rb#48
class GPGME::Error::AmbiguousName < ::GPGME::Error; end

# source://gpgme//lib/gpgme/error.rb#58
class GPGME::Error::BadCertificateChain < ::GPGME::Error; end

# source://gpgme//lib/gpgme/error.rb#45
class GPGME::Error::BadPassphrase < ::GPGME::Error; end

# source://gpgme//lib/gpgme/error.rb#62
class GPGME::Error::BadSignature < ::GPGME::Error; end

# source://gpgme//lib/gpgme/error.rb#46
class GPGME::Error::Canceled < ::GPGME::Error; end

# source://gpgme//lib/gpgme/error.rb#53
class GPGME::Error::CertificateExpired < ::GPGME::Error; end

# source://gpgme//lib/gpgme/error.rb#52
class GPGME::Error::CertificateRevoked < ::GPGME::Error; end

# source://gpgme//lib/gpgme/error.rb#42
class GPGME::Error::Conflict < ::GPGME::Error; end

# source://gpgme//lib/gpgme/error.rb#44
class GPGME::Error::DecryptFailed < ::GPGME::Error; end

# source://gpgme//lib/gpgme/error.rb#33
class GPGME::Error::General < ::GPGME::Error; end

# source://gpgme//lib/gpgme/error.rb#47
class GPGME::Error::InvalidEngine < ::GPGME::Error; end

# source://gpgme//lib/gpgme/error.rb#34
class GPGME::Error::InvalidValue < ::GPGME::Error; end

# source://gpgme//lib/gpgme/error.rb#64
class GPGME::Error::InvalidVersion < ::GPGME::Error; end

# source://gpgme//lib/gpgme/error.rb#57
class GPGME::Error::MissingCertificate < ::GPGME::Error; end

# source://gpgme//lib/gpgme/error.rb#54
class GPGME::Error::NoCRLKnown < ::GPGME::Error; end

# source://gpgme//lib/gpgme/error.rb#41
class GPGME::Error::NoData < ::GPGME::Error; end

# source://gpgme//lib/gpgme/error.rb#55
class GPGME::Error::NoPolicyMatch < ::GPGME::Error; end

# source://gpgme//lib/gpgme/error.rb#63
class GPGME::Error::NoPublicKey < ::GPGME::Error; end

# source://gpgme//lib/gpgme/error.rb#56
class GPGME::Error::NoSecretKey < ::GPGME::Error; end

# source://gpgme//lib/gpgme/error.rb#43
class GPGME::Error::NotImplemented < ::GPGME::Error; end

# source://gpgme//lib/gpgme/error.rb#59
class GPGME::Error::UnsupportedAlgorithm < ::GPGME::Error
  # Returns the value of attribute algorithm.
  #
  # source://gpgme//lib/gpgme/error.rb#60
  def algorithm; end

  # Sets the attribute algorithm
  #
  # @param value the value to set the attribute algorithm to.
  #
  # source://gpgme//lib/gpgme/error.rb#60
  def algorithm=(_arg0); end
end

# source://gpgme//lib/gpgme/error.rb#35
class GPGME::Error::UnusablePublicKey < ::GPGME::Error
  # Returns the value of attribute keys.
  #
  # source://gpgme//lib/gpgme/error.rb#36
  def keys; end

  # Sets the attribute keys
  #
  # @param value the value to set the attribute keys to.
  #
  # source://gpgme//lib/gpgme/error.rb#36
  def keys=(_arg0); end
end

# source://gpgme//lib/gpgme/error.rb#38
class GPGME::Error::UnusableSecretKey < ::GPGME::Error
  # Returns the value of attribute keys.
  #
  # source://gpgme//lib/gpgme/error.rb#39
  def keys; end

  # Sets the attribute keys
  #
  # @param value the value to set the attribute keys to.
  #
  # source://gpgme//lib/gpgme/error.rb#39
  def keys=(_arg0); end
end

# source://gpgme//lib/gpgme/error.rb#49
class GPGME::Error::WrongKeyUsage < ::GPGME::Error
  # Returns the value of attribute key_usage.
  #
  # source://gpgme//lib/gpgme/error.rb#50
  def key_usage; end

  # Sets the attribute key_usage
  #
  # @param value the value to set the attribute key_usage to.
  #
  # source://gpgme//lib/gpgme/error.rb#50
  def key_usage=(_arg0); end
end

GPGME::GPGME_ATTR_ALGO = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_CAN_CERTIFY = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_CAN_ENCRYPT = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_CAN_SIGN = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_CHAINID = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_COMMENT = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_CREATED = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_EMAIL = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_ERRTOK = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_EXPIRE = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_FPR = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_ISSUER = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_IS_SECRET = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_KEYID = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_KEY_CAPS = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_KEY_DISABLED = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_KEY_EXPIRED = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_KEY_INVALID = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_KEY_REVOKED = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_LEN = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_LEVEL = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_NAME = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_OTRUST = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_SERIAL = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_SIG_STATUS = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_SIG_SUMMARY = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_TYPE = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_UID_INVALID = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_UID_REVOKED = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_USERID = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ATTR_VALIDITY = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_DATA_ENCODING_ARMOR = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_DATA_ENCODING_BASE64 = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_DATA_ENCODING_BINARY = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_DATA_ENCODING_NONE = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_ENCRYPT_ALWAYS_TRUST = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_EXPORT_MODE_EXTERN = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_EXPORT_MODE_MINIMAL = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_EXPORT_MODE_PKCS12 = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_EXPORT_MODE_RAW = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_EXPORT_MODE_SECRET = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_IMPORT_NEW = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_IMPORT_SECRET = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_IMPORT_SIG = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_IMPORT_SUBKEY = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_IMPORT_UID = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_KEYLIST_MODE_EPHEMERAL = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_KEYLIST_MODE_EXTERN = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_KEYLIST_MODE_LOCAL = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_KEYLIST_MODE_SIGS = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_KEYLIST_MODE_SIG_NOTATIONS = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_KEYLIST_MODE_VALIDATE = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_KEYLIST_MODE_WITH_SECRET = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_MD_CRC24_RFC2440 = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_MD_CRC32 = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_MD_CRC32_RFC1510 = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_MD_HAVAL = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_MD_MD2 = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_MD_MD4 = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_MD_MD5 = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_MD_RMD160 = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_MD_SHA1 = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_MD_SHA256 = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_MD_SHA384 = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_MD_SHA512 = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_MD_TIGER = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_PINENTRY_MODE_ASK = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_PINENTRY_MODE_CANCEL = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_PINENTRY_MODE_DEFAULT = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_PINENTRY_MODE_ERROR = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_PINENTRY_MODE_LOOPBACK = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_PK_DSA = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_PK_ELG = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_PK_ELG_E = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_PK_RSA = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_PROTOCOL_CMS = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_PROTOCOL_OpenPGP = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_SIGSUM_BAD_POLICY = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_SIGSUM_CRL_MISSING = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_SIGSUM_CRL_TOO_OLD = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_SIGSUM_GREEN = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_SIGSUM_KEY_EXPIRED = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_SIGSUM_KEY_MISSING = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_SIGSUM_KEY_REVOKED = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_SIGSUM_RED = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_SIGSUM_SIG_EXPIRED = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_SIGSUM_SYS_ERROR = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_SIGSUM_VALID = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_SIG_MODE_CLEAR = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_SIG_MODE_DETACH = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_SIG_MODE_NORMAL = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_SIG_STAT_BAD = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_SIG_STAT_DIFF = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_SIG_STAT_ERROR = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_SIG_STAT_GOOD = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_SIG_STAT_GOOD_EXP = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_SIG_STAT_GOOD_EXPKEY = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_SIG_STAT_NOKEY = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_SIG_STAT_NONE = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_SIG_STAT_NOSIG = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_SPAWN_ALLOW_SET_FG = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_SPAWN_DETACHED = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_ABORT = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_ALREADY_SIGNED = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_ATTRIBUTE = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_BADARMOR = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_BADMDC = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_BADSIG = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_BAD_PASSPHRASE = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_BEGIN_DECRYPTION = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_BEGIN_ENCRYPTION = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_BEGIN_SIGNING = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_BEGIN_STREAM = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_DECRYPTION_FAILED = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_DECRYPTION_OKAY = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_DELETE_PROBLEM = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_ENC_TO = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_END_DECRYPTION = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_END_ENCRYPTION = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_END_STREAM = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_ENTER = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_EOF = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_ERRMDC = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_ERROR = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_ERRSIG = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_EXPKEYSIG = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_EXPSIG = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_FILE_DONE = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_FILE_ERROR = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_FILE_START = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_GET_BOOL = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_GET_HIDDEN = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_GET_LINE = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_GOODMDC = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_GOODSIG = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_GOOD_PASSPHRASE = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_GOT_IT = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_IMPORTED = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_IMPORT_RES = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_INV_RECP = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_KEYEXPIRED = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_KEYREVOKED = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_KEY_CREATED = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_KEY_NOT_CREATED = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_LEAVE = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_MISSING_PASSPHRASE = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_MOUNTPOINT = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_NEED_PASSPHRASE = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_NEED_PASSPHRASE_SYM = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_NODATA = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_NOTATION_DATA = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_NOTATION_NAME = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_NO_PUBKEY = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_NO_RECP = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_NO_SECKEY = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_PINENTRY_LAUNCHED = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_PLAINTEXT_LENGTH = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_POLICY_URL = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_PROGRESS = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_RSA_OR_IDEA = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_SESSION_KEY = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_SHM_GET = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_SHM_GET_BOOL = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_SHM_GET_HIDDEN = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_SHM_INFO = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_SIGEXPIRED = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_SIG_CREATED = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_SIG_ID = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_TRUNCATED = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_TRUST_FULLY = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_TRUST_MARGINAL = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_TRUST_NEVER = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_TRUST_ULTIMATE = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_TRUST_UNDEFINED = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_UNEXPECTED = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_USERID_HINT = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_STATUS_VALIDSIG = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_VALIDITY_FULL = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_VALIDITY_MARGINAL = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_VALIDITY_NEVER = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_VALIDITY_ULTIMATE = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_VALIDITY_UNDEFINED = T.let(T.unsafe(nil), Integer)
GPGME::GPGME_VALIDITY_UNKNOWN = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_AMBIGUOUS_NAME = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_BAD_CERT_CHAIN = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_BAD_PASSPHRASE = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_BAD_SIGNATURE = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_CANCELED = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_CERT_EXPIRED = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_CERT_REVOKED = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_CONFLICT = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_DECRYPT_FAILED = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_ENOMEM = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_EOF = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_GENERAL = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_INV_ENGINE = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_INV_VALUE = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_KEY_EXPIRED = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_MISSING_CERT = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_NOT_IMPLEMENTED = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_NO_CRL_KNOWN = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_NO_DATA = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_NO_ERROR = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_NO_POLICY_MATCH = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_NO_PUBKEY = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_NO_SECKEY = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_SIG_EXPIRED = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_SOURCE_GCRYPT = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_SOURCE_GPG = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_SOURCE_GPGAGENT = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_SOURCE_GPGME = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_SOURCE_GPGSM = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_SOURCE_KEYBOX = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_SOURCE_PINENTRY = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_SOURCE_SCD = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_SOURCE_UNKNOWN = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_SOURCE_USER_1 = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_SOURCE_USER_2 = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_SOURCE_USER_3 = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_SOURCE_USER_4 = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_UNSUPPORTED_ALGORITHM = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_UNUSABLE_PUBKEY = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_UNUSABLE_SECKEY = T.let(T.unsafe(nil), Integer)
GPGME::GPG_ERR_WRONG_KEY_USAGE = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#42
GPGME::IMPORT_NEW = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#43
GPGME::IMPORT_SECRET = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#44
GPGME::IMPORT_SIG = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#45
GPGME::IMPORT_SUBKEY = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#46
GPGME::IMPORT_UID = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/io_callbacks.rb#2
class GPGME::IOCallbacks
  # @return [IOCallbacks] a new instance of IOCallbacks
  #
  # source://gpgme//lib/gpgme/io_callbacks.rb#3
  def initialize(io); end

  # source://gpgme//lib/gpgme/io_callbacks.rb#7
  def read(hook, length); end

  # source://gpgme//lib/gpgme/io_callbacks.rb#15
  def seek(hook, offset, whence); end

  # source://gpgme//lib/gpgme/io_callbacks.rb#11
  def write(hook, buffer, length); end
end

# source://gpgme//lib/gpgme/misc.rb#65
class GPGME::ImportResult
  # Returns the value of attribute considered.
  #
  # source://gpgme//lib/gpgme/misc.rb#68
  def considered; end

  # Returns the value of attribute imported.
  #
  # source://gpgme//lib/gpgme/misc.rb#68
  def imported; end

  # Returns the value of attribute imported_rsa.
  #
  # source://gpgme//lib/gpgme/misc.rb#68
  def imported_rsa; end

  # Returns the value of attribute imports.
  #
  # source://gpgme//lib/gpgme/misc.rb#71
  def imports; end

  # Returns the value of attribute new_revocations.
  #
  # source://gpgme//lib/gpgme/misc.rb#69
  def new_revocations; end

  # Returns the value of attribute new_signatures.
  #
  # source://gpgme//lib/gpgme/misc.rb#69
  def new_signatures; end

  # Returns the value of attribute new_sub_keys.
  #
  # source://gpgme//lib/gpgme/misc.rb#69
  def new_sub_keys; end

  # Returns the value of attribute new_user_ids.
  #
  # source://gpgme//lib/gpgme/misc.rb#69
  def new_user_ids; end

  # Returns the value of attribute no_user_id.
  #
  # source://gpgme//lib/gpgme/misc.rb#68
  def no_user_id; end

  # Returns the value of attribute not_imported.
  #
  # source://gpgme//lib/gpgme/misc.rb#71
  def not_imported; end

  # Returns the value of attribute secret_imported.
  #
  # source://gpgme//lib/gpgme/misc.rb#70
  def secret_imported; end

  # Returns the value of attribute secret_read.
  #
  # source://gpgme//lib/gpgme/misc.rb#70
  def secret_read; end

  # Returns the value of attribute secret_unchanged.
  #
  # source://gpgme//lib/gpgme/misc.rb#70
  def secret_unchanged; end

  # Returns the value of attribute unchanged.
  #
  # source://gpgme//lib/gpgme/misc.rb#68
  def unchanged; end

  class << self
    private

    def new(*_arg0); end
  end
end

# source://gpgme//lib/gpgme/misc.rb#58
class GPGME::ImportStatus
  # Returns the value of attribute fpr.
  #
  # source://gpgme//lib/gpgme/misc.rb#61
  def fingerprint; end

  # Returns the value of attribute fpr.
  #
  # source://gpgme//lib/gpgme/misc.rb#61
  def fpr; end

  # Returns the value of attribute result.
  #
  # source://gpgme//lib/gpgme/misc.rb#61
  def result; end

  # Returns the value of attribute status.
  #
  # source://gpgme//lib/gpgme/misc.rb#61
  def status; end

  class << self
    private

    def new(*_arg0); end
  end
end

# source://gpgme//lib/gpgme/misc.rb#40
class GPGME::InvalidKey
  # Returns the value of attribute fpr.
  #
  # source://gpgme//lib/gpgme/misc.rb#43
  def fingerprint; end

  # Returns the value of attribute fpr.
  #
  # source://gpgme//lib/gpgme/misc.rb#43
  def fpr; end

  # Returns the value of attribute reason.
  #
  # source://gpgme//lib/gpgme/misc.rb#43
  def reason; end

  class << self
    private

    def new(*_arg0); end
  end
end

# source://gpgme//lib/gpgme/constants.rb#55
GPGME::KEYLIST_MODE_EPHEMERAL = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#47
GPGME::KEYLIST_MODE_EXTERN = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#48
GPGME::KEYLIST_MODE_LOCAL = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#253
GPGME::KEYLIST_MODE_NAMES = T.let(T.unsafe(nil), Hash)

# source://gpgme//lib/gpgme/constants.rb#49
GPGME::KEYLIST_MODE_SIGS = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#52
GPGME::KEYLIST_MODE_SIG_NOTATIONS = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#50
GPGME::KEYLIST_MODE_VALIDATE = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#58
GPGME::KEYLIST_MODE_WITH_SECRET = T.let(T.unsafe(nil), Integer)

# A ruby representation of a public or a secret key.
#
# Every key has two instances of {GPGME::SubKey}, accessible through
# {.subkeys}, and with a {.primary_subkey} where most attributes are
# derived from, like the +fingerprint+.
#
# Also, every key has at least a {GPGME::UserID}, accessible through
# {.uids}, with a {.primary_uid}, where other attributes are derived from,
# like +email+ or +name+
#
# source://gpgme//lib/gpgme/key.rb#13
class GPGME::Key
  include ::GPGME::KeyCommon

  # source://gpgme//lib/gpgme/key.rb#224
  def ==(another_key); end

  # Returns the value of attribute chain_id.
  #
  # source://gpgme//lib/gpgme/key.rb#17
  def chain_id; end

  # Returns the issuer comment for this key.
  #
  # source://gpgme//lib/gpgme/key.rb#220
  def comment; end

  # Delete this key. If it's public, and has a secret one it will fail unless
  # +allow_secret+ is specified as true.
  #
  # source://gpgme//lib/gpgme/key.rb#160
  def delete!(allow_secret = T.unsafe(nil)); end

  # Returns the email for this key.
  #
  # source://gpgme//lib/gpgme/key.rb#208
  def email; end

  # Returns true if the key is expired
  #
  # source://gpgme//lib/gpgme/key.rb#180
  def expired; end

  # Returns the expiry date for this key
  #
  # source://gpgme//lib/gpgme/key.rb#174
  def expires; end

  # Returns true if the key has an expiry date else false
  #
  # @return [Boolean]
  #
  # source://gpgme//lib/gpgme/key.rb#168
  def expires?; end

  # Exports this key. Accepts the same options as {GPGME::Ctx.new}, and
  # +options[:output]+, where you can specify something that can become a
  # {GPGME::Data}, where the output will go.
  #
  # @example
  #   key.export(:armor => true)
  #   # => GPGME::Data you can read with ASCII armored format
  # @example
  #   file = File.open("key.asc", "w+")
  #   key.export(:output => file)
  #   # => the key will be written to the file.
  #
  # source://gpgme//lib/gpgme/key.rb#153
  def export(options = T.unsafe(nil)); end

  # Longer descriptive value. Can be used to identify the key.
  #
  # source://gpgme//lib/gpgme/key.rb#196
  def fingerprint; end

  # source://gpgme//lib/gpgme/key.rb#228
  def inspect; end

  # Returns the value of attribute issuer_name.
  #
  # source://gpgme//lib/gpgme/key.rb#17
  def issuer_name; end

  # Returns the value of attribute issuer_serial.
  #
  # source://gpgme//lib/gpgme/key.rb#17
  def issuer_serial; end

  # Returns the value of attribute keylist_mode.
  #
  # source://gpgme//lib/gpgme/key.rb#16
  def keylist_mode; end

  # Returns the issuer name for this key.
  #
  # source://gpgme//lib/gpgme/key.rb#214
  def name; end

  # Returns the value of attribute owner_trust.
  #
  # source://gpgme//lib/gpgme/key.rb#16
  def owner_trust; end

  # source://gpgme//lib/gpgme/key.rb#184
  def primary_subkey; end

  # Returns the main {GPGME::UserID} for this key.
  #
  # source://gpgme//lib/gpgme/key.rb#202
  def primary_uid; end

  # Returns the value of attribute protocol.
  #
  # source://gpgme//lib/gpgme/key.rb#16
  def protocol; end

  # Short descriptive value. Can be used to identify the key.
  #
  # source://gpgme//lib/gpgme/key.rb#190
  def sha; end

  # Returns the value of attribute subkeys.
  #
  # source://gpgme//lib/gpgme/key.rb#18
  def subkeys; end

  # source://gpgme//lib/gpgme/key.rb#243
  def to_s; end

  # Returns the value of attribute uids.
  #
  # source://gpgme//lib/gpgme/key.rb#18
  def uids; end

  class << self
    # Exports public keys
    #
    #   GPGME::Key.export pattern, options
    #
    # Private keys cannot be exported due to GPGME restrictions.
    #
    # @example
    #   key = GPGME::Key.export "mrsimo@example.com"
    # @example writing to a file
    #   out = File.open("my.key", "w+")
    #   GPGME::Key.export "mrsimo@example.com", :output => out
    # @param pattern Identifier of the key to export.
    # @param options [Hash] * +:output+ specify where to write the key to. It will be converted to
    #   a {GPGME::Data}, so it could be a file, for example.
    #   * +:minimal+ set to true to let the export mode be 'minimal'.
    #   * Any other option accepted by {GPGME::Ctx.new}
    # @return [GPGME::Data] the exported key.
    #
    # source://gpgme//lib/gpgme/key.rb#96
    def export(pattern, options = T.unsafe(nil)); end

    # Returns an array of {GPGME::Key} objects that match the parameters.
    # * +secret+ set to +:secret+ to get only secret keys, or to +:public+ to
    #   get only public keys.
    # * +keys_or_names+ an array or an item that can be either {GPGME::Key}
    #   elements, or string identifiers like the email or the sha. Leave
    #   blank to get all.
    # * +purposes+ get only keys that are usable for any of these purposes.
    #   See {GPGME::Key} for a list of possible key capabilities.
    #
    # @example
    #   GPGME::Key.find :secret # => first secret key found
    # @example
    #   GPGME::Key.find(:public, "mrsimo@example.com")
    #   # => return only public keys that match mrsimo@example.com
    # @example
    #   GPGME::Key.find(:public, "mrsimo@example.com", :sign)
    #   # => return the public keys that match mrsimo@example.com and are
    #   #    capable of signing
    #
    # source://gpgme//lib/gpgme/key.rb#45
    def find(secret, keys_or_names = T.unsafe(nil), purposes = T.unsafe(nil)); end

    # source://gpgme//lib/gpgme/key.rb#66
    def get(fingerprint); end

    # Imports a key
    #
    #   GPGME::Key.import keydata, options
    #
    # @example
    #   GPGME::Key.import(File.open("my.key"))
    # @param keydata The key to import. It will be converted to a {GPGME::Data} object,
    #   so could be a file, for example.
    # @param options Any other option accepted by {GPGME::Ctx.new}
    #
    # source://gpgme//lib/gpgme/key.rb#125
    def import(keydata, options = T.unsafe(nil)); end

    # Checks if a key is valid
    #
    # @return [Boolean]
    #
    # source://gpgme//lib/gpgme/key.rb#133
    def valid?(key); end

    private

    def new(*_arg0); end
  end
end

# source://gpgme//lib/gpgme/key_common.rb#2
module GPGME::KeyCommon
  # Array of capabilities for this key. It can contain any combination of
  # +:encrypt+, +:sign+, +:certify+ or +:authenticate+
  #
  # source://gpgme//lib/gpgme/key_common.rb#17
  def capability; end

  # @return [Boolean]
  #
  # source://gpgme//lib/gpgme/key_common.rb#39
  def secret?; end

  # Returns nil if the trust is valid.
  # Returns one of +:revoked+, +:expired+, +:disabled+, +:invalid+
  #
  # source://gpgme//lib/gpgme/key_common.rb#7
  def trust; end

  # Checks if the key is capable of all of these actions. If empty array
  # is passed then will return true.
  #
  # Returns false if the keys trust has been invalidated.
  #
  # @return [Boolean]
  #
  # source://gpgme//lib/gpgme/key_common.rb#31
  def usable_for?(purposes); end
end

# source://gpgme//lib/gpgme/key_sig.rb#2
class GPGME::KeySig
  # @return [Boolean]
  #
  # source://gpgme//lib/gpgme/key_sig.rb#11
  def expired?; end

  # source://gpgme//lib/gpgme/key_sig.rb#27
  def expires; end

  # @return [Boolean]
  #
  # source://gpgme//lib/gpgme/key_sig.rb#19
  def exportable?; end

  # source://gpgme//lib/gpgme/key_sig.rb#31
  def inspect; end

  # @return [Boolean]
  #
  # source://gpgme//lib/gpgme/key_sig.rb#15
  def invalid?; end

  # Returns the value of attribute keyid.
  #
  # source://gpgme//lib/gpgme/key_sig.rb#5
  def keyid; end

  # Returns the value of attribute pubkey_algo.
  #
  # source://gpgme//lib/gpgme/key_sig.rb#5
  def pubkey_algo; end

  # @return [Boolean]
  #
  # source://gpgme//lib/gpgme/key_sig.rb#7
  def revoked?; end

  # source://gpgme//lib/gpgme/key_sig.rb#23
  def timestamp; end

  class << self
    private

    def new(*_arg0); end
  end
end

# source://gpgme//lib/gpgme/constants.rb#60
GPGME::MD_CRC24_RFC2440 = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#61
GPGME::MD_CRC32 = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#62
GPGME::MD_CRC32_RFC1510 = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#63
GPGME::MD_HAVAL = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#64
GPGME::MD_MD2 = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#65
GPGME::MD_MD4 = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#66
GPGME::MD_MD5 = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#67
GPGME::MD_RMD160 = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#68
GPGME::MD_SHA1 = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#69
GPGME::MD_SHA256 = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#73
GPGME::MD_SHA384 = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#74
GPGME::MD_SHA512 = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#75
GPGME::MD_TIGER = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/misc.rb#47
class GPGME::NewSignature
  # Returns the value of attribute fpr.
  #
  # source://gpgme//lib/gpgme/misc.rb#50
  def fingerprint; end

  # Returns the value of attribute fpr.
  #
  # source://gpgme//lib/gpgme/misc.rb#50
  def fpr; end

  # Returns the value of attribute hash_algo.
  #
  # source://gpgme//lib/gpgme/misc.rb#50
  def hash_algo; end

  # Returns the value of attribute pubkey_algo.
  #
  # source://gpgme//lib/gpgme/misc.rb#50
  def pubkey_algo; end

  # Returns the value of attribute sig_class.
  #
  # source://gpgme//lib/gpgme/misc.rb#50
  def sig_class; end

  # source://gpgme//lib/gpgme/misc.rb#53
  def timestamp; end

  # Returns the value of attribute type.
  #
  # source://gpgme//lib/gpgme/misc.rb#50
  def type; end

  class << self
    private

    def new(*_arg0); end
  end
end

# source://gpgme//lib/gpgme/constants.rb#78
GPGME::PINENTRY_MODE_ASK = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#79
GPGME::PINENTRY_MODE_CANCEL = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#77
GPGME::PINENTRY_MODE_DEFAULT = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#80
GPGME::PINENTRY_MODE_ERROR = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#81
GPGME::PINENTRY_MODE_LOOPBACK = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#82
GPGME::PINENTRY_MODE_NAMES = T.let(T.unsafe(nil), Hash)

# source://gpgme//lib/gpgme/constants.rb#90
GPGME::PK_DSA = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#91
GPGME::PK_ELG = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#92
GPGME::PK_ELG_E = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#93
GPGME::PK_RSA = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#97
GPGME::PROTOCOL_CMS = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#222
GPGME::PROTOCOL_NAMES = T.let(T.unsafe(nil), Hash)

# source://gpgme//lib/gpgme/constants.rb#98
GPGME::PROTOCOL_OpenPGP = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/misc.rb#15
class GPGME::Recipient
  # Returns the value of attribute keyid.
  #
  # source://gpgme//lib/gpgme/misc.rb#18
  def keyid; end

  # Returns the value of attribute pubkey_algo.
  #
  # source://gpgme//lib/gpgme/misc.rb#18
  def pubkey_algo; end

  # Returns the value of attribute status.
  #
  # source://gpgme//lib/gpgme/misc.rb#18
  def status; end

  class << self
    private

    def new(*_arg0); end
  end
end

# source://gpgme//lib/gpgme/constants.rb#99
GPGME::SIGSUM_BAD_POLICY = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#100
GPGME::SIGSUM_CRL_MISSING = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#101
GPGME::SIGSUM_CRL_TOO_OLD = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#102
GPGME::SIGSUM_GREEN = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#103
GPGME::SIGSUM_KEY_EXPIRED = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#104
GPGME::SIGSUM_KEY_MISSING = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#105
GPGME::SIGSUM_KEY_REVOKED = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#106
GPGME::SIGSUM_RED = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#107
GPGME::SIGSUM_SIG_EXPIRED = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#108
GPGME::SIGSUM_SYS_ERROR = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#109
GPGME::SIGSUM_VALID = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#110
GPGME::SIG_MODE_CLEAR = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#111
GPGME::SIG_MODE_DETACH = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#112
GPGME::SIG_MODE_NORMAL = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#113
GPGME::SIG_STAT_BAD = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#114
GPGME::SIG_STAT_DIFF = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#115
GPGME::SIG_STAT_ERROR = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#116
GPGME::SIG_STAT_GOOD = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#117
GPGME::SIG_STAT_GOOD_EXP = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#118
GPGME::SIG_STAT_GOOD_EXPKEY = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#119
GPGME::SIG_STAT_NOKEY = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#120
GPGME::SIG_STAT_NONE = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#121
GPGME::SIG_STAT_NOSIG = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#122
GPGME::STATUS_ABORT = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#123
GPGME::STATUS_ALREADY_SIGNED = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#187
GPGME::STATUS_ATTRIBUTE = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#124
GPGME::STATUS_BADARMOR = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#125
GPGME::STATUS_BADMDC = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#126
GPGME::STATUS_BADSIG = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#127
GPGME::STATUS_BAD_PASSPHRASE = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#128
GPGME::STATUS_BEGIN_DECRYPTION = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#129
GPGME::STATUS_BEGIN_ENCRYPTION = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#190
GPGME::STATUS_BEGIN_SIGNING = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#130
GPGME::STATUS_BEGIN_STREAM = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#131
GPGME::STATUS_DECRYPTION_FAILED = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#132
GPGME::STATUS_DECRYPTION_OKAY = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#133
GPGME::STATUS_DELETE_PROBLEM = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#134
GPGME::STATUS_ENC_TO = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#135
GPGME::STATUS_END_DECRYPTION = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#136
GPGME::STATUS_END_ENCRYPTION = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#137
GPGME::STATUS_END_STREAM = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#138
GPGME::STATUS_ENTER = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#139
GPGME::STATUS_EOF = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#140
GPGME::STATUS_ERRMDC = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#141
GPGME::STATUS_ERROR = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#142
GPGME::STATUS_ERRSIG = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#143
GPGME::STATUS_EXPKEYSIG = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#144
GPGME::STATUS_EXPSIG = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#145
GPGME::STATUS_FILE_DONE = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#146
GPGME::STATUS_FILE_ERROR = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#147
GPGME::STATUS_FILE_START = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#148
GPGME::STATUS_GET_BOOL = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#149
GPGME::STATUS_GET_HIDDEN = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#150
GPGME::STATUS_GET_LINE = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#151
GPGME::STATUS_GOODMDC = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#152
GPGME::STATUS_GOODSIG = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#153
GPGME::STATUS_GOOD_PASSPHRASE = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#154
GPGME::STATUS_GOT_IT = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#155
GPGME::STATUS_IMPORTED = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#156
GPGME::STATUS_IMPORT_RES = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#157
GPGME::STATUS_INV_RECP = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#158
GPGME::STATUS_KEYEXPIRED = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#159
GPGME::STATUS_KEYREVOKED = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#160
GPGME::STATUS_KEY_CREATED = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#193
GPGME::STATUS_KEY_NOT_CREATED = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#161
GPGME::STATUS_LEAVE = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#162
GPGME::STATUS_MISSING_PASSPHRASE = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#181
GPGME::STATUS_MOUNTPOINT = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#163
GPGME::STATUS_NEED_PASSPHRASE = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#164
GPGME::STATUS_NEED_PASSPHRASE_SYM = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#165
GPGME::STATUS_NODATA = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#166
GPGME::STATUS_NOTATION_DATA = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#167
GPGME::STATUS_NOTATION_NAME = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#168
GPGME::STATUS_NO_PUBKEY = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#169
GPGME::STATUS_NO_RECP = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#170
GPGME::STATUS_NO_SECKEY = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#184
GPGME::STATUS_PINENTRY_LAUNCHED = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#178
GPGME::STATUS_PLAINTEXT_LENGTH = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#195
GPGME::STATUS_POLICY_URL = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#196
GPGME::STATUS_PROGRESS = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#197
GPGME::STATUS_RSA_OR_IDEA = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#198
GPGME::STATUS_SESSION_KEY = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#199
GPGME::STATUS_SHM_GET = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#200
GPGME::STATUS_SHM_GET_BOOL = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#201
GPGME::STATUS_SHM_GET_HIDDEN = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#202
GPGME::STATUS_SHM_INFO = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#203
GPGME::STATUS_SIGEXPIRED = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#204
GPGME::STATUS_SIG_CREATED = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#205
GPGME::STATUS_SIG_ID = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#206
GPGME::STATUS_TRUNCATED = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#207
GPGME::STATUS_TRUST_FULLY = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#208
GPGME::STATUS_TRUST_MARGINAL = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#209
GPGME::STATUS_TRUST_NEVER = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#210
GPGME::STATUS_TRUST_ULTIMATE = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#211
GPGME::STATUS_TRUST_UNDEFINED = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#212
GPGME::STATUS_UNEXPECTED = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#213
GPGME::STATUS_USERID_HINT = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#214
GPGME::STATUS_VALIDSIG = T.let(T.unsafe(nil), Integer)

class GPGME::SigNotation; end

# source://gpgme//lib/gpgme/misc.rb#28
class GPGME::SignResult
  # Returns the value of attribute invalid_signers.
  #
  # source://gpgme//lib/gpgme/misc.rb#31
  def invalid_signers; end

  # Returns the value of attribute signatures.
  #
  # source://gpgme//lib/gpgme/misc.rb#31
  def signatures; end

  class << self
    private

    def new(*_arg0); end
  end
end

# source://gpgme//lib/gpgme/signature.rb#2
class GPGME::Signature
  # @return [Boolean]
  #
  # source://gpgme//lib/gpgme/signature.rb#28
  def bad?; end

  # source://gpgme//lib/gpgme/signature.rb#64
  def exp_timestamp; end

  # @return [Boolean]
  #
  # source://gpgme//lib/gpgme/signature.rb#20
  def expired_key?; end

  # @return [Boolean]
  #
  # source://gpgme//lib/gpgme/signature.rb#16
  def expired_signature?; end

  # Returns the value of attribute fpr.
  #
  # source://gpgme//lib/gpgme/signature.rb#5
  def fingerprint; end

  # Returns the value of attribute fpr.
  #
  # source://gpgme//lib/gpgme/signature.rb#5
  def fpr; end

  # source://gpgme//lib/gpgme/signature.rb#40
  def from; end

  # source://gpgme//lib/gpgme/signature.rb#52
  def key; end

  # @return [Boolean]
  #
  # source://gpgme//lib/gpgme/signature.rb#32
  def no_key?; end

  # Returns the value of attribute notations.
  #
  # source://gpgme//lib/gpgme/signature.rb#5
  def notations; end

  # Returns the value of attribute pka_address.
  #
  # source://gpgme//lib/gpgme/signature.rb#7
  def pka_address; end

  # Returns the value of attribute pka_trust.
  #
  # source://gpgme//lib/gpgme/signature.rb#7
  def pka_trust; end

  # @return [Boolean]
  #
  # source://gpgme//lib/gpgme/signature.rb#24
  def revoked_key?; end

  # Returns the value of attribute status.
  #
  # source://gpgme//lib/gpgme/signature.rb#5
  def status; end

  # source://gpgme//lib/gpgme/signature.rb#36
  def status_code; end

  # Returns the value of attribute summary.
  #
  # source://gpgme//lib/gpgme/signature.rb#5
  def summary; end

  # source://gpgme//lib/gpgme/signature.rb#60
  def timestamp; end

  # source://gpgme//lib/gpgme/signature.rb#68
  def to_s; end

  # Returns true if the signature is correct
  #
  # @return [Boolean]
  #
  # source://gpgme//lib/gpgme/signature.rb#12
  def valid?; end

  # Returns the value of attribute validity.
  #
  # source://gpgme//lib/gpgme/signature.rb#6
  def validity; end

  # Returns the value of attribute validity_reason.
  #
  # source://gpgme//lib/gpgme/signature.rb#6
  def validity_reason; end

  # Returns the value of attribute wrong_key_usage.
  #
  # source://gpgme//lib/gpgme/signature.rb#5
  def wrong_key_usage; end

  class << self
    private

    def new(*_arg0); end
  end
end

# source://gpgme//lib/gpgme/sub_key.rb#2
class GPGME::SubKey
  include ::GPGME::KeyCommon

  # source://gpgme//lib/gpgme/sub_key.rb#28
  def expired; end

  # source://gpgme//lib/gpgme/sub_key.rb#24
  def expires; end

  # @return [Boolean]
  #
  # source://gpgme//lib/gpgme/sub_key.rb#20
  def expires?; end

  # Returns the value of attribute fpr.
  #
  # source://gpgme//lib/gpgme/sub_key.rb#5
  def fingerprint; end

  # Returns the value of attribute fpr.
  #
  # source://gpgme//lib/gpgme/sub_key.rb#5
  def fpr; end

  # source://gpgme//lib/gpgme/sub_key.rb#47
  def inspect; end

  # Returns the value of attribute keyid.
  #
  # source://gpgme//lib/gpgme/sub_key.rb#5
  def keyid; end

  # Returns the value of attribute length.
  #
  # source://gpgme//lib/gpgme/sub_key.rb#5
  def length; end

  # Returns the value of attribute pubkey_algo.
  #
  # source://gpgme//lib/gpgme/sub_key.rb#5
  def pubkey_algo; end

  # source://gpgme//lib/gpgme/sub_key.rb#43
  def pubkey_algo_letter; end

  # source://gpgme//lib/gpgme/sub_key.rb#32
  def sha; end

  # source://gpgme//lib/gpgme/sub_key.rb#10
  def timestamp; end

  # source://gpgme//lib/gpgme/sub_key.rb#58
  def to_s; end

  class << self
    private

    def new(*_arg0); end
  end
end

# source://gpgme//lib/gpgme/sub_key.rb#36
GPGME::SubKey::PUBKEY_ALGO_LETTERS = T.let(T.unsafe(nil), Hash)

class GPGME::TrustItem; end

# source://gpgme//lib/gpgme/user_id.rb#2
class GPGME::UserID
  # Returns the value of attribute comment.
  #
  # source://gpgme//lib/gpgme/user_id.rb#5
  def comment; end

  # Returns the value of attribute email.
  #
  # source://gpgme//lib/gpgme/user_id.rb#5
  def email; end

  # source://gpgme//lib/gpgme/user_id.rb#15
  def inspect; end

  # @return [Boolean]
  #
  # source://gpgme//lib/gpgme/user_id.rb#11
  def invalid?; end

  # Returns the value of attribute name.
  #
  # source://gpgme//lib/gpgme/user_id.rb#5
  def name; end

  # @return [Boolean]
  #
  # source://gpgme//lib/gpgme/user_id.rb#7
  def revoked?; end

  # Returns the value of attribute signatures.
  #
  # source://gpgme//lib/gpgme/user_id.rb#5
  def signatures; end

  # Returns the value of attribute uid.
  #
  # source://gpgme//lib/gpgme/user_id.rb#5
  def uid; end

  # Returns the value of attribute validity.
  #
  # source://gpgme//lib/gpgme/user_id.rb#5
  def validity; end

  class << self
    private

    def new(*_arg0); end
  end
end

# source://gpgme//lib/gpgme/constants.rb#215
GPGME::VALIDITY_FULL = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#216
GPGME::VALIDITY_MARGINAL = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#260
GPGME::VALIDITY_NAMES = T.let(T.unsafe(nil), Hash)

# source://gpgme//lib/gpgme/constants.rb#217
GPGME::VALIDITY_NEVER = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#218
GPGME::VALIDITY_ULTIMATE = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#219
GPGME::VALIDITY_UNDEFINED = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/constants.rb#220
GPGME::VALIDITY_UNKNOWN = T.let(T.unsafe(nil), Integer)

# source://gpgme//lib/gpgme/misc.rb#9
class GPGME::VerifyResult
  # Returns the value of attribute signatures.
  #
  # source://gpgme//lib/gpgme/misc.rb#12
  def signatures; end

  class << self
    private

    def new(*_arg0); end
  end
end
