# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `uri` gem.
# Please instead update this file by running `bin/tapioca gem uri`.

# module URI
module Kernel
  private

  # Returns a \URI object derived from the given +uri+,
  # which may be a \URI string or an existing \URI object:
  #
  #   # Returns a new URI.
  #   uri = URI('http://github.com/ruby/ruby')
  #   # => #<URI::HTTP http://github.com/ruby/ruby>
  #   # Returns the given URI.
  #   URI(uri)
  #   # => #<URI::HTTP http://github.com/ruby/ruby>
  #
  # source://uri//lib/uri/common.rb#842
  def URI(uri); end

  class << self
    # Returns a \URI object derived from the given +uri+,
    # which may be a \URI string or an existing \URI object:
    #
    #   # Returns a new URI.
    #   uri = URI('http://github.com/ruby/ruby')
    #   # => #<URI::HTTP http://github.com/ruby/ruby>
    #   # Returns the given URI.
    #   URI(uri)
    #   # => #<URI::HTTP http://github.com/ruby/ruby>
    #
    # source://uri//lib/uri/common.rb#842
    def URI(uri); end
  end
end

module URI
  include ::URI::RFC2396_REGEXP

  class << self
    # Like URI.decode_www_form_component, except that <tt>'+'</tt> is preserved.
    #
    # source://uri//lib/uri/common.rb#379
    def decode_uri_component(str, enc = T.unsafe(nil)); end

    # Returns name/value pairs derived from the given string +str+,
    # which must be an ASCII string.
    #
    # The method may be used to decode the body of Net::HTTPResponse object +res+
    # for which <tt>res['Content-Type']</tt> is <tt>'application/x-www-form-urlencoded'</tt>.
    #
    # The returned data is an array of 2-element subarrays;
    # each subarray is a name/value pair (both are strings).
    # Each returned string has encoding +enc+,
    # and has had invalid characters removed via
    # {String#scrub}[https://docs.ruby-lang.org/en/master/String.html#method-i-scrub].
    #
    # A simple example:
    #
    #   URI.decode_www_form('foo=0&bar=1&baz')
    #   # => [["foo", "0"], ["bar", "1"], ["baz", ""]]
    #
    # The returned strings have certain conversions,
    # similar to those performed in URI.decode_www_form_component:
    #
    #   URI.decode_www_form('f%23o=%2F&b-r=%24&b+z=%40')
    #   # => [["f#o", "/"], ["b-r", "$"], ["b z", "@"]]
    #
    # The given string may contain consecutive separators:
    #
    #   URI.decode_www_form('foo=0&&bar=1&&baz=2')
    #   # => [["foo", "0"], ["", ""], ["bar", "1"], ["", ""], ["baz", "2"]]
    #
    # A different separator may be specified:
    #
    #   URI.decode_www_form('foo=0--bar=1--baz', separator: '--')
    #   # => [["foo", "0"], ["bar", "1"], ["baz", ""]]
    #
    # @raise [ArgumentError]
    #
    # source://uri//lib/uri/common.rb#554
    def decode_www_form(str, enc = T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

    # Returns a string decoded from the given \URL-encoded string +str+.
    #
    # The given string is first encoded as Encoding::ASCII-8BIT (using String#b),
    # then decoded (as below), and finally force-encoded to the given encoding +enc+.
    #
    # The returned string:
    #
    # - Preserves:
    #
    #   - Characters <tt>'*'</tt>, <tt>'.'</tt>, <tt>'-'</tt>, and <tt>'_'</tt>.
    #   - Character in ranges <tt>'a'..'z'</tt>, <tt>'A'..'Z'</tt>,
    #     and <tt>'0'..'9'</tt>.
    #
    #   Example:
    #
    #     URI.decode_www_form_component('*.-_azAZ09')
    #     # => "*.-_azAZ09"
    #
    # - Converts:
    #
    #   - Character <tt>'+'</tt> to character <tt>' '</tt>.
    #   - Each "percent notation" to an ASCII character.
    #
    #   Example:
    #
    #     URI.decode_www_form_component('Here+are+some+punctuation+characters%3A+%2C%3B%3F%3A')
    #     # => "Here are some punctuation characters: ,;?:"
    #
    # Related: URI.decode_uri_component (preserves <tt>'+'</tt>).
    #
    # source://uri//lib/uri/common.rb#368
    def decode_www_form_component(str, enc = T.unsafe(nil)); end

    # Like URI.encode_www_form_component, except that <tt>' '</tt> (space)
    # is encoded as <tt>'%20'</tt> (instead of <tt>'+'</tt>).
    #
    # source://uri//lib/uri/common.rb#374
    def encode_uri_component(str, enc = T.unsafe(nil)); end

    # Returns a URL-encoded string derived from the given
    # {Enumerable}[https://docs.ruby-lang.org/en/master/Enumerable.html#module-Enumerable-label-Enumerable+in+Ruby+Classes]
    # +enum+.
    #
    # The result is suitable for use as form data
    # for an \HTTP request whose <tt>Content-Type</tt> is
    # <tt>'application/x-www-form-urlencoded'</tt>.
    #
    # The returned string consists of the elements of +enum+,
    # each converted to one or more URL-encoded strings,
    # and all joined with character <tt>'&'</tt>.
    #
    # Simple examples:
    #
    #   URI.encode_www_form([['foo', 0], ['bar', 1], ['baz', 2]])
    #   # => "foo=0&bar=1&baz=2"
    #   URI.encode_www_form({foo: 0, bar: 1, baz: 2})
    #   # => "foo=0&bar=1&baz=2"
    #
    # The returned string is formed using method URI.encode_www_form_component,
    # which converts certain characters:
    #
    #   URI.encode_www_form('f#o': '/', 'b-r': '$', 'b z': '@')
    #   # => "f%23o=%2F&b-r=%24&b+z=%40"
    #
    # When +enum+ is Array-like, each element +ele+ is converted to a field:
    #
    # - If +ele+ is an array of two or more elements,
    #   the field is formed from its first two elements
    #   (and any additional elements are ignored):
    #
    #     name = URI.encode_www_form_component(ele[0], enc)
    #     value = URI.encode_www_form_component(ele[1], enc)
    #     "#{name}=#{value}"
    #
    #   Examples:
    #
    #     URI.encode_www_form([%w[foo bar], %w[baz bat bah]])
    #     # => "foo=bar&baz=bat"
    #     URI.encode_www_form([['foo', 0], ['bar', :baz, 'bat']])
    #     # => "foo=0&bar=baz"
    #
    # - If +ele+ is an array of one element,
    #   the field is formed from <tt>ele[0]</tt>:
    #
    #     URI.encode_www_form_component(ele[0])
    #
    #   Example:
    #
    #     URI.encode_www_form([['foo'], [:bar], [0]])
    #     # => "foo&bar&0"
    #
    # - Otherwise the field is formed from +ele+:
    #
    #     URI.encode_www_form_component(ele)
    #
    #   Example:
    #
    #     URI.encode_www_form(['foo', :bar, 0])
    #     # => "foo&bar&0"
    #
    # The elements of an Array-like +enum+ may be mixture:
    #
    #   URI.encode_www_form([['foo', 0], ['bar', 1, 2], ['baz'], :bat])
    #   # => "foo=0&bar=1&baz&bat"
    #
    # When +enum+ is Hash-like,
    # each +key+/+value+ pair is converted to one or more fields:
    #
    # - If +value+ is
    #   {Array-convertible}[https://docs.ruby-lang.org/en/master/implicit_conversion_rdoc.html#label-Array-Convertible+Objects],
    #   each element +ele+ in +value+ is paired with +key+ to form a field:
    #
    #     name = URI.encode_www_form_component(key, enc)
    #     value = URI.encode_www_form_component(ele, enc)
    #     "#{name}=#{value}"
    #
    #   Example:
    #
    #     URI.encode_www_form({foo: [:bar, 1], baz: [:bat, :bam, 2]})
    #     # => "foo=bar&foo=1&baz=bat&baz=bam&baz=2"
    #
    # - Otherwise, +key+ and +value+ are paired to form a field:
    #
    #     name = URI.encode_www_form_component(key, enc)
    #     value = URI.encode_www_form_component(value, enc)
    #     "#{name}=#{value}"
    #
    #   Example:
    #
    #     URI.encode_www_form({foo: 0, bar: 1, baz: 2})
    #     # => "foo=0&bar=1&baz=2"
    #
    # The elements of a Hash-like +enum+ may be mixture:
    #
    #   URI.encode_www_form({foo: [0, 1], bar: 2})
    #   # => "foo=0&foo=1&bar=2"
    #
    # source://uri//lib/uri/common.rb#501
    def encode_www_form(enum, enc = T.unsafe(nil)); end

    # Returns a URL-encoded string derived from the given string +str+.
    #
    # The returned string:
    #
    # - Preserves:
    #
    #   - Characters <tt>'*'</tt>, <tt>'.'</tt>, <tt>'-'</tt>, and <tt>'_'</tt>.
    #   - Character in ranges <tt>'a'..'z'</tt>, <tt>'A'..'Z'</tt>,
    #     and <tt>'0'..'9'</tt>.
    #
    #   Example:
    #
    #     URI.encode_www_form_component('*.-_azAZ09')
    #     # => "*.-_azAZ09"
    #
    # - Converts:
    #
    #   - Character <tt>' '</tt> to character <tt>'+'</tt>.
    #   - Any other character to "percent notation";
    #     the percent notation for character <i>c</i> is <tt>'%%%X' % c.ord</tt>.
    #
    #   Example:
    #
    #     URI.encode_www_form_component('Here are some punctuation characters: ,;?:')
    #     # => "Here+are+some+punctuation+characters%3A+%2C%3B%3F%3A"
    #
    # Encoding:
    #
    # - If +str+ has encoding Encoding::ASCII_8BIT, argument +enc+ is ignored.
    # - Otherwise +str+ is converted first to Encoding::UTF_8
    #   (with suitable character replacements),
    #   and then to encoding +enc+.
    #
    # In either case, the returned string has forced encoding Encoding::US_ASCII.
    #
    # Related: URI.encode_uri_component (encodes <tt>' '</tt> as <tt>'%20'</tt>).
    #
    # source://uri//lib/uri/common.rb#335
    def encode_www_form_component(str, enc = T.unsafe(nil)); end

    # == Synopsis
    #
    #   URI::extract(str[, schemes][,&blk])
    #
    # == Args
    #
    # +str+::
    #   String to extract URIs from.
    # +schemes+::
    #   Limit URI matching to specific schemes.
    #
    # == Description
    #
    # Extracts URIs from a string. If block given, iterates through all matched URIs.
    # Returns nil if block given or array with matches.
    #
    # == Usage
    #
    #   require "uri"
    #
    #   URI.extract("text here http://foo.example.org/bla and here mailto:test@example.com and here also.")
    #   # => ["http://foo.example.com/bla", "mailto:test@example.com"]
    #
    # source://uri//lib/uri/common.rb#239
    def extract(str, schemes = T.unsafe(nil), &block); end

    # Returns a new object constructed from the given +scheme+, +arguments+,
    # and +default+:
    #
    # - The new object is an instance of <tt>URI.scheme_list[scheme.upcase]</tt>.
    # - The object is initialized by calling the class initializer
    #   using +scheme+ and +arguments+.
    #   See URI::Generic.new.
    #
    # Examples:
    #
    #   values = ['john.doe', 'www.example.com', '123', nil, '/forum/questions/', nil, 'tag=networking&order=newest', 'top']
    #   URI.for('https', *values)
    #   # => #<URI::HTTPS https://john.doe@www.example.com:123/forum/questions/?tag=networking&order=newest#top>
    #   URI.for('foo', *values, default: URI::HTTP)
    #   # => #<URI::HTTP foo://john.doe@www.example.com:123/forum/questions/?tag=networking&order=newest#top>
    #
    # source://uri//lib/uri/common.rb#123
    def for(scheme, *arguments, default: T.unsafe(nil)); end

    # return encoding or nil
    # http://encoding.spec.whatwg.org/#concept-encoding-get
    #
    # source://uri//lib/uri/common.rb#824
    def get_encoding(label); end

    # Merges the given URI strings +str+
    # per {RFC 2396}[https://www.rfc-editor.org/rfc/rfc2396.html].
    #
    # Each string in +str+ is converted to an
    # {RFC3986 URI}[https://www.rfc-editor.org/rfc/rfc3986.html] before being merged.
    #
    # Examples:
    #
    #   URI.join("http://example.com/","main.rbx")
    #   # => #<URI::HTTP http://example.com/main.rbx>
    #
    #   URI.join('http://example.com', 'foo')
    #   # => #<URI::HTTP http://example.com/foo>
    #
    #   URI.join('http://example.com', '/foo', '/bar')
    #   # => #<URI::HTTP http://example.com/bar>
    #
    #   URI.join('http://example.com', '/foo', 'bar')
    #   # => #<URI::HTTP http://example.com/bar>
    #
    #   URI.join('http://example.com', '/foo/', 'bar')
    #   # => #<URI::HTTP http://example.com/foo/bar>
    #
    # source://uri//lib/uri/common.rb#211
    def join(*str); end

    # Returns a new \URI object constructed from the given string +uri+:
    #
    #   URI.parse('https://john.doe@www.example.com:123/forum/questions/?tag=networking&order=newest#top')
    #   # => #<URI::HTTPS https://john.doe@www.example.com:123/forum/questions/?tag=networking&order=newest#top>
    #   URI.parse('http://john.doe@www.example.com:123/forum/questions/?tag=networking&order=newest#top')
    #   # => #<URI::HTTP http://john.doe@www.example.com:123/forum/questions/?tag=networking&order=newest#top>
    #
    # It's recommended to first ::escape string +uri+
    # if it may contain invalid URI characters.
    #
    # source://uri//lib/uri/common.rb#184
    def parse(uri); end

    # == Synopsis
    #
    #   URI::regexp([match_schemes])
    #
    # == Args
    #
    # +match_schemes+::
    #   Array of schemes. If given, resulting regexp matches to URIs
    #   whose scheme is one of the match_schemes.
    #
    # == Description
    #
    # Returns a Regexp object which matches to URI-like strings.
    # The Regexp object returned by this method includes arbitrary
    # number of capture group (parentheses).  Never rely on its number.
    #
    # == Usage
    #
    #   require 'uri'
    #
    #   # extract first URI from html_string
    #   html_string.slice(URI.regexp)
    #
    #   # remove ftp URIs
    #   html_string.sub(URI.regexp(['ftp']), '')
    #
    #   # You should not rely on the number of parentheses
    #   html_string.scan(URI.regexp) do |*matches|
    #     p $&
    #   end
    #
    # source://uri//lib/uri/common.rb#276
    def regexp(schemes = T.unsafe(nil)); end

    # Registers the given +klass+ as the class to be instantiated
    # when parsing a \URI with the given +scheme+:
    #
    #   URI.register_scheme('MS_SEARCH', URI::Generic) # => URI::Generic
    #   URI.scheme_list['MS_SEARCH']                   # => URI::Generic
    #
    # Note that after calling String#upcase on +scheme+, it must be a valid
    # constant name.
    #
    # source://uri//lib/uri/common.rb#79
    def register_scheme(scheme, klass); end

    # Returns a hash of the defined schemes:
    #
    #   URI.scheme_list
    #   # =>
    #   {"MAILTO"=>URI::MailTo,
    #    "LDAPS"=>URI::LDAPS,
    #    "WS"=>URI::WS,
    #    "HTTP"=>URI::HTTP,
    #    "HTTPS"=>URI::HTTPS,
    #    "LDAP"=>URI::LDAP,
    #    "FILE"=>URI::File,
    #    "FTP"=>URI::FTP}
    #
    # Related: URI.register_scheme.
    #
    # source://uri//lib/uri/common.rb#97
    def scheme_list; end

    # Returns a 9-element array representing the parts of the \URI
    # formed from the string +uri+;
    # each array element is a string or +nil+:
    #
    #   names = %w[scheme userinfo host port registry path opaque query fragment]
    #   values = URI.split('https://john.doe@www.example.com:123/forum/questions/?tag=networking&order=newest#top')
    #   names.zip(values)
    #   # =>
    #   [["scheme", "https"],
    #    ["userinfo", "john.doe"],
    #    ["host", "www.example.com"],
    #    ["port", "123"],
    #    ["registry", nil],
    #    ["path", "/forum/questions/"],
    #    ["opaque", nil],
    #    ["query", "tag=networking&order=newest"],
    #    ["fragment", "top"]]
    #
    # source://uri//lib/uri/common.rb#170
    def split(uri); end

    private

    # @raise [ArgumentError]
    #
    # source://uri//lib/uri/common.rb#397
    def _decode_uri_component(regexp, str, enc); end

    # source://uri//lib/uri/common.rb#383
    def _encode_uri_component(regexp, table, str, enc); end
  end
end

# FTP URI syntax is defined by RFC1738 section 3.2.
#
# This class will be redesigned because of difference of implementations;
# the structure of its path. draft-hoffman-ftp-uri-04 is a draft but it
# is a good summary about the de facto spec.
# http://tools.ietf.org/html/draft-hoffman-ftp-uri-04
class URI::FTP < ::URI::Generic
  # == Description
  #
  # Creates a new URI::FTP object from generic URL components with no
  # syntax checking.
  #
  # Unlike build(), this method does not escape the path component as
  # required by RFC1738; instead it is treated as per RFC2396.
  #
  # Arguments are +scheme+, +userinfo+, +host+, +port+, +registry+, +path+,
  # +opaque+, +query+, and +fragment+, in that order.
  #
  # @raise [InvalidURIError]
  # @return [FTP] a new instance of FTP
  #
  # source://uri//lib/uri/ftp.rb#133
  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser = T.unsafe(nil), arg_check = T.unsafe(nil)); end

  # source://uri//lib/uri/ftp.rb#214
  def merge(oth); end

  # Returns the path from an FTP URI.
  #
  # RFC 1738 specifically states that the path for an FTP URI does not
  # include the / which separates the URI path from the URI host. Example:
  #
  # <code>ftp://ftp.example.com/pub/ruby</code>
  #
  # The above URI indicates that the client should connect to
  # ftp.example.com then cd to pub/ruby from the initial login directory.
  #
  # If you want to cd to an absolute directory, you must include an
  # escaped / (%2F) in the path. Example:
  #
  # <code>ftp://ftp.example.com/%2Fpub/ruby</code>
  #
  # This method will then return "/pub/ruby".
  #
  # source://uri//lib/uri/ftp.rb#240
  def path; end

  # Returns a String representation of the URI::FTP.
  #
  # source://uri//lib/uri/ftp.rb#251
  def to_s; end

  # typecode accessor.
  #
  # See URI::FTP::COMPONENT.
  #
  # source://uri//lib/uri/ftp.rb#161
  def typecode; end

  # == Args
  #
  # +v+::
  #    String
  #
  # == Description
  #
  # Public setter for the typecode +v+
  # (with validation).
  #
  # See also URI::FTP.check_typecode.
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   uri = URI.parse("ftp://john@ftp.example.com/my_file.img")
  #   #=> #<URI::FTP ftp://john@ftp.example.com/my_file.img>
  #   uri.typecode = "i"
  #   uri
  #   #=> #<URI::FTP ftp://john@ftp.example.com/my_file.img;type=i>
  #
  # source://uri//lib/uri/ftp.rb#208
  def typecode=(typecode); end

  protected

  # Private setter for the path of the URI::FTP.
  #
  # source://uri//lib/uri/ftp.rb#245
  def set_path(v); end

  # Private setter for the typecode +v+.
  #
  # See also URI::FTP.typecode=.
  #
  # source://uri//lib/uri/ftp.rb#180
  def set_typecode(v); end

  private

  # Validates typecode +v+,
  # returns +true+ or +false+.
  #
  # source://uri//lib/uri/ftp.rb#166
  def check_typecode(v); end

  class << self
    # == Description
    #
    # Creates a new URI::FTP object from components, with syntax checking.
    #
    # The components accepted are +userinfo+, +host+, +port+, +path+, and
    # +typecode+.
    #
    # The components should be provided either as an Array, or as a Hash
    # with keys formed by preceding the component names with a colon.
    #
    # If an Array is used, the components must be passed in the
    # order <code>[userinfo, host, port, path, typecode]</code>.
    #
    # If the path supplied is absolute, it will be escaped in order to
    # make it absolute in the URI.
    #
    # Examples:
    #
    #     require 'uri'
    #
    #     uri1 = URI::FTP.build(['user:password', 'ftp.example.com', nil,
    #       '/path/file.zip', 'i'])
    #     uri1.to_s  # => "ftp://user:password@ftp.example.com/%2Fpath/file.zip;type=i"
    #
    #     uri2 = URI::FTP.build({:host => 'ftp.example.com',
    #       :path => 'ruby/src'})
    #     uri2.to_s  # => "ftp://ftp.example.com/ruby/src"
    #
    # source://uri//lib/uri/ftp.rb#96
    def build(args); end

    # source://uri//lib/uri/ftp.rb#47
    def new2(user, password, host, port, path, typecode = T.unsafe(nil), arg_check = T.unsafe(nil)); end
  end
end

# The "file" URI is defined by RFC8089.
class URI::File < ::URI::Generic
  # raise InvalidURIError
  #
  # @raise [URI::InvalidURIError]
  #
  # source://uri//lib/uri/file.rb#82
  def check_password(user); end

  # raise InvalidURIError
  #
  # @raise [URI::InvalidURIError]
  #
  # source://uri//lib/uri/file.rb#77
  def check_user(user); end

  # raise InvalidURIError
  #
  # @raise [URI::InvalidURIError]
  #
  # source://uri//lib/uri/file.rb#72
  def check_userinfo(user); end

  # Protected setter for the host component +v+.
  #
  # See also URI::Generic.host=.
  #
  # source://uri//lib/uri/file.rb#62
  def set_host(v); end

  # do nothing
  #
  # source://uri//lib/uri/file.rb#95
  def set_password(v); end

  # do nothing
  #
  # source://uri//lib/uri/file.rb#68
  def set_port(v); end

  # do nothing
  #
  # source://uri//lib/uri/file.rb#91
  def set_user(v); end

  # do nothing
  #
  # source://uri//lib/uri/file.rb#87
  def set_userinfo(v); end

  class << self
    # == Description
    #
    # Creates a new URI::File object from components, with syntax checking.
    #
    # The components accepted are +host+ and +path+.
    #
    # The components should be provided either as an Array, or as a Hash
    # with keys formed by preceding the component names with a colon.
    #
    # If an Array is used, the components must be passed in the
    # order <code>[host, path]</code>.
    #
    # A path from e.g. the File class should be escaped before
    # being passed.
    #
    # Examples:
    #
    #     require 'uri'
    #
    #     uri1 = URI::File.build(['host.example.com', '/path/file.zip'])
    #     uri1.to_s  # => "file://host.example.com/path/file.zip"
    #
    #     uri2 = URI::File.build({:host => 'host.example.com',
    #       :path => '/ruby/src'})
    #     uri2.to_s  # => "file://host.example.com/ruby/src"
    #
    #     uri3 = URI::File.build({:path => URI::escape('/path/my file.txt')})
    #     uri3.to_s  # => "file:///path/my%20file.txt"
    #
    # source://uri//lib/uri/file.rb#53
    def build(args); end
  end
end

# An Array of the available components for URI::File.
#
# source://uri//lib/uri/file.rb#17
URI::File::COMPONENT = T.let(T.unsafe(nil), Array)

# A Default port of nil for URI::File.
#
# source://uri//lib/uri/file.rb#12
URI::File::DEFAULT_PORT = T.let(T.unsafe(nil), T.untyped)

# Base class for all URI classes.
# Implements generic URI syntax as per RFC 2396.
class URI::Generic
  include ::URI::RFC2396_REGEXP
  include ::URI

  # == Args
  #
  # +scheme+::
  #   Protocol scheme, i.e. 'http','ftp','mailto' and so on.
  # +userinfo+::
  #   User name and password, i.e. 'sdmitry:bla'.
  # +host+::
  #   Server host name.
  # +port+::
  #   Server port.
  # +registry+::
  #   Registry of naming authorities.
  # +path+::
  #   Path on server.
  # +opaque+::
  #   Opaque part.
  # +query+::
  #   Query data.
  # +fragment+::
  #   Part of the URI after '#' character.
  # +parser+::
  #   Parser for internal use [URI::DEFAULT_PARSER by default].
  # +arg_check+::
  #   Check arguments [false by default].
  #
  # == Description
  #
  # Creates a new URI::Generic instance from ``generic'' components without check.
  #
  # @return [Generic] a new instance of Generic
  #
  # source://uri//lib/uri/generic.rb#169
  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser = T.unsafe(nil), arg_check = T.unsafe(nil)); end

  # == Args
  #
  # +oth+::
  #    URI or String
  #
  # == Description
  #
  # Merges two URIs.
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   uri = URI.parse("http://my.example.com")
  #   uri.merge("/main.rbx?page=1")
  #   # => "http://my.example.com/main.rbx?page=1"
  # merge
  #
  # source://uri//lib/uri/generic.rb#1109
  def +(oth); end

  # == Args
  #
  # +oth+::
  #    URI or String
  #
  # == Description
  #
  # Calculates relative path from oth to self.
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   uri = URI.parse('http://my.example.com/main.rbx?page=1')
  #   uri.route_from('http://my.example.com')
  #   #=> #<URI::Generic /main.rbx?page=1>
  #
  # source://uri//lib/uri/generic.rb#1262
  def -(oth); end

  # Compares two URIs.
  #
  # source://uri//lib/uri/generic.rb#1384
  def ==(oth); end

  # Returns true if URI has a scheme (e.g. http:// or https://) specified.
  #
  # @return [Boolean]
  #
  # source://uri//lib/uri/generic.rb#972
  def absolute; end

  # Returns true if URI has a scheme (e.g. http:// or https://) specified.
  #
  # @return [Boolean]
  #
  # source://uri//lib/uri/generic.rb#972
  def absolute?; end

  # == Args
  #
  # +v+::
  #    URI or String
  #
  # == Description
  #
  # Attempts to parse other URI +oth+,
  # returns [parsed_oth, self].
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   uri = URI.parse("http://my.example.com")
  #   uri.coerce("http://foo.com")
  #   #=> [#<URI::HTTP http://foo.com>, #<URI::HTTP http://my.example.com>]
  #
  # source://uri//lib/uri/generic.rb#1474
  def coerce(oth); end

  # Components of the URI in the order.
  #
  # source://uri//lib/uri/generic.rb#313
  def component; end

  # Returns the password component after URI decoding.
  #
  # source://uri//lib/uri/generic.rb#583
  def decoded_password; end

  # Returns the user component after URI decoding.
  #
  # source://uri//lib/uri/generic.rb#578
  def decoded_user; end

  # Returns default port.
  #
  # source://uri//lib/uri/generic.rb#39
  def default_port; end

  # @return [Boolean]
  #
  # source://uri//lib/uri/generic.rb#1396
  def eql?(oth); end

  # Returns a proxy URI.
  # The proxy URI is obtained from environment variables such as http_proxy,
  # ftp_proxy, no_proxy, etc.
  # If there is no proper proxy, nil is returned.
  #
  # If the optional parameter +env+ is specified, it is used instead of ENV.
  #
  # Note that capitalized variables (HTTP_PROXY, FTP_PROXY, NO_PROXY, etc.)
  # are examined, too.
  #
  # But http_proxy and HTTP_PROXY is treated specially under CGI environment.
  # It's because HTTP_PROXY may be set by Proxy: header.
  # So HTTP_PROXY is not used.
  # http_proxy is not used too if the variable is case insensitive.
  # CGI_HTTP_PROXY can be used instead.
  #
  # @raise [BadURIError]
  #
  # source://uri//lib/uri/generic.rb#1500
  def find_proxy(env = T.unsafe(nil)); end

  # Returns the fragment component of the URI.
  #
  #   URI("http://foo/bar/baz?search=FooBar#ponies").fragment #=> "ponies"
  #
  # source://uri//lib/uri/generic.rb#283
  def fragment; end

  # Checks the fragment +v+ component against the URI::Parser Regexp for :FRAGMENT.
  #
  #
  # == Args
  #
  # +v+::
  #    String
  #
  # == Description
  #
  # Public setter for the fragment component +v+
  # (with validation).
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   uri = URI.parse("http://my.example.com/?id=25#time=1305212049")
  #   uri.fragment = "time=1305212086"
  #   uri.to_s  #=> "http://my.example.com/?id=25#time=1305212086"
  #
  # source://uri//lib/uri/generic.rb#929
  def fragment=(v); end

  # source://uri//lib/uri/generic.rb#1392
  def hash; end

  # Returns true if URI is hierarchical.
  #
  # == Description
  #
  # URI has components listed in order of decreasing significance from left to right,
  # see RFC3986 https://tools.ietf.org/html/rfc3986 1.2.3.
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   uri = URI.parse("http://my.example.com/")
  #   uri.hierarchical?
  #   #=> true
  #   uri = URI.parse("mailto:joe@example.com")
  #   uri.hierarchical?
  #   #=> false
  #
  # @return [Boolean]
  #
  # source://uri//lib/uri/generic.rb#961
  def hierarchical?; end

  # Returns the host component of the URI.
  #
  #   URI("http://foo/bar/baz").host #=> "foo"
  #
  # It returns nil if no host component exists.
  #
  #   URI("mailto:foo@example.org").host #=> nil
  #
  # The component does not contain the port number.
  #
  #   URI("http://foo:8080/bar/baz").host #=> "foo"
  #
  # Since IPv6 addresses are wrapped with brackets in URIs,
  # this method returns IPv6 addresses wrapped with brackets.
  # This form is not appropriate to pass to socket methods such as TCPSocket.open.
  # If unwrapped host names are required, use the #hostname method.
  #
  #   URI("http://[::1]/bar/baz").host     #=> "[::1]"
  #   URI("http://[::1]/bar/baz").hostname #=> "::1"
  #
  # source://uri//lib/uri/generic.rb#243
  def host; end

  # == Args
  #
  # +v+::
  #    String
  #
  # == Description
  #
  # Public setter for the host component +v+
  # (with validation).
  #
  # See also URI::Generic.check_host.
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   uri = URI.parse("http://my.example.com")
  #   uri.host = "foo.com"
  #   uri.to_s  #=> "http://foo.com"
  #
  # source://uri//lib/uri/generic.rb#639
  def host=(v); end

  # Extract the host part of the URI and unwrap brackets for IPv6 addresses.
  #
  # This method is the same as URI::Generic#host except
  # brackets for IPv6 (and future IP) addresses are removed.
  #
  #   uri = URI("http://[::1]/bar")
  #   uri.hostname      #=> "::1"
  #   uri.host          #=> "[::1]"
  #
  # source://uri//lib/uri/generic.rb#654
  def hostname; end

  # Sets the host part of the URI as the argument with brackets for IPv6 addresses.
  #
  # This method is the same as URI::Generic#host= except
  # the argument can be a bare IPv6 address.
  #
  #   uri = URI("http://foo/bar")
  #   uri.hostname = "::1"
  #   uri.to_s  #=> "http://[::1]/bar"
  #
  # If the argument seems to be an IPv6 address,
  # it is wrapped with brackets.
  #
  # source://uri//lib/uri/generic.rb#671
  def hostname=(v); end

  # source://uri//lib/uri/generic.rb#1451
  def inspect; end

  # == Args
  #
  # +oth+::
  #    URI or String
  #
  # == Description
  #
  # Merges two URIs.
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   uri = URI.parse("http://my.example.com")
  #   uri.merge("/main.rbx?page=1")
  #   # => "http://my.example.com/main.rbx?page=1"
  #
  # source://uri//lib/uri/generic.rb#1109
  def merge(oth); end

  # == Args
  #
  # +oth+::
  #    URI or String
  #
  # == Description
  #
  # Destructive form of #merge.
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   uri = URI.parse("http://my.example.com")
  #   uri.merge!("/main.rbx?page=1")
  #   uri.to_s  # => "http://my.example.com/main.rbx?page=1"
  #
  # source://uri//lib/uri/generic.rb#1081
  def merge!(oth); end

  # Returns normalized URI.
  #
  #   require 'uri'
  #
  #   URI("HTTP://my.EXAMPLE.com").normalize
  #   #=> #<URI::HTTP http://my.example.com/>
  #
  # Normalization here means:
  #
  # * scheme and host are converted to lowercase,
  # * an empty path component is set to "/".
  #
  # source://uri//lib/uri/generic.rb#1319
  def normalize; end

  # Destructive version of #normalize.
  #
  # source://uri//lib/uri/generic.rb#1328
  def normalize!; end

  # Returns the opaque part of the URI.
  #
  #   URI("mailto:foo@example.org").opaque #=> "foo@example.org"
  #   URI("http://foo/bar/baz").opaque     #=> nil
  #
  # The portion of the path that does not make use of the slash '/'.
  # The path typically refers to an absolute path or an opaque part.
  # (See RFC2396 Section 3 and 5.2.)
  #
  # source://uri//lib/uri/generic.rb#277
  def opaque; end

  # == Args
  #
  # +v+::
  #    String
  #
  # == Description
  #
  # Public setter for the opaque component +v+
  # (with validation).
  #
  # See also URI::Generic.check_opaque.
  #
  # source://uri//lib/uri/generic.rb#901
  def opaque=(v); end

  # Returns the parser to be used.
  #
  # Unless a URI::Parser is defined, DEFAULT_PARSER is used.
  #
  # source://uri//lib/uri/generic.rb#289
  def parser; end

  # Returns the password component (without URI decoding).
  #
  # source://uri//lib/uri/generic.rb#573
  def password; end

  # == Args
  #
  # +v+::
  #    String
  #
  # == Description
  #
  # Public setter for the +password+ component
  # (with validation).
  #
  # See also URI::Generic.check_password.
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   uri = URI.parse("http://john:S3nsit1ve@my.example.com")
  #   uri.password = "V3ry_S3nsit1ve"
  #   uri.to_s  #=> "http://john:V3ry_S3nsit1ve@my.example.com"
  #
  # source://uri//lib/uri/generic.rb#498
  def password=(password); end

  # Returns the path component of the URI.
  #
  #   URI("http://foo/bar/baz").path #=> "/bar/baz"
  #
  # source://uri//lib/uri/generic.rb#260
  def path; end

  # == Args
  #
  # +v+::
  #    String
  #
  # == Description
  #
  # Public setter for the path component +v+
  # (with validation).
  #
  # See also URI::Generic.check_path.
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   uri = URI.parse("http://my.example.com/pub/files")
  #   uri.path = "/faq/"
  #   uri.to_s  #=> "http://my.example.com/faq/"
  #
  # source://uri//lib/uri/generic.rb#815
  def path=(v); end

  # Returns the port component of the URI.
  #
  #   URI("http://foo/bar/baz").port      #=> 80
  #   URI("http://foo:8080/bar/baz").port #=> 8080
  #
  # source://uri//lib/uri/generic.rb#250
  def port; end

  # == Args
  #
  # +v+::
  #    String
  #
  # == Description
  #
  # Public setter for the port component +v+
  # (with validation).
  #
  # See also URI::Generic.check_port.
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   uri = URI.parse("http://my.example.com")
  #   uri.port = 8080
  #   uri.to_s  #=> "http://my.example.com:8080"
  #
  # source://uri//lib/uri/generic.rb#729
  def port=(v); end

  # Returns the query component of the URI.
  #
  #   URI("http://foo/bar/baz?search=FooBar").query #=> "search=FooBar"
  #
  # source://uri//lib/uri/generic.rb#266
  def query; end

  # == Args
  #
  # +v+::
  #    String
  #
  # == Description
  #
  # Public setter for the query component +v+.
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   uri = URI.parse("http://my.example.com/?id=25")
  #   uri.query = "id=1"
  #   uri.to_s  #=> "http://my.example.com/?id=1"
  #
  # @raise [InvalidURIError]
  #
  # source://uri//lib/uri/generic.rb#839
  def query=(v); end

  # source://uri//lib/uri/generic.rb#252
  def registry; end

  # @raise [InvalidURIError]
  #
  # source://uri//lib/uri/generic.rb#745
  def registry=(v); end

  # Returns true if URI does not have a scheme (e.g. http:// or https://) specified.
  #
  # @return [Boolean]
  #
  # source://uri//lib/uri/generic.rb#984
  def relative?; end

  # == Args
  #
  # +oth+::
  #    URI or String
  #
  # == Description
  #
  # Calculates relative path from oth to self.
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   uri = URI.parse('http://my.example.com/main.rbx?page=1')
  #   uri.route_from('http://my.example.com')
  #   #=> #<URI::Generic /main.rbx?page=1>
  #
  # source://uri//lib/uri/generic.rb#1262
  def route_from(oth); end

  # == Args
  #
  # +oth+::
  #    URI or String
  #
  # == Description
  #
  # Calculates relative path to oth from self.
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   uri = URI.parse('http://my.example.com')
  #   uri.route_to('http://my.example.com/main.rbx?page=1')
  #   #=> #<URI::Generic /main.rbx?page=1>
  #
  # source://uri//lib/uri/generic.rb#1302
  def route_to(oth); end

  # Returns the scheme component of the URI.
  #
  #   URI("http://foo/bar/baz").scheme #=> "http"
  #
  # source://uri//lib/uri/generic.rb#221
  def scheme; end

  # == Args
  #
  # +v+::
  #    String
  #
  # == Description
  #
  # Public setter for the scheme component +v+
  # (with validation).
  #
  # See also URI::Generic.check_scheme.
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   uri = URI.parse("http://my.example.com")
  #   uri.scheme = "https"
  #   uri.to_s  #=> "https://my.example.com"
  #
  # source://uri//lib/uri/generic.rb#360
  def scheme=(v); end

  # == Args
  #
  # +components+::
  #    Multiple Symbol arguments defined in URI::HTTP.
  #
  # == Description
  #
  # Selects specified components from URI.
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   uri = URI.parse('http://myuser:mypass@my.example.com/test.rbx')
  #   uri.select(:userinfo, :host, :path)
  #   # => ["myuser:mypass", "my.example.com", "/test.rbx"]
  #
  # source://uri//lib/uri/generic.rb#1440
  def select(*components); end

  # Constructs String from URI.
  #
  # source://uri//lib/uri/generic.rb#1343
  def to_s; end

  # Constructs String from URI.
  #
  # source://uri//lib/uri/generic.rb#1343
  def to_str; end

  # Returns the user component (without URI decoding).
  #
  # source://uri//lib/uri/generic.rb#568
  def user; end

  # == Args
  #
  # +v+::
  #    String
  #
  # == Description
  #
  # Public setter for the +user+ component
  # (with validation).
  #
  # See also URI::Generic.check_user.
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   uri = URI.parse("http://john:S3nsit1ve@my.example.com")
  #   uri.user = "sam"
  #   uri.to_s  #=> "http://sam:V3ry_S3nsit1ve@my.example.com"
  #
  # source://uri//lib/uri/generic.rb#471
  def user=(user); end

  # Returns the userinfo, either as 'user' or 'user:password'.
  #
  # source://uri//lib/uri/generic.rb#557
  def userinfo; end

  # Sets userinfo, argument is string like 'name:pass'.
  #
  # source://uri//lib/uri/generic.rb#441
  def userinfo=(userinfo); end

  protected

  # Returns an Array of the components defined from the COMPONENT Array.
  #
  # source://uri//lib/uri/generic.rb#1416
  def component_ary; end

  # Protected setter for the host component +v+.
  #
  # See also URI::Generic.host=.
  #
  # source://uri//lib/uri/generic.rb#613
  def set_host(v); end

  # Protected setter for the opaque component +v+.
  #
  # See also URI::Generic.opaque=.
  #
  # source://uri//lib/uri/generic.rb#883
  def set_opaque(v); end

  # Protected setter for the password component +v+.
  #
  # See also URI::Generic.password=.
  #
  # source://uri//lib/uri/generic.rb#534
  def set_password(v); end

  # Protected setter for the path component +v+.
  #
  # See also URI::Generic.path=.
  #
  # source://uri//lib/uri/generic.rb#789
  def set_path(v); end

  # Protected setter for the port component +v+.
  #
  # See also URI::Generic.port=.
  #
  # source://uri//lib/uri/generic.rb#702
  def set_port(v); end

  # @raise [InvalidURIError]
  #
  # source://uri//lib/uri/generic.rb#740
  def set_registry(v); end

  # Protected setter for the scheme component +v+.
  #
  # See also URI::Generic.scheme=.
  #
  # source://uri//lib/uri/generic.rb#334
  def set_scheme(v); end

  # Protected setter for the user component +v+.
  #
  # See also URI::Generic.user=.
  #
  # source://uri//lib/uri/generic.rb#524
  def set_user(v); end

  # Protected setter for the +user+ component, and +password+ if available
  # (with validation).
  #
  # See also URI::Generic.userinfo=.
  #
  # source://uri//lib/uri/generic.rb#509
  def set_userinfo(user, password = T.unsafe(nil)); end

  private

  # Checks the host +v+ component for RFC2396 compliance
  # and against the URI::Parser Regexp for :HOST.
  #
  # Can not have a registry or opaque component defined,
  # with a host component defined.
  #
  # source://uri//lib/uri/generic.rb#594
  def check_host(v); end

  # Checks the opaque +v+ component for RFC2396 compliance and
  # against the URI::Parser Regexp for :OPAQUE.
  #
  # Can not have a host, port, user, or path component defined,
  # with an opaque component defined.
  #
  # source://uri//lib/uri/generic.rb#861
  def check_opaque(v); end

  # Checks the password +v+ component for RFC2396 compliance
  # and against the URI::Parser Regexp for :USERINFO.
  #
  # Can not have a registry or opaque component defined,
  # with a user component defined.
  #
  # source://uri//lib/uri/generic.rb#417
  def check_password(v, user = T.unsafe(nil)); end

  # Checks the path +v+ component for RFC2396 compliance
  # and against the URI::Parser Regexp
  # for :ABS_PATH and :REL_PATH.
  #
  # Can not have a opaque component defined,
  # with a path component defined.
  #
  # source://uri//lib/uri/generic.rb#757
  def check_path(v); end

  # Checks the port +v+ component for RFC2396 compliance
  # and against the URI::Parser Regexp for :PORT.
  #
  # Can not have a registry or opaque component defined,
  # with a port component defined.
  #
  # source://uri//lib/uri/generic.rb#683
  def check_port(v); end

  # @raise [InvalidURIError]
  #
  # source://uri//lib/uri/generic.rb#735
  def check_registry(v); end

  # Checks the scheme +v+ component against the URI::Parser Regexp for :SCHEME.
  #
  # source://uri//lib/uri/generic.rb#320
  def check_scheme(v); end

  # Checks the user +v+ component for RFC2396 compliance
  # and against the URI::Parser Regexp for :USERINFO.
  #
  # Can not have a registry or opaque component defined,
  # with a user component defined.
  #
  # source://uri//lib/uri/generic.rb#393
  def check_user(v); end

  # Checks the +user+ and +password+.
  #
  # If +password+ is not provided, then +user+ is
  # split, using URI::Generic.split_userinfo, to
  # pull +user+ and +password.
  #
  # See also URI::Generic.check_user, URI::Generic.check_password.
  #
  # source://uri//lib/uri/generic.rb#375
  def check_userinfo(user, password = T.unsafe(nil)); end

  # Escapes 'user:password' +v+ based on RFC 1738 section 3.1.
  #
  # source://uri//lib/uri/generic.rb#551
  def escape_userpass(v); end

  # Merges a base path +base+, with relative path +rel+,
  # returns a modified base path.
  #
  # source://uri//lib/uri/generic.rb#1000
  def merge_path(base, rel); end

  # Replaces self by other URI object.
  #
  # source://uri//lib/uri/generic.rb#299
  def replace!(oth); end

  # :stopdoc:
  #
  # source://uri//lib/uri/generic.rb#1194
  def route_from0(oth); end

  # :stopdoc:
  #
  # source://uri//lib/uri/generic.rb#1155
  def route_from_path(src, dst); end

  # Returns an Array of the path split on '/'.
  #
  # source://uri//lib/uri/generic.rb#991
  def split_path(path); end

  # Returns the userinfo +ui+ as <code>[user, password]</code>
  # if properly formatted as 'user:password'.
  #
  # source://uri//lib/uri/generic.rb#542
  def split_userinfo(ui); end

  class << self
    # == Synopsis
    #
    # See ::new.
    #
    # == Description
    #
    # Creates a new URI::Generic instance from components of URI::Generic
    # with check.  Components are: scheme, userinfo, host, port, registry, path,
    # opaque, query, and fragment. You can provide arguments either by an Array or a Hash.
    # See ::new for hash keys to use or for order of array items.
    #
    # source://uri//lib/uri/generic.rb#116
    def build(args); end

    # == Synopsis
    #
    # See ::new.
    #
    # == Description
    #
    # At first, tries to create a new URI::Generic instance using
    # URI::Generic::build. But, if exception URI::InvalidComponentError is raised,
    # then it does URI::Escape.escape all URI components and tries again.
    #
    # source://uri//lib/uri/generic.rb#78
    def build2(args); end

    # Components of the URI in the order.
    #
    # source://uri//lib/uri/generic.rb#57
    def component; end

    # Returns default port.
    #
    # source://uri//lib/uri/generic.rb#32
    def default_port; end

    # @return [Boolean]
    #
    # source://uri//lib/uri/generic.rb#1566
    def use_proxy?(hostname, addr, port, no_proxy); end

    # source://uri//lib/uri/generic.rb#63
    def use_registry; end
  end
end

# The syntax of HTTP URIs is defined in RFC1738 section 3.3.
#
# Note that the Ruby URI library allows HTTP URLs containing usernames and
# passwords. This is not legal as per the RFC, but used to be
# supported in Internet Explorer 5 and 6, before the MS04-004 security
# update. See <URL:http://support.microsoft.com/kb/834489>.
class URI::HTTP < ::URI::Generic
  # == Description
  #
  # Returns the authority for an HTTP uri, as defined in
  # https://datatracker.ietf.org/doc/html/rfc3986/#section-3.2.
  #
  #
  # Example:
  #
  #     URI::HTTP.build(host: 'www.example.com', path: '/foo/bar').authority #=> "www.example.com"
  #     URI::HTTP.build(host: 'www.example.com', port: 8000, path: '/foo/bar').authority #=> "www.example.com:8000"
  #     URI::HTTP.build(host: 'www.example.com', port: 80, path: '/foo/bar').authority #=> "www.example.com"
  #
  # source://uri//lib/uri/http.rb#97
  def authority; end

  # == Description
  #
  # Returns the origin for an HTTP uri, as defined in
  # https://datatracker.ietf.org/doc/html/rfc6454.
  #
  #
  # Example:
  #
  #     URI::HTTP.build(host: 'www.example.com', path: '/foo/bar').origin #=> "http://www.example.com"
  #     URI::HTTP.build(host: 'www.example.com', port: 8000, path: '/foo/bar').origin #=> "http://www.example.com:8000"
  #     URI::HTTP.build(host: 'www.example.com', port: 80, path: '/foo/bar').origin #=> "http://www.example.com"
  #     URI::HTTPS.build(host: 'www.example.com', path: '/foo/bar').origin #=> "https://www.example.com"
  #
  # source://uri//lib/uri/http.rb#119
  def origin; end

  # == Description
  #
  # Returns the full path for an HTTP request, as required by Net::HTTP::Get.
  #
  # If the URI contains a query, the full path is URI#path + '?' + URI#query.
  # Otherwise, the path is simply URI#path.
  #
  # Example:
  #
  #     uri = URI::HTTP.build(path: '/foo/bar', query: 'test=true')
  #     uri.request_uri #  => "/foo/bar?test=true"
  #
  # source://uri//lib/uri/http.rb#77
  def request_uri; end

  class << self
    # == Description
    #
    # Creates a new URI::HTTP object from components, with syntax checking.
    #
    # The components accepted are userinfo, host, port, path, query, and
    # fragment.
    #
    # The components should be provided either as an Array, or as a Hash
    # with keys formed by preceding the component names with a colon.
    #
    # If an Array is used, the components must be passed in the
    # order <code>[userinfo, host, port, path, query, fragment]</code>.
    #
    # Example:
    #
    #     uri = URI::HTTP.build(host: 'www.example.com', path: '/foo/bar')
    #
    #     uri = URI::HTTP.build([nil, "www.example.com", nil, "/path",
    #       "query", 'fragment'])
    #
    # Currently, if passed userinfo components this method generates
    # invalid HTTP URIs as per RFC 1738.
    #
    # source://uri//lib/uri/http.rb#59
    def build(args); end
  end
end

# source://uri//lib/uri/common.rb#103
URI::INITIAL_SCHEMES = T.let(T.unsafe(nil), Hash)

# LDAP URI SCHEMA (described in RFC2255).
# --
# ldap://<host>/<dn>[?<attrs>[?<scope>[?<filter>[?<extensions>]]]]
# ++
class URI::LDAP < ::URI::Generic
  # == Description
  #
  # Creates a new URI::LDAP object from generic URI components as per
  # RFC 2396. No LDAP-specific syntax checking is performed.
  #
  # Arguments are +scheme+, +userinfo+, +host+, +port+, +registry+, +path+,
  # +opaque+, +query+, and +fragment+, in that order.
  #
  # Example:
  #
  #     uri = URI::LDAP.new("ldap", nil, "ldap.example.com", nil, nil,
  #       "/dc=example;dc=com", nil, "query", nil)
  #
  # See also URI::Generic.new.
  #
  # @return [LDAP] a new instance of LDAP
  #
  # source://uri//lib/uri/ldap.rb#108
  def initialize(*arg); end

  # Returns attributes.
  #
  # source://uri//lib/uri/ldap.rb#178
  def attributes; end

  # Setter for attributes +val+.
  #
  # source://uri//lib/uri/ldap.rb#191
  def attributes=(val); end

  # Returns dn.
  #
  # source://uri//lib/uri/ldap.rb#159
  def dn; end

  # Setter for dn +val+.
  #
  # source://uri//lib/uri/ldap.rb#172
  def dn=(val); end

  # Returns extensions.
  #
  # source://uri//lib/uri/ldap.rb#235
  def extensions; end

  # Setter for extensions +val+.
  #
  # source://uri//lib/uri/ldap.rb#248
  def extensions=(val); end

  # Returns filter.
  #
  # source://uri//lib/uri/ldap.rb#216
  def filter; end

  # Setter for filter +val+.
  #
  # source://uri//lib/uri/ldap.rb#229
  def filter=(val); end

  # Checks if URI has a path.
  # For URI::LDAP this will return +false+.
  #
  # @return [Boolean]
  #
  # source://uri//lib/uri/ldap.rb#255
  def hierarchical?; end

  # Returns scope.
  #
  # source://uri//lib/uri/ldap.rb#197
  def scope; end

  # Setter for scope +val+.
  #
  # source://uri//lib/uri/ldap.rb#210
  def scope=(val); end

  protected

  # Private setter for attributes +val+.
  #
  # source://uri//lib/uri/ldap.rb#183
  def set_attributes(val); end

  # Private setter for dn +val+.
  #
  # source://uri//lib/uri/ldap.rb#164
  def set_dn(val); end

  # Private setter for extensions +val+.
  #
  # source://uri//lib/uri/ldap.rb#240
  def set_extensions(val); end

  # Private setter for filter +val+.
  #
  # source://uri//lib/uri/ldap.rb#221
  def set_filter(val); end

  # Private setter for scope +val+.
  #
  # source://uri//lib/uri/ldap.rb#202
  def set_scope(val); end

  private

  # Private method to assemble +query+ from +attributes+, +scope+, +filter+, and +extensions+.
  #
  # source://uri//lib/uri/ldap.rb#146
  def build_path_query; end

  # Private method to cleanup +dn+ from using the +path+ component attribute.
  #
  # @raise [InvalidURIError]
  #
  # source://uri//lib/uri/ldap.rb#120
  def parse_dn; end

  # Private method to cleanup +attributes+, +scope+, +filter+, and +extensions+
  # from using the +query+ component attribute.
  #
  # source://uri//lib/uri/ldap.rb#128
  def parse_query; end

  class << self
    # == Description
    #
    # Creates a new URI::LDAP object from components, with syntax checking.
    #
    # The components accepted are host, port, dn, attributes,
    # scope, filter, and extensions.
    #
    # The components should be provided either as an Array, or as a Hash
    # with keys formed by preceding the component names with a colon.
    #
    # If an Array is used, the components must be passed in the
    # order <code>[host, port, dn, attributes, scope, filter, extensions]</code>.
    #
    # Example:
    #
    #     uri = URI::LDAP.build({:host => 'ldap.example.com',
    #       :dn => '/dc=example'})
    #
    #     uri = URI::LDAP.build(["ldap.example.com", nil,
    #       "/dc=example;dc=com", "query", nil, nil, nil])
    #
    # source://uri//lib/uri/ldap.rb#74
    def build(args); end
  end
end

# RFC6068, the mailto URL scheme.
class URI::MailTo < ::URI::Generic
  # == Description
  #
  # Creates a new URI::MailTo object from generic URL components with
  # no syntax checking.
  #
  # This method is usually called from URI::parse, which checks
  # the validity of each component.
  #
  # @return [MailTo] a new instance of MailTo
  #
  # source://uri//lib/uri/mailto.rb#132
  def initialize(*arg); end

  # E-mail headers set by the URL, as an Array of Arrays.
  #
  # source://uri//lib/uri/mailto.rb#166
  def headers; end

  # Setter for headers +v+.
  #
  # source://uri//lib/uri/mailto.rb#232
  def headers=(v); end

  # The primary e-mail address of the URL, as a String.
  #
  # source://uri//lib/uri/mailto.rb#163
  def to; end

  # Setter for to +v+.
  #
  # source://uri//lib/uri/mailto.rb#200
  def to=(v); end

  # Returns the RFC822 e-mail text equivalent of the URL, as a String.
  #
  # Example:
  #
  #   require 'uri'
  #
  #   uri = URI.parse("mailto:ruby-list@ruby-lang.org?Subject=subscribe&cc=myaddr")
  #   uri.to_mailtext
  #   # => "To: ruby-list@ruby-lang.org\nSubject: subscribe\nCc: myaddr\n\n\n"
  #
  # source://uri//lib/uri/mailto.rb#268
  def to_mailtext; end

  # Returns the RFC822 e-mail text equivalent of the URL, as a String.
  #
  # Example:
  #
  #   require 'uri'
  #
  #   uri = URI.parse("mailto:ruby-list@ruby-lang.org?Subject=subscribe&cc=myaddr")
  #   uri.to_mailtext
  #   # => "To: ruby-list@ruby-lang.org\nSubject: subscribe\nCc: myaddr\n\n\n"
  #
  # source://uri//lib/uri/mailto.rb#268
  def to_rfc822text; end

  # Constructs String from URI.
  #
  # source://uri//lib/uri/mailto.rb#239
  def to_s; end

  protected

  # Private setter for headers +v+.
  #
  # source://uri//lib/uri/mailto.rb#221
  def set_headers(v); end

  # Private setter for to +v+.
  #
  # source://uri//lib/uri/mailto.rb#194
  def set_to(v); end

  private

  # Checks the headers +v+ component against either
  # * HEADER_REGEXP
  #
  # source://uri//lib/uri/mailto.rb#208
  def check_headers(v); end

  # Checks the to +v+ component.
  #
  # source://uri//lib/uri/mailto.rb#169
  def check_to(v); end

  class << self
    # == Description
    #
    # Creates a new URI::MailTo object from components, with syntax checking.
    #
    # Components can be provided as an Array or Hash. If an Array is used,
    # the components must be supplied as <code>[to, headers]</code>.
    #
    # If a Hash is used, the keys are the component names preceded by colons.
    #
    # The headers can be supplied as a pre-encoded string, such as
    # <code>"subject=subscribe&cc=address"</code>, or as an Array of Arrays
    # like <code>[['subject', 'subscribe'], ['cc', 'address']]</code>.
    #
    # Examples:
    #
    #    require 'uri'
    #
    #    m1 = URI::MailTo.build(['joe@example.com', 'subject=Ruby'])
    #    m1.to_s  # => "mailto:joe@example.com?subject=Ruby"
    #
    #    m2 = URI::MailTo.build(['john@example.com', [['Subject', 'Ruby'], ['Cc', 'jack@example.com']]])
    #    m2.to_s  # => "mailto:john@example.com?Subject=Ruby&Cc=jack@example.com"
    #
    #    m3 = URI::MailTo.build({:to => 'listman@example.com', :headers => [['subject', 'subscribe']]})
    #    m3.to_s  # => "mailto:listman@example.com?subject=subscribe"
    #
    # source://uri//lib/uri/mailto.rb#85
    def build(args); end
  end
end

# Class that parses String's into URI's.
#
# It contains a Hash set of patterns and Regexp's that match and validate.
class URI::RFC2396_Parser
  include ::URI::RFC2396_REGEXP

  # == Synopsis
  #
  #   URI::Parser.new([opts])
  #
  # == Args
  #
  # The constructor accepts a hash as options for parser.
  # Keys of options are pattern names of URI components
  # and values of options are pattern strings.
  # The constructor generates set of regexps for parsing URIs.
  #
  # You can use the following keys:
  #
  #   * :ESCAPED (URI::PATTERN::ESCAPED in default)
  #   * :UNRESERVED (URI::PATTERN::UNRESERVED in default)
  #   * :DOMLABEL (URI::PATTERN::DOMLABEL in default)
  #   * :TOPLABEL (URI::PATTERN::TOPLABEL in default)
  #   * :HOSTNAME (URI::PATTERN::HOSTNAME in default)
  #
  # == Examples
  #
  #   p = URI::Parser.new(:ESCAPED => "(?:%[a-fA-F0-9]{2}|%u[a-fA-F0-9]{4})")
  #   u = p.parse("http://example.jp/%uABCD") #=> #<URI::HTTP http://example.jp/%uABCD>
  #   URI.parse(u.to_s) #=> raises URI::InvalidURIError
  #
  #   s = "http://example.com/ABCD"
  #   u1 = p.parse(s) #=> #<URI::HTTP http://example.com/ABCD>
  #   u2 = URI.parse(s) #=> #<URI::HTTP http://example.com/ABCD>
  #   u1 == u2 #=> true
  #   u1.eql?(u2) #=> false
  #
  # @return [RFC2396_Parser] a new instance of RFC2396_Parser
  #
  # source://uri//lib/uri/rfc2396_parser.rb#99
  def initialize(opts = T.unsafe(nil)); end

  # :call-seq:
  #   escape( str )
  #   escape( str, unsafe )
  #
  # == Args
  #
  # +str+::
  #    String to make safe
  # +unsafe+::
  #    Regexp to apply. Defaults to +self.regexp[:UNSAFE]+
  #
  # == Description
  #
  # Constructs a safe String from +str+, removing unsafe characters,
  # replacing them with codes.
  #
  # source://uri//lib/uri/rfc2396_parser.rb#287
  def escape(str, unsafe = T.unsafe(nil)); end

  # :call-seq:
  #   extract( str )
  #   extract( str, schemes )
  #   extract( str, schemes ) {|item| block }
  #
  # == Args
  #
  # +str+::
  #    String to search
  # +schemes+::
  #    Patterns to apply to +str+
  #
  # == Description
  #
  # Attempts to parse and merge a set of URIs.
  # If no +block+ given, then returns the result,
  # else it calls +block+ for each element in result.
  #
  # See also URI::Parser.make_regexp.
  #
  # source://uri//lib/uri/rfc2396_parser.rb#249
  def extract(str, schemes = T.unsafe(nil)); end

  # source://uri//lib/uri/rfc2396_parser.rb#326
  def inspect; end

  # == Args
  #
  # +uris+::
  #    an Array of Strings
  #
  # == Description
  #
  # Attempts to parse and merge a set of URIs.
  #
  # source://uri//lib/uri/rfc2396_parser.rb#223
  def join(*uris); end

  # Returns Regexp that is default +self.regexp[:ABS_URI_REF]+,
  # unless +schemes+ is provided. Then it is a Regexp.union with +self.pattern[:X_ABS_URI]+.
  #
  # source://uri//lib/uri/rfc2396_parser.rb#262
  def make_regexp(schemes = T.unsafe(nil)); end

  # == Args
  #
  # +uri+::
  #    String
  #
  # == Description
  #
  # Parses +uri+ and constructs either matching URI scheme object
  # (File, FTP, HTTP, HTTPS, LDAP, LDAPS, or MailTo) or URI::Generic.
  #
  # == Usage
  #
  #   p = URI::Parser.new
  #   p.parse("ldap://ldap.example.com/dc=example?user=john")
  #   #=> #<URI::LDAP ldap://ldap.example.com/dc=example?user=john>
  #
  # source://uri//lib/uri/rfc2396_parser.rb#209
  def parse(uri); end

  # The Hash of patterns.
  #
  # See also URI::Parser.initialize_pattern.
  #
  # source://uri//lib/uri/rfc2396_parser.rb#112
  def pattern; end

  # The Hash of Regexp.
  #
  # See also URI::Parser.initialize_regexp.
  #
  # source://uri//lib/uri/rfc2396_parser.rb#117
  def regexp; end

  # Returns a split URI against +regexp[:ABS_URI]+.
  #
  # source://uri//lib/uri/rfc2396_parser.rb#120
  def split(uri); end

  # :call-seq:
  #   unescape( str )
  #   unescape( str, escaped )
  #
  # == Args
  #
  # +str+::
  #    String to remove escapes from
  # +escaped+::
  #    Regexp to apply. Defaults to +self.regexp[:ESCAPED]+
  #
  # == Description
  #
  # Removes escapes from +str+.
  #
  # source://uri//lib/uri/rfc2396_parser.rb#318
  def unescape(str, escaped = T.unsafe(nil)); end

  private

  # source://uri//lib/uri/rfc2396_parser.rb#527
  def convert_to_uri(uri); end

  # Constructs the default Hash of patterns.
  #
  # source://uri//lib/uri/rfc2396_parser.rb#338
  def initialize_pattern(opts = T.unsafe(nil)); end

  # Constructs the default Hash of Regexp's.
  #
  # source://uri//lib/uri/rfc2396_parser.rb#496
  def initialize_regexp(pattern); end
end

class URI::RFC3986_Parser
  # @return [RFC3986_Parser] a new instance of RFC3986_Parser
  #
  # source://uri//lib/uri/rfc3986_parser.rb#73
  def initialize; end

  # source://uri//lib/uri/rfc3986_parser.rb#146
  def inspect; end

  # source://uri//lib/uri/rfc3986_parser.rb#139
  def join(*uris); end

  # source://uri//lib/uri/rfc3986_parser.rb#134
  def parse(uri); end

  # Returns the value of attribute regexp.
  #
  # source://uri//lib/uri/rfc3986_parser.rb#71
  def regexp; end

  # source://uri//lib/uri/rfc3986_parser.rb#77
  def split(uri); end

  private

  # source://uri//lib/uri/rfc3986_parser.rb#171
  def convert_to_uri(uri); end

  # source://uri//lib/uri/rfc3986_parser.rb#157
  def default_regexp; end
end

# source://uri//lib/uri/rfc3986_parser.rb#33
URI::RFC3986_Parser::FRAGMENT = T.let(T.unsafe(nil), String)

# URI defined in RFC3986
#
# source://uri//lib/uri/rfc3986_parser.rb#5
URI::RFC3986_Parser::HOST = T.let(T.unsafe(nil), Regexp)

# source://uri//lib/uri/rfc3986_parser.rb#54
URI::RFC3986_Parser::RFC3986_relative_ref = T.let(T.unsafe(nil), Regexp)

# source://uri//lib/uri/rfc3986_parser.rb#30
URI::RFC3986_Parser::SCHEME = T.let(T.unsafe(nil), String)

# source://uri//lib/uri/rfc3986_parser.rb#31
URI::RFC3986_Parser::SEG = T.let(T.unsafe(nil), String)

# source://uri//lib/uri/rfc3986_parser.rb#32
URI::RFC3986_Parser::SEG_NC = T.let(T.unsafe(nil), String)

# source://uri//lib/uri/rfc3986_parser.rb#28
URI::RFC3986_Parser::USERINFO = T.let(T.unsafe(nil), Regexp)

module URI::Schemes; end

# source://uri//lib/uri/common.rb#80
URI::Schemes::FILE = URI::File

# source://uri//lib/uri/common.rb#80
URI::Schemes::FTP = URI::FTP

# source://uri//lib/uri/common.rb#80
URI::Schemes::HTTP = URI::HTTP

# source://uri//lib/uri/common.rb#80
URI::Schemes::HTTPS = URI::HTTPS

# source://uri//lib/uri/common.rb#80
URI::Schemes::LDAP = URI::LDAP

# source://uri//lib/uri/common.rb#80
URI::Schemes::LDAPS = URI::LDAPS

# source://uri//lib/uri/common.rb#80
URI::Schemes::MAILTO = URI::MailTo

# source://uri//lib/uri/common.rb#80
URI::Schemes::SOURCE = URI::Source

# source://uri//lib/uri/common.rb#80
URI::Schemes::WS = URI::WS

# source://uri//lib/uri/common.rb#80
URI::Schemes::WSS = URI::WSS

class URI::Source < ::URI::File
  # source://tapioca/0.13.3/lib/tapioca/helpers/source_uri.rb#58
  sig { params(v: T.nilable(::String)).returns(T::Boolean) }
  def check_host(v); end

  # source://uri//lib/uri/generic.rb#243
  def gem_name; end

  # source://tapioca/0.13.3/lib/tapioca/helpers/source_uri.rb#25
  sig { returns(T.nilable(::String)) }
  def gem_version; end

  # source://uri//lib/uri/generic.rb#283
  def line_number; end

  # source://tapioca/0.13.3/lib/tapioca/helpers/source_uri.rb#51
  sig { params(v: T.nilable(::String)).void }
  def set_path(v); end

  # source://tapioca/0.13.3/lib/tapioca/helpers/source_uri.rb#70
  sig { returns(::String) }
  def to_s; end

  class << self
    # source://tapioca/0.13.3/lib/tapioca/helpers/source_uri.rb#38
    sig do
      params(
        gem_name: ::String,
        gem_version: T.nilable(::String),
        path: ::String,
        line_number: T.nilable(::String)
      ).returns(::URI::Source)
    end
    def build(gem_name:, gem_version:, path:, line_number:); end
  end
end

# source://uri//lib/uri/common.rb#285
URI::TBLENCURICOMP_ = T.let(T.unsafe(nil), Hash)

module URI::Util
  private

  # source://uri//lib/uri/common.rb#36
  def make_components_hash(klass, array_hash); end

  class << self
    # source://uri//lib/uri/common.rb#36
    def make_components_hash(klass, array_hash); end
  end
end

# The syntax of WS URIs is defined in RFC6455 section 3.
#
# Note that the Ruby URI library allows WS URLs containing usernames and
# passwords. This is not legal as per the RFC, but used to be
# supported in Internet Explorer 5 and 6, before the MS04-004 security
# update. See <URL:http://support.microsoft.com/kb/834489>.
class URI::WS < ::URI::Generic
  # == Description
  #
  # Returns the full path for a WS URI, as required by Net::HTTP::Get.
  #
  # If the URI contains a query, the full path is URI#path + '?' + URI#query.
  # Otherwise, the path is simply URI#path.
  #
  # Example:
  #
  #     uri = URI::WS.build(path: '/foo/bar', query: 'test=true')
  #     uri.request_uri #  => "/foo/bar?test=true"
  #
  # source://uri//lib/uri/ws.rb#74
  def request_uri; end

  class << self
    # == Description
    #
    # Creates a new URI::WS object from components, with syntax checking.
    #
    # The components accepted are userinfo, host, port, path, and query.
    #
    # The components should be provided either as an Array, or as a Hash
    # with keys formed by preceding the component names with a colon.
    #
    # If an Array is used, the components must be passed in the
    # order <code>[userinfo, host, port, path, query]</code>.
    #
    # Example:
    #
    #     uri = URI::WS.build(host: 'www.example.com', path: '/foo/bar')
    #
    #     uri = URI::WS.build([nil, "www.example.com", nil, "/path", "query"])
    #
    # Currently, if passed userinfo components this method generates
    # invalid WS URIs as per RFC 1738.
    #
    # source://uri//lib/uri/ws.rb#56
    def build(args); end
  end
end

# The default port for WSS URIs is 443, and the scheme is 'wss:' rather
# than 'ws:'. Other than that, WSS URIs are identical to WS URIs;
# see URI::WS.
class URI::WSS < ::URI::WS; end

# A Default port of 443 for URI::WSS
#
# source://uri//lib/uri/wss.rb#19
URI::WSS::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
