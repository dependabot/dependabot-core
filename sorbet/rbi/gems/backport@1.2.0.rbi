# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `backport` gem.
# Please instead update this file by running `bin/tapioca gem backport`.

# An event-driven IO library.
#
# source://backport//lib/backport/version.rb#1
module Backport
  class << self
    # @return [Logger]
    #
    # source://backport//lib/backport.rb#75
    def logger; end

    # Prepare an interval server to run in Backport.
    #
    # @param period [Float] Seconds between intervals
    # @return [void]
    #
    # source://backport//lib/backport.rb#35
    def prepare_interval(period, &block); end

    # Prepare a STDIO server to run in Backport.
    #
    # @param adapter [Adapter]
    # @return [void]
    #
    # source://backport//lib/backport.rb#17
    def prepare_stdio_server(adapter: T.unsafe(nil)); end

    # Prepare a TCP server to run in Backport.
    #
    # @param host [String]
    # @param port [Integer]
    # @param adapter [Adapter]
    # @return [void]
    #
    # source://backport//lib/backport.rb#27
    def prepare_tcp_server(host: T.unsafe(nil), port: T.unsafe(nil), adapter: T.unsafe(nil)); end

    # Run the Backport machine. The provided block will be executed before the
    # machine starts. Program execution is blocked until the machine stops.
    #
    # @example Print "tick" once per second
    #   Backport.run do
    #   Backport.prepare_interval 1 do
    #   puts "tick"
    #   end
    #   end
    # @return [void]
    #
    # source://backport//lib/backport.rb#50
    def run(&block); end

    # Stop all running Backport machines.
    #
    # For more accurate control, consider stopping the machine
    # from the self reference in Machine#run, e.g.:
    #
    # ```
    # Backport.run do |machine|
    #   # ...
    #   machine.stop
    # end
    # ```
    #
    # @return [void]
    #
    # source://backport//lib/backport.rb#70
    def stop; end

    private

    # @return [Array<Machine>]
    #
    # source://backport//lib/backport.rb#82
    def machines; end
  end
end

# The application interface between Backport servers and clients.
#
# source://backport//lib/backport/adapter.rb#4
class Backport::Adapter
  # @param output [IO]
  # @param remote [Hash{Symbol => String, Integer}]
  # @return [Adapter] a new instance of Adapter
  #
  # source://backport//lib/backport/adapter.rb#7
  def initialize(output, remote = T.unsafe(nil)); end

  # Close the client connection.
  #
  # @note The adapter sets #closed? to true and runs the #closing callback.
  #   The server is responsible for implementation details like closing the
  #   client's socket.
  # @return [void]
  #
  # source://backport//lib/backport/adapter.rb#80
  def close; end

  # @return [Boolean]
  #
  # source://backport//lib/backport/adapter.rb#69
  def closed?; end

  # A callback triggered when a client connection is closing. Subclasses
  # and/or modules should override this method to provide their own
  # functionality.
  #
  # @return [void]
  #
  # source://backport//lib/backport/adapter.rb#41
  def closing; end

  # A callback triggered when a client connection is opening. Subclasses
  # and/or modules should override this method to provide their own
  # functionality.
  #
  # @return [void]
  #
  # source://backport//lib/backport/adapter.rb#34
  def opening; end

  # A callback triggered when the server receives data from the client.
  # Subclasses and/or modules should override this method to provide their
  # own functionality.
  #
  # @param data [String]
  # @return [void]
  #
  # source://backport//lib/backport/adapter.rb#49
  def receiving(data); end

  # A hash of information about the client connection. The data can vary
  # based on the transport, e.g., :hostname and :address for TCP connections
  # or :filename for file streams.
  #
  # @return [Hash{Symbol => String, Integer}]
  #
  # source://backport//lib/backport/adapter.rb#25
  def remote; end

  # Send data to the client.
  #
  # @param data [String]
  # @return [void]
  #
  # source://backport//lib/backport/adapter.rb#55
  def write(data); end

  # Send a line of data to the client.
  #
  # @param data [String]
  # @return [void]
  #
  # source://backport//lib/backport/adapter.rb#64
  def write_line(data); end
end

# A client connected to a connectable Backport server.
#
# source://backport//lib/backport/client.rb#6
class Backport::Client
  include ::Observable

  # @param input [IO]
  # @param output [IO]
  # @param adapter [Class, Module]
  # @param remote [Hash]
  # @return [Client] a new instance of Client
  #
  # source://backport//lib/backport/client.rb#16
  def initialize(input, output, adapter, remote = T.unsafe(nil)); end

  # @return [Adapter]
  #
  # source://backport//lib/backport/client.rb#10
  def adapter; end

  # Start running the client. This method will start the thread that reads
  # client input from IO.
  #
  # @deprecated Prefer #start to #run for non-blocking client/server methods
  # @return [void]
  #
  # source://backport//lib/backport/client.rb#50
  def run; end

  # Start running the client. This method will start the thread that reads
  # client input from IO.
  #
  # @return [void]
  #
  # source://backport//lib/backport/client.rb#50
  def start; end

  # Close the client connection.
  #
  # callback. The server is responsible for implementation details like
  # closing the client's socket.
  #
  # @note The client sets #stopped? to true and runs the adapter's #closing
  # @return [void]
  #
  # source://backport//lib/backport/client.rb#38
  def stop; end

  # True if the client is stopped.
  #
  # @return [Boolean]
  #
  # source://backport//lib/backport/client.rb#27
  def stopped?; end

  # Handle a tick from the server. This method will check for client input
  # and update the adapter accordingly, or stop the client if the adapter is
  # closed.
  #
  # @return [void]
  #
  # source://backport//lib/backport/client.rb#64
  def tick; end

  private

  # @param mod_cls [Module, Class] The Adapter module or class
  # @param remote [Hash] Remote client data
  # @return [Adapter]
  #
  # source://backport//lib/backport/client.rb#86
  def make_adapter(mod_cls, remote); end

  # @return [Mutex]
  #
  # source://backport//lib/backport/client.rb#98
  def mutex; end

  # Read the client input. Return nil if the input buffer is empty.
  #
  # @return [String, nil]
  #
  # source://backport//lib/backport/client.rb#74
  def read; end

  # Read input from the client.
  #
  # @return [void]
  #
  # source://backport//lib/backport/client.rb#112
  def read_input; end

  # Start the thread that checks the input IO for client data.
  #
  # @return [void]
  #
  # source://backport//lib/backport/client.rb#103
  def run_input_thread; end
end

# The Backport server controller.
#
# source://backport//lib/backport/machine.rb#4
class Backport::Machine
  # @return [Machine] a new instance of Machine
  #
  # source://backport//lib/backport/machine.rb#5
  def initialize; end

  # Add a server to the machine. The server will be started when the machine
  # starts. If the machine is already running, the server will be started
  # immediately.
  #
  # @param server [Server::Base]
  # @return [void]
  #
  # source://backport//lib/backport/machine.rb#45
  def prepare(server); end

  # Run the machine. If a block is provided, it gets executed before the
  # maching starts its main loop. The main loop blocks program execution
  # until the machine is stopped.
  #
  # @return [void]
  # @yieldparam [self]
  #
  # source://backport//lib/backport/machine.rb#16
  def run; end

  # @return [Array<Server::Base>]
  #
  # source://backport//lib/backport/machine.rb#52
  def servers; end

  # Stop the machine.
  #
  # @return [void]
  #
  # source://backport//lib/backport/machine.rb#27
  def stop; end

  # True if the machine is stopped.
  #
  # @return [Boolean]
  #
  # source://backport//lib/backport/machine.rb#35
  def stopped?; end

  # @param server [Server::Base]
  # @return [void]
  #
  # source://backport//lib/backport/machine.rb#58
  def update(server); end

  private

  # @return [Mutex]
  #
  # source://backport//lib/backport/machine.rb#70
  def mutex; end

  # Start the thread that updates servers via the #tick method.
  #
  # @return [void]
  #
  # source://backport//lib/backport/machine.rb#75
  def run_server_thread; end
end

# Classes and modules for Backport servers.
#
# source://backport//lib/backport/server.rb#4
module Backport::Server; end

# An extendable server class that provides basic start/stop functionality
# and common callbacks.
#
# source://backport//lib/backport/server/base.rb#8
class Backport::Server::Base
  include ::Observable

  # Start the server.
  #
  # @return [void]
  #
  # source://backport//lib/backport/server/base.rb#14
  def start; end

  # @return [Boolean]
  #
  # source://backport//lib/backport/server/base.rb#31
  def started?; end

  # A callback triggered when a Machine starts running or the server is
  # added to a running machine. Subclasses should override this method to
  # provide their own functionality.
  #
  # @return [void]
  #
  # source://backport//lib/backport/server/base.rb#44
  def starting; end

  # Stop the server.
  #
  # @return [void]
  #
  # source://backport//lib/backport/server/base.rb#23
  def stop; end

  # @return [Boolean]
  #
  # source://backport//lib/backport/server/base.rb#35
  def stopped?; end

  # A callback triggered when the server is stopping. Subclasses should
  # override this method to provide their own functionality.
  #
  # @return [void]
  #
  # source://backport//lib/backport/server/base.rb#50
  def stopping; end

  # A callback triggered from the main loop of a running Machine.
  # Subclasses should override this method to provide their own
  # functionality.
  #
  # @return [void]
  #
  # source://backport//lib/backport/server/base.rb#57
  def tick; end
end

# A mixin for Backport servers that communicate with clients.
#
# Connectable servers check clients for incoming data on each tick.
#
# source://backport//lib/backport/server/connectable.rb#7
module Backport::Server::Connectable
  # @return [Array<Client>]
  #
  # source://backport//lib/backport/server/connectable.rb#19
  def clients; end

  # @return [void]
  #
  # source://backport//lib/backport/server/connectable.rb#9
  def starting; end

  # @return [void]
  #
  # source://backport//lib/backport/server/connectable.rb#14
  def stopping; end

  private

  # @return [Mutex]
  #
  # source://backport//lib/backport/server/connectable.rb#26
  def mutex; end
end

# A Backport periodical interval server.
#
# source://backport//lib/backport/server/interval.rb#8
class Backport::Server::Interval < ::Backport::Server::Base
  # @param period [Float] The interval time in seconds.
  # @param block [Proc] The proc to run on each interval.
  # @return [Interval] a new instance of Interval
  # @yieldparam [Interval]
  #
  # source://backport//lib/backport/server/interval.rb#9
  def initialize(period, &block); end

  # source://backport//lib/backport/server/interval.rb#16
  def starting; end

  # source://backport//lib/backport/server/interval.rb#21
  def tick; end

  private

  # @return [void]
  #
  # source://backport//lib/backport/server/interval.rb#32
  def run_ready_thread; end
end

# A Backport STDIO server.
#
# source://backport//lib/backport/server/stdio.rb#5
class Backport::Server::Stdio < ::Backport::Server::Base
  include ::Backport::Server::Connectable

  # @param input [IO]
  # @param output [IO]
  # @param adapter [Module, Class]
  # @return [Stdio] a new instance of Stdio
  #
  # source://backport//lib/backport/server/stdio.rb#11
  def initialize(input: T.unsafe(nil), output: T.unsafe(nil), adapter: T.unsafe(nil)); end

  # @param client [Client]
  # @return [void]
  #
  # source://backport//lib/backport/server/stdio.rb#22
  def update(client); end
end

# A Backport TCP server. It runs a thread to accept incoming connections
# and automatically stops when the socket is closed.
#
# source://backport//lib/backport/server/tcpip.rb#8
class Backport::Server::Tcpip < ::Backport::Server::Base
  include ::Backport::Server::Connectable

  # @param host [String]
  # @param port [Integer]
  # @param adapter [Module, Class]
  # @param socket_class [Class]
  # @return [Tcpip] a new instance of Tcpip
  #
  # source://backport//lib/backport/server/tcpip.rb#15
  def initialize(host: T.unsafe(nil), port: T.unsafe(nil), adapter: T.unsafe(nil), socket_class: T.unsafe(nil)); end

  # Accept an incoming connection using accept_nonblock. Return the
  # resulting Client if a connection was accepted or nil if no connections
  # are pending.
  #
  # @return [Client, nil]
  #
  # source://backport//lib/backport/server/tcpip.rb#41
  def accept; end

  # source://backport//lib/backport/server/tcpip.rb#21
  def starting; end

  # source://backport//lib/backport/server/tcpip.rb#25
  def stopping; end

  # @param client [Client]
  # @return [void]
  #
  # source://backport//lib/backport/server/tcpip.rb#78
  def update(client); end

  private

  # @return [TCPSocket]
  #
  # source://backport//lib/backport/server/tcpip.rb#89
  def socket; end

  # @return [void]
  #
  # source://backport//lib/backport/server/tcpip.rb#92
  def start_accept_thread; end
end

# source://backport//lib/backport/version.rb#2
Backport::VERSION = T.let(T.unsafe(nil), String)
