# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `http` gem.
# Please instead update this file by running `bin/tapioca gem http`.


# HTTP should be easy
#
# source://http//lib/http/errors.rb#3
module HTTP
  extend ::HTTP::Base64
  extend ::HTTP::Chainable

  class << self
    # HTTP[:accept => 'text/html'].get(...)
    #
    # source://http//lib/http.rb#25
    def [](headers); end
  end
end

# source://http//lib/http/base64.rb#4
module HTTP::Base64
  private

  # Equivalent to Base64.strict_encode64
  #
  # source://http//lib/http/base64.rb#8
  def encode64(input); end

  class << self
    # Equivalent to Base64.strict_encode64
    #
    # source://http//lib/http/base64.rb#8
    def encode64(input); end
  end
end

# source://http//lib/http/chainable.rb#7
module HTTP::Chainable
  include ::HTTP::Base64

  # Accept the given MIME type(s)
  #
  # @param type
  #
  # source://http//lib/http/chainable.rb#199
  def accept(type); end

  # Make a request with the given Authorization header
  #
  # @param value [#to_s] Authorization header value
  #
  # source://http//lib/http/chainable.rb#205
  def auth(value); end

  # Make a request with the given Basic authorization header
  #
  # @option opts
  # @option opts
  # @param opts [#fetch]
  # @see http://tools.ietf.org/html/rfc2617
  #
  # source://http//lib/http/chainable.rb#214
  def basic_auth(opts); end

  # Prepare an HTTP request with the given verb
  #
  # source://http//lib/http/chainable.rb#81
  def build_request(*args); end

  # Convert to a transparent TCP/IP tunnel
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  #
  # source://http//lib/http/chainable.rb#62
  def connect(uri, options = T.unsafe(nil)); end

  # Make a request with the given cookies
  #
  # source://http//lib/http/chainable.rb#188
  def cookies(cookies); end

  # Get options for HTTP
  #
  # @return [HTTP::Options]
  #
  # source://http//lib/http/chainable.rb#224
  def default_options; end

  # Set options for HTTP
  #
  # @param opts
  # @return [HTTP::Options]
  #
  # source://http//lib/http/chainable.rb#231
  def default_options=(opts); end

  # Delete a resource
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  #
  # source://http//lib/http/chainable.rb#41
  def delete(uri, options = T.unsafe(nil)); end

  # Force a specific encoding for response body
  #
  # source://http//lib/http/chainable.rb#193
  def encoding(encoding); end

  # Make client follow redirects.
  #
  # @param options
  # @return [HTTP::Client]
  # @see Redirector#initialize
  #
  # source://http//lib/http/chainable.rb#177
  def follow(options = T.unsafe(nil)); end

  # Get a resource
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  #
  # source://http//lib/http/chainable.rb#20
  def get(uri, options = T.unsafe(nil)); end

  # Request a get sans response body
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  #
  # source://http//lib/http/chainable.rb#13
  def head(uri, options = T.unsafe(nil)); end

  # Make a request with the given headers
  #
  # @param headers
  #
  # source://http//lib/http/chainable.rb#183
  def headers(headers); end

  # Set TCP_NODELAY on the socket
  #
  # source://http//lib/http/chainable.rb#236
  def nodelay; end

  # Return the methods supported on the given URI
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  #
  # source://http//lib/http/chainable.rb#55
  def options(uri, options = T.unsafe(nil)); end

  # Apply partial modifications to a resource
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  #
  # source://http//lib/http/chainable.rb#69
  def patch(uri, options = T.unsafe(nil)); end

  # @overload persistent
  # @overload persistent
  #
  # source://http//lib/http/chainable.rb#145
  def persistent(host, timeout: T.unsafe(nil)); end

  # Post to a resource
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  #
  # source://http//lib/http/chainable.rb#27
  def post(uri, options = T.unsafe(nil)); end

  # Put to a resource
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  #
  # source://http//lib/http/chainable.rb#34
  def put(uri, options = T.unsafe(nil)); end

  # Make an HTTP request with the given verb
  #
  # source://http//lib/http/chainable.rb#75
  def request(*args); end

  # Returns retriable client instance, which retries requests if they failed
  # due to some socket errors or response status is `5xx`.
  #
  # @example Usage
  #
  #   # Retry max 5 times with randomly growing delay between retries
  #   HTTP.retriable.get(url)
  #
  #   # Retry max 3 times with randomly growing delay between retries
  #   HTTP.retriable(times: 3).get(url)
  #
  #   # Retry max 3 times with 1 sec delay between retries
  #   HTTP.retriable(times: 3, delay: proc { 1 }).get(url)
  #
  #   # Retry max 3 times with geometrically progressed delay between retries
  #   HTTP.retriable(times: 3, delay: proc { |i| 1 + i*i }).get(url)
  #
  # source://http//lib/http/chainable.rb#270
  def retriable(**options); end

  # Make a request through an HTTP proxy
  #
  # @param proxy [Array]
  # @raise [Request::Error] if HTTP proxy is invalid
  #
  # source://http//lib/http/chainable.rb#171
  def through(*proxy); end

  # @overload timeout
  # @overload timeout
  #
  # source://http//lib/http/chainable.rb#94
  def timeout(options); end

  # Echo the request back to the client
  #
  # @option options
  # @param uri
  # @param options [Hash] a customizable set of options
  #
  # source://http//lib/http/chainable.rb#48
  def trace(uri, options = T.unsafe(nil)); end

  # Turn on given features. Available features are:
  # * auto_inflate
  # * auto_deflate
  # * instrumentation
  # * logging
  # * normalize_uri
  # * raise_error
  #
  # @param features
  #
  # source://http//lib/http/chainable.rb#248
  def use(*features); end

  # Make a request through an HTTP proxy
  #
  # @param proxy [Array]
  # @raise [Request::Error] if HTTP proxy is invalid
  #
  # source://http//lib/http/chainable.rb#158
  def via(*proxy); end

  private

  # source://http//lib/http/chainable.rb#277
  def branch(options); end
end

# Clients make requests and receive responses
#
# source://http//lib/http/client.rb#15
class HTTP::Client
  include ::HTTP::Base64
  include ::HTTP::Chainable
  extend ::Forwardable

  # @return [Client] a new instance of Client
  #
  # source://http//lib/http/client.rb#21
  def initialize(default_options = T.unsafe(nil)); end

  # Prepare an HTTP request
  #
  # source://http//lib/http/client.rb#40
  def build_request(verb, uri, opts = T.unsafe(nil)); end

  # source://http//lib/http/client.rb#97
  def close; end

  # Perform a single (no follow) HTTP request
  #
  # source://http//lib/http/client.rb#64
  def perform(request, options); end

  # @return [Boolean] whenever client is persistent
  # @see Options#persistent?
  #
  # source://http//lib/http/client.rb#61
  def persistent?(*args, **_arg1, &block); end

  # Make an HTTP request
  #
  # source://http//lib/http/client.rb#28
  def request(verb, uri, opts = T.unsafe(nil)); end

  private

  # source://http//lib/http/client.rb#111
  def build_response(req, options); end

  # source://http//lib/http/client.rb#192
  def make_form_data(form); end

  # Create the request body object to send
  #
  # source://http//lib/http/client.rb#177
  def make_request_body(opts, headers); end

  # Creates request headers with cookies (if any) merged in
  #
  # source://http//lib/http/client.rb#160
  def make_request_headers(opts); end

  # Merges query params if needed
  #
  # @param uri [#to_s]
  # @return [URI]
  #
  # source://http//lib/http/client.rb#142
  def make_request_uri(uri, opts); end

  # Verify our request isn't going to be made against another URI
  #
  # source://http//lib/http/client.rb#124
  def verify_connection!(uri); end

  # source://http//lib/http/client.rb#105
  def wrap_request(req, opts); end
end

# source://http//lib/http/client.rb#19
HTTP::Client::HTTP_OR_HTTPS_RE = T.let(T.unsafe(nil), Regexp)

# Timeout when first establishing the conncetion
#
# source://http//lib/http/errors.rb#39
class HTTP::ConnectTimeoutError < ::HTTP::TimeoutError; end

# A connection to the HTTP server
#
# source://http//lib/http/connection.rb#9
class HTTP::Connection
  extend ::Forwardable

  # @param req [HTTP::Request]
  # @param options [HTTP::Options]
  # @raise [HTTP::ConnectionError] when failed to connect
  # @return [Connection] a new instance of Connection
  #
  # source://http//lib/http/connection.rb#31
  def initialize(req, options); end

  # Close the connection
  #
  # @return [void]
  #
  # source://http//lib/http/connection.rb#132
  def close; end

  # Whether our connection has expired
  #
  # @return [Boolean]
  #
  # source://http//lib/http/connection.rb#151
  def expired?; end

  # @return [Boolean] whenever proxy connect failed
  #
  # source://http//lib/http/connection.rb#64
  def failed_proxy_connect?; end

  # Callback for when we've reached the end of a response
  #
  # @return [void]
  #
  # source://http//lib/http/connection.rb#120
  def finish_response; end

  # @return [Boolean]
  #
  # source://http//lib/http/connection.rb#139
  def finished_request?; end

  # source://http//lib/http/connection.rb#61
  def headers(*args, **_arg1, &block); end

  # source://http//lib/http/connection.rb#58
  def http_version(*args, **_arg1, &block); end

  # Whether we're keeping the conn alive
  #
  # @return [Boolean]
  #
  # source://http//lib/http/connection.rb#145
  def keep_alive?; end

  # Returned after HTTP CONNECT (via proxy)
  #
  # source://http//lib/http/connection.rb#26
  def proxy_response_headers; end

  # Reads data from socket up until headers are loaded
  #
  # @raise [ResponseHeaderError] when unable to read response headers
  # @return [void]
  #
  # source://http//lib/http/connection.rb#109
  def read_headers!; end

  # Read a chunk of the body
  #
  # @return [String] data chunk
  # @return [nil] when no more data left
  #
  # source://http//lib/http/connection.rb#93
  def readpartial(size = T.unsafe(nil)); end

  # Send a request to the server
  #
  # @param req [Request] Request to send to the server
  # @return [nil]
  #
  # source://http//lib/http/connection.rb#72
  def send_request(req); end

  # source://http//lib/http/connection.rb#55
  def status_code(*args, **_arg1, &block); end

  private

  # Feeds some more data into parser
  #
  # @raise [SocketReadError] when unable to read from socket
  # @return [void]
  #
  # source://http//lib/http/connection.rb#222
  def read_more(size); end

  # Resets expiration of persistent connection.
  #
  # @return [void]
  #
  # source://http//lib/http/connection.rb#198
  def reset_timer; end

  # Open tunnel through proxy
  #
  # source://http//lib/http/connection.rb#174
  def send_proxy_connect_request(req); end

  # Store whether the connection should be kept alive.
  # Once we reset the parser, we lose all of this state.
  #
  # @return [void]
  #
  # source://http//lib/http/connection.rb#205
  def set_keep_alive; end

  # Sets up SSL context and starts TLS if needed.
  #
  # @param req [HTTP::Request]
  # @param options [HTTP::Options]
  # @return [void]
  #
  # source://http//lib/http/connection.rb#160
  def start_tls(req, options); end
end

# Attempt to read this much data
#
# source://http//lib/http/connection.rb#17
HTTP::Connection::BUFFER_SIZE = T.let(T.unsafe(nil), Integer)

# source://http//lib/http/connection.rb#14
HTTP::Connection::CLOSE = T.let(T.unsafe(nil), String)

# HTTP/1.0
#
# source://http//lib/http/connection.rb#20
HTTP::Connection::HTTP_1_0 = T.let(T.unsafe(nil), String)

# HTTP/1.1
#
# source://http//lib/http/connection.rb#23
HTTP::Connection::HTTP_1_1 = T.let(T.unsafe(nil), String)

# Allowed values for CONNECTION header
#
# source://http//lib/http/connection.rb#13
HTTP::Connection::KEEP_ALIVE = T.let(T.unsafe(nil), String)

# Generic Connection error
#
# source://http//lib/http/errors.rb#8
class HTTP::ConnectionError < ::HTTP::Error; end

# source://http//lib/http/content_type.rb#4
class HTTP::ContentType
  # @return [ContentType] a new instance of ContentType
  #
  # source://http//lib/http/content_type.rb#29
  def initialize(mime_type = T.unsafe(nil), charset = T.unsafe(nil)); end

  # Returns the value of attribute charset.
  #
  # source://http//lib/http/content_type.rb#8
  def charset; end

  # Sets the attribute charset
  #
  # @param value the value to set the attribute charset to.
  #
  # source://http//lib/http/content_type.rb#8
  def charset=(_arg0); end

  # Returns the value of attribute mime_type.
  #
  # source://http//lib/http/content_type.rb#8
  def mime_type; end

  # Sets the attribute mime_type
  #
  # @param value the value to set the attribute mime_type to.
  #
  # source://http//lib/http/content_type.rb#8
  def mime_type=(_arg0); end

  class << self
    # Parse string and return ContentType struct
    #
    # source://http//lib/http/content_type.rb#12
    def parse(str); end

    private

    # source://http//lib/http/content_type.rb#24
    def charset(str); end

    # source://http//lib/http/content_type.rb#19
    def mime_type(str); end
  end
end

# source://http//lib/http/content_type.rb#6
HTTP::ContentType::CHARSET_RE = T.let(T.unsafe(nil), Regexp)

# source://http//lib/http/content_type.rb#5
HTTP::ContentType::MIME_TYPE_RE = T.let(T.unsafe(nil), Regexp)

# Generic error
#
# source://http//lib/http/errors.rb#5
class HTTP::Error < ::StandardError; end

# source://http//lib/http/feature.rb#4
class HTTP::Feature
  # @return [Feature] a new instance of Feature
  #
  # source://http//lib/http/feature.rb#5
  def initialize(opts = T.unsafe(nil)); end

  # source://http//lib/http/feature.rb#17
  def on_error(request, error); end

  # source://http//lib/http/feature.rb#9
  def wrap_request(request); end

  # source://http//lib/http/feature.rb#13
  def wrap_response(response); end
end

# source://http//lib/http/features/auto_inflate.rb#6
module HTTP::Features; end

# source://http//lib/http/features/auto_deflate.rb#10
class HTTP::Features::AutoDeflate < ::HTTP::Feature
  # @raise [Error]
  # @return [AutoDeflate] a new instance of AutoDeflate
  #
  # source://http//lib/http/features/auto_deflate.rb#13
  def initialize(**_arg0); end

  # source://http//lib/http/features/auto_deflate.rb#40
  def deflated_body(body); end

  # Returns the value of attribute method.
  #
  # source://http//lib/http/features/auto_deflate.rb#11
  def method; end

  # source://http//lib/http/features/auto_deflate.rb#21
  def wrap_request(request); end
end

# source://http//lib/http/features/auto_deflate.rb#51
class HTTP::Features::AutoDeflate::CompressedBody < ::HTTP::Request::Body
  # @return [CompressedBody] a new instance of CompressedBody
  #
  # source://http//lib/http/features/auto_deflate.rb#52
  def initialize(uncompressed_body); end

  # source://http//lib/http/features/auto_deflate.rb#62
  def each(&block); end

  # source://http//lib/http/features/auto_deflate.rb#57
  def size; end

  private

  # source://http//lib/http/features/auto_deflate.rb#84
  def compress_all!; end

  # source://http//lib/http/features/auto_deflate.rb#76
  def compressed_each; end
end

# source://http//lib/http/features/auto_deflate.rb#110
class HTTP::Features::AutoDeflate::DeflatedBody < ::HTTP::Features::AutoDeflate::CompressedBody
  # source://http//lib/http/features/auto_deflate.rb#111
  def compress; end
end

# source://http//lib/http/features/auto_deflate.rb#91
class HTTP::Features::AutoDeflate::GzippedBody < ::HTTP::Features::AutoDeflate::CompressedBody
  # source://http//lib/http/features/auto_deflate.rb#92
  def compress(&block); end
end

# source://http//lib/http/features/auto_deflate.rb#99
class HTTP::Features::AutoDeflate::GzippedBody::BlockIO
  # @return [BlockIO] a new instance of BlockIO
  #
  # source://http//lib/http/features/auto_deflate.rb#100
  def initialize(block); end

  # source://http//lib/http/features/auto_deflate.rb#104
  def write(data); end
end

# source://http//lib/http/features/auto_inflate.rb#7
class HTTP::Features::AutoInflate < ::HTTP::Feature
  # source://http//lib/http/features/auto_inflate.rb#27
  def stream_for(connection); end

  # source://http//lib/http/features/auto_inflate.rb#11
  def wrap_response(response); end

  private

  # @return [Boolean]
  #
  # source://http//lib/http/features/auto_inflate.rb#33
  def supported_encoding?(response); end
end

# source://http//lib/http/features/auto_inflate.rb#8
HTTP::Features::AutoInflate::SUPPORTED_ENCODING = T.let(T.unsafe(nil), Set)

# Instrument requests and responses. Expects an
# ActiveSupport::Notifications-compatible instrumenter. Defaults to use a
# namespace of 'http' which may be overridden with a `:namespace` param.
# Emits a single event like `"request.{namespace}"`, eg `"request.http"`.
# Be sure to specify the instrumenter when enabling the feature:
#
#    HTTP
#      .use(instrumentation: {instrumenter: ActiveSupport::Notifications.instrumenter})
#      .get("https://example.com/")
#
# Emits two events on every request:
#
#  * `start_request.http` before the request is made, so you can log the reqest being started
#  * `request.http` after the response is recieved, and contains `start`
#    and `finish` so the duration of the request can be calculated.
#
# source://http//lib/http/features/instrumentation.rb#21
class HTTP::Features::Instrumentation < ::HTTP::Feature
  # @return [Instrumentation] a new instance of Instrumentation
  #
  # source://http//lib/http/features/instrumentation.rb#24
  def initialize(instrumenter: T.unsafe(nil), namespace: T.unsafe(nil)); end

  # Returns the value of attribute error_name.
  #
  # source://http//lib/http/features/instrumentation.rb#22
  def error_name; end

  # Returns the value of attribute instrumenter.
  #
  # source://http//lib/http/features/instrumentation.rb#22
  def instrumenter; end

  # Returns the value of attribute name.
  #
  # source://http//lib/http/features/instrumentation.rb#22
  def name; end

  # source://http//lib/http/features/instrumentation.rb#43
  def on_error(request, error); end

  # source://http//lib/http/features/instrumentation.rb#30
  def wrap_request(request); end

  # source://http//lib/http/features/instrumentation.rb#38
  def wrap_response(response); end
end

# source://http//lib/http/features/instrumentation.rb#49
class HTTP::Features::Instrumentation::NullInstrumenter
  # source://http//lib/http/features/instrumentation.rb#63
  def finish(_name, _payload); end

  # source://http//lib/http/features/instrumentation.rb#50
  def instrument(name, payload = T.unsafe(nil)); end

  # source://http//lib/http/features/instrumentation.rb#59
  def start(_name, _payload); end
end

# Log requests and responses. Request verb and uri, and Response status are
# logged at `info`, and the headers and bodies of both are logged at
# `debug`. Be sure to specify the logger when enabling the feature:
#
#    HTTP.use(logging: {logger: Logger.new(STDOUT)}).get("https://example.com/")
#
# source://http//lib/http/features/logging.rb#11
class HTTP::Features::Logging < ::HTTP::Feature
  # @return [Logging] a new instance of Logging
  #
  # source://http//lib/http/features/logging.rb#28
  def initialize(logger: T.unsafe(nil)); end

  # Returns the value of attribute logger.
  #
  # source://http//lib/http/features/logging.rb#26
  def logger; end

  # source://http//lib/http/features/logging.rb#32
  def wrap_request(request); end

  # source://http//lib/http/features/logging.rb#39
  def wrap_response(response); end

  private

  # source://http//lib/http/features/logging.rb#48
  def stringify_headers(headers); end
end

# source://http//lib/http/features/logging.rb#14
class HTTP::Features::Logging::NullLogger
  # source://http//lib/http/features/logging.rb#16
  def debug(*_args); end

  # source://http//lib/http/features/logging.rb#20
  def debug?; end

  # source://http//lib/http/features/logging.rb#16
  def error(*_args); end

  # source://http//lib/http/features/logging.rb#20
  def error?; end

  # source://http//lib/http/features/logging.rb#16
  def fatal(*_args); end

  # source://http//lib/http/features/logging.rb#20
  def fatal?; end

  # source://http//lib/http/features/logging.rb#16
  def info(*_args); end

  # source://http//lib/http/features/logging.rb#20
  def info?; end

  # source://http//lib/http/features/logging.rb#16
  def warn(*_args); end

  # source://http//lib/http/features/logging.rb#20
  def warn?; end
end

# source://http//lib/http/features/normalize_uri.rb#7
class HTTP::Features::NormalizeUri < ::HTTP::Feature
  # @return [NormalizeUri] a new instance of NormalizeUri
  #
  # source://http//lib/http/features/normalize_uri.rb#10
  def initialize(normalizer: T.unsafe(nil)); end

  # Returns the value of attribute normalizer.
  #
  # source://http//lib/http/features/normalize_uri.rb#8
  def normalizer; end
end

# source://http//lib/http/features/raise_error.rb#5
class HTTP::Features::RaiseError < ::HTTP::Feature
  # @return [RaiseError] a new instance of RaiseError
  #
  # source://http//lib/http/features/raise_error.rb#6
  def initialize(ignore: T.unsafe(nil)); end

  # @raise [HTTP::StatusError]
  #
  # source://http//lib/http/features/raise_error.rb#12
  def wrap_response(response); end
end

# Header value is of unexpected format (similar to Net::HTTPHeaderSyntaxError)
#
# source://http//lib/http/errors.rb#42
class HTTP::HeaderError < ::HTTP::Error; end

# HTTP Headers container.
#
# source://http//lib/http/headers/mixin.rb#6
class HTTP::Headers
  include ::Enumerable
  extend ::Forwardable

  # Class constructor.
  #
  # @return [Headers] a new instance of Headers
  #
  # source://http//lib/http/headers.rb#43
  def initialize; end

  # Compares headers to another Headers or Array of key/value pairs
  #
  # @return [Boolean]
  #
  # source://http//lib/http/headers.rb#162
  def ==(other); end

  # Smart version of {#get}.
  #
  # @return [nil] if header was not set
  # @return [String] if header has exactly one value
  # @return [Array<String>] if header has more than one value
  #
  # source://http//lib/http/headers.rb#112
  def [](name); end

  # Sets header.
  #
  # @return [void]
  #
  # source://http//lib/http/headers.rb#59
  def []=(name, value); end

  # Appends header.
  #
  # @param name [String, Symbol] header name. When specified as a string, the
  #   name is sent as-is. When specified as a symbol, the name is converted
  #   to a string of capitalized words separated by a dash. Word boundaries
  #   are determined by an underscore (`_`) or a dash (`-`).
  #   Ex: `:content_type` is sent as `"Content-Type"`, and `"auth_key"` (string)
  #   is sent as `"auth_key"`.
  # @param value [Array<#to_s>, #to_s] header value(s) to be appended
  # @return [void]
  #
  # source://http//lib/http/headers.rb#80
  def add(name, value); end

  # Removes header.
  #
  # @param name [#to_s] header name
  # @return [void]
  #
  # source://http//lib/http/headers.rb#65
  def delete(name); end

  # Calls the given block once for each key/value pair in headers container.
  #
  # @return [Enumerator] if no block given
  # @return [Headers] self-reference
  #
  # source://http//lib/http/headers.rb#172
  def each; end

  # Returns `true` if `self` has no key/value pairs
  #
  # @return [Boolean]
  #
  # source://http//lib/http/headers.rb#183
  def empty?(*args, **_arg1, &block); end

  # Returns list of header values if any.
  #
  # @return [Array<String>]
  #
  # source://http//lib/http/headers.rb#102
  def get(name); end

  # Compute a hash-code for this headers container.
  # Two containers with the same content will have the same hash code.
  #
  # @return [Fixnum]
  # @see http://www.ruby-doc.org/core/Object.html#method-i-hash
  #
  # source://http//lib/http/headers.rb#191
  def hash(*args, **_arg1, &block); end

  # Tells whenever header with given `name` is set or not.
  #
  # @return [Boolean]
  #
  # source://http//lib/http/headers.rb#125
  def include?(name); end

  # Returns human-readable representation of `self` instance.
  #
  # @return [String]
  #
  # source://http//lib/http/headers.rb#148
  def inspect; end

  # Returns list of header names.
  #
  # @return [Array<String>]
  #
  # source://http//lib/http/headers.rb#155
  def keys; end

  # Returns new instance with `other` headers merged in.
  #
  # @return [Headers]
  # @see #merge!
  #
  # source://http//lib/http/headers.rb#213
  def merge(other); end

  # Merges `other` headers into `self`.
  #
  # @return [void]
  # @see #merge
  #
  # source://http//lib/http/headers.rb#205
  def merge!(other); end

  # Sets header.
  #
  # @param name [String, Symbol] header name. When specified as a string, the
  #   name is sent as-is. When specified as a symbol, the name is converted
  #   to a string of capitalized words separated by a dash. Word boundaries
  #   are determined by an underscore (`_`) or a dash (`-`).
  #   Ex: `:content_type` is sent as `"Content-Type"`, and `"auth_key"` (string)
  #   is sent as `"auth_key"`.
  # @param value [Array<#to_s>, #to_s] header value(s) to be appended
  # @return [void]
  #
  # source://http//lib/http/headers.rb#55
  def set(name, value); end

  # Returns headers key/value pairs.
  #
  # @return [Array<[String, String]>]
  #
  # source://http//lib/http/headers.rb#141
  def to_a; end

  # Returns Rack-compatible headers Hash
  #
  # @return [Hash]
  #
  # source://http//lib/http/headers.rb#133
  def to_h; end

  # Returns Rack-compatible headers Hash
  #
  # @return [Hash]
  #
  # source://http//lib/http/headers.rb#136
  def to_hash; end

  private

  # Properly clones internal key/value storage.
  #
  # @api private
  #
  # source://http//lib/http/headers.rb#196
  def initialize_copy(orig); end

  # Transforms `name` to canonical HTTP header capitalization
  #
  # source://http//lib/http/headers.rb#220
  def normalize_header(name); end

  # Ensures there is no new line character in the header value
  #
  # @param value [String]
  # @raise [HeaderError] if value includes new line character
  # @return [String] stringified header value
  #
  # source://http//lib/http/headers.rb#229
  def validate_value(value); end

  class << self
    # Coerces given `object` into Headers.
    #
    # @param object [#to_hash, #to_h, #to_a]
    # @raise [Error] if object can't be coerced
    # @return [Headers]
    #
    # source://http//lib/http/headers.rb#35
    def [](object); end

    # Coerces given `object` into Headers.
    #
    # @param object [#to_hash, #to_h, #to_a]
    # @raise [Error] if object can't be coerced
    # @return [Headers]
    #
    # source://http//lib/http/headers.rb#22
    def coerce(object); end

    # source://http//lib/http/headers.rb#37
    def normalizer; end
  end
end

# Content-Types that are acceptable for the response.
#
# source://http//lib/http/headers/known.rb#6
HTTP::Headers::ACCEPT = T.let(T.unsafe(nil), String)

# Content-codings that are acceptable in the response.
#
# source://http//lib/http/headers/known.rb#9
HTTP::Headers::ACCEPT_ENCODING = T.let(T.unsafe(nil), String)

# The age the object has been in a proxy cache in seconds.
#
# source://http//lib/http/headers/known.rb#12
HTTP::Headers::AGE = T.let(T.unsafe(nil), String)

# Authentication credentials for HTTP authentication.
#
# source://http//lib/http/headers/known.rb#15
HTTP::Headers::AUTHORIZATION = T.let(T.unsafe(nil), String)

# Used to specify directives that must be obeyed by all caching mechanisms
# along the request-response chain.
#
# source://http//lib/http/headers/known.rb#19
HTTP::Headers::CACHE_CONTROL = T.let(T.unsafe(nil), String)

# Control options for the current connection and list
# of hop-by-hop request fields.
#
# source://http//lib/http/headers/known.rb#26
HTTP::Headers::CONNECTION = T.let(T.unsafe(nil), String)

# Indicates what additional content codings have been applied to the
# entity-body.
#
# source://http//lib/http/headers/known.rb#77
HTTP::Headers::CONTENT_ENCODING = T.let(T.unsafe(nil), String)

# The length of the request body in octets (8-bit bytes).
#
# source://http//lib/http/headers/known.rb#29
HTTP::Headers::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# The MIME type of the body of the request
# (used with POST and PUT requests).
#
# source://http//lib/http/headers/known.rb#33
HTTP::Headers::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# An HTTP cookie previously sent by the server with Set-Cookie.
#
# source://http//lib/http/headers/known.rb#22
HTTP::Headers::COOKIE = T.let(T.unsafe(nil), String)

# The date and time that the message was sent (in "HTTP-date" format as
# defined by RFC 7231 Date/Time Formats).
#
# source://http//lib/http/headers/known.rb#37
HTTP::Headers::DATE = T.let(T.unsafe(nil), String)

# An identifier for a specific version of a resource,
# often a message digest.
#
# source://http//lib/http/headers/known.rb#41
HTTP::Headers::ETAG = T.let(T.unsafe(nil), String)

# Gives the date/time after which the response is considered stale (in
# "HTTP-date" format as defined by RFC 7231).
#
# source://http//lib/http/headers/known.rb#45
HTTP::Headers::EXPIRES = T.let(T.unsafe(nil), String)

# The domain name of the server (for virtual hosting), and the TCP port
# number on which the server is listening. The port number may be omitted
# if the port is the standard port for the service requested.
#
# source://http//lib/http/headers/known.rb#50
HTTP::Headers::HOST = T.let(T.unsafe(nil), String)

# Allows a 304 Not Modified to be returned if content is unchanged.
#
# source://http//lib/http/headers/known.rb#53
HTTP::Headers::IF_MODIFIED_SINCE = T.let(T.unsafe(nil), String)

# Allows a 304 Not Modified to be returned if content is unchanged.
#
# source://http//lib/http/headers/known.rb#56
HTTP::Headers::IF_NONE_MATCH = T.let(T.unsafe(nil), String)

# The last modified date for the requested object (in "HTTP-date" format as
# defined by RFC 7231).
#
# source://http//lib/http/headers/known.rb#60
HTTP::Headers::LAST_MODIFIED = T.let(T.unsafe(nil), String)

# Used in redirection, or when a new resource has been created.
#
# source://http//lib/http/headers/known.rb#63
HTTP::Headers::LOCATION = T.let(T.unsafe(nil), String)

# Provides shared behavior for {HTTP::Request} and {HTTP::Response}.
# Expects `@headers` to be an instance of {HTTP::Headers}.
#
# @example Usage
#
#   class MyHttpRequest
#   include HTTP::Headers::Mixin
#
#   def initialize
#   @headers = HTTP::Headers.new
#   end
#   end
#
# source://http//lib/http/headers/mixin.rb#19
module HTTP::Headers::Mixin
  extend ::Forwardable

  # Smart version of {#get}.
  #
  # @return [nil] if header was not set
  # @return [String] if header has exactly one value
  # @return [Array<String>] if header has more than one value
  #
  # source://http//lib/http/headers/mixin.rb#27
  def [](*args, **_arg1, &block); end

  # Sets header.
  #
  # @return [void]
  #
  # source://http//lib/http/headers/mixin.rb#31
  def []=(*args, **_arg1, &block); end

  # @return [HTTP::Headers]
  #
  # source://http//lib/http/headers/mixin.rb#23
  def headers; end
end

# source://http//lib/http/headers/normalizer.rb#5
class HTTP::Headers::Normalizer
  # @return [Normalizer] a new instance of Normalizer
  #
  # source://http//lib/http/headers/normalizer.rb#38
  def initialize; end

  # Transforms `name` to canonical HTTP header capitalization
  #
  # source://http//lib/http/headers/normalizer.rb#43
  def call(name); end

  private

  # Transforms `name` to canonical HTTP header capitalization
  #
  # @param name [String]
  # @raise [HeaderError] if normalized name does not
  #   match {COMPLIANT_NAME_RE}
  # @return [String] canonical HTTP header name
  #
  # source://http//lib/http/headers/normalizer.rb#58
  def normalize_header(name); end
end

# Matches HTTP header names when in "Canonical-Http-Format"
#
# source://http//lib/http/headers/normalizer.rb#7
HTTP::Headers::Normalizer::CANONICAL_NAME_RE = T.let(T.unsafe(nil), Regexp)

# Matches valid header field name according to RFC.
#
# @see http://tools.ietf.org/html/rfc7230#section-3.2
#
# source://http//lib/http/headers/normalizer.rb#11
HTTP::Headers::Normalizer::COMPLIANT_NAME_RE = T.let(T.unsafe(nil), Regexp)

# Normalized header names cache
#
# @private
#
# source://http//lib/http/headers/normalizer.rb#17
class HTTP::Headers::Normalizer::Cache
  # @return [Cache] a new instance of Cache
  #
  # source://http//lib/http/headers/normalizer.rb#20
  def initialize; end

  # source://http//lib/http/headers/normalizer.rb#27
  def [](key); end

  # source://http//lib/http/headers/normalizer.rb#35
  def []=(key, value); end

  # source://http//lib/http/headers/normalizer.rb#24
  def get(key); end

  # source://http//lib/http/headers/normalizer.rb#29
  def set(key, value); end
end

# source://http//lib/http/headers/normalizer.rb#18
HTTP::Headers::Normalizer::Cache::MAX_SIZE = T.let(T.unsafe(nil), Integer)

# source://http//lib/http/headers/normalizer.rb#13
HTTP::Headers::Normalizer::NAME_PARTS_SEPARATOR_RE = T.let(T.unsafe(nil), Regexp)

# Authorization credentials for connecting to a proxy.
#
# source://http//lib/http/headers/known.rb#66
HTTP::Headers::PROXY_AUTHORIZATION = T.let(T.unsafe(nil), String)

# An HTTP cookie.
#
# source://http//lib/http/headers/known.rb#69
HTTP::Headers::SET_COOKIE = T.let(T.unsafe(nil), String)

# The form of encoding used to safely transfer the entity to the user.
# Currently defined methods are: chunked, compress, deflate, gzip, identity.
#
# source://http//lib/http/headers/known.rb#73
HTTP::Headers::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)

# The user agent string of the user agent.
#
# source://http//lib/http/headers/known.rb#80
HTTP::Headers::USER_AGENT = T.let(T.unsafe(nil), String)

# Tells downstream proxies how to match future request headers to decide
# whether the cached response can be used rather than requesting a fresh
# one from the origin server.
#
# source://http//lib/http/headers/known.rb#85
HTTP::Headers::VARY = T.let(T.unsafe(nil), String)

# MIME type encode/decode adapters
#
# source://http//lib/http/mime_type.rb#5
module HTTP::MimeType
  class << self
    # Returns adapter associated with MIME type
    #
    # @param type [#to_s]
    # @raise [Error] if no adapter found
    # @return [Class]
    #
    # source://http//lib/http/mime_type.rb#37
    def [](type); end

    # Resolves type by shortcut if possible
    #
    # @param type [#to_s]
    # @return [String]
    #
    # source://http//lib/http/mime_type.rb#58
    def normalize(type); end

    # Associate MIME type with adapter
    #
    # @example
    #
    #   module JsonAdapter
    #   class << self
    #   def encode(obj)
    #   # encode logic here
    #   end
    #
    #   def decode(str)
    #   # decode logic here
    #   end
    #   end
    #   end
    #
    #   HTTP::MimeType.register_adapter 'application/json', MyJsonAdapter
    # @param type [#to_s]
    # @param adapter [#encode, #decode]
    # @return [void]
    #
    # source://http//lib/http/mime_type.rb#28
    def register_adapter(type, adapter); end

    # Register a shortcut for MIME type
    #
    # @example
    #
    #   HTTP::MimeType.register_alias 'application/json', :json
    # @param type [#to_s]
    # @param shortcut [#to_sym]
    # @return [void]
    #
    # source://http//lib/http/mime_type.rb#50
    def register_alias(type, shortcut); end

    private

    # source://http//lib/http/mime_type.rb#65
    def adapters; end

    # source://http//lib/http/mime_type.rb#70
    def aliases; end
  end
end

# Base encode/decode MIME type adapter
#
# source://http//lib/http/mime_type/adapter.rb#9
class HTTP::MimeType::Adapter
  include ::Singleton::SingletonInstanceMethods
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # source://http//lib/http/mime_type/adapter.rb#19
  def decode(*_arg0); end

  # source://http//lib/http/mime_type/adapter.rb#19
  def encode(*_arg0); end

  class << self
    # source://http//lib/http/mime_type/adapter.rb#14
    def decode(*args, **_arg1, &block); end

    # source://http//lib/http/mime_type/adapter.rb#14
    def encode(*args, **_arg1, &block); end

    private

    # source://http//lib/http/mime_type/adapter.rb#10
    def allocate; end

    # source://http//lib/http/mime_type/adapter.rb#10
    def new(*_arg0); end
  end
end

# JSON encode/decode MIME type adapter
#
# source://http//lib/http/mime_type/json.rb#9
class HTTP::MimeType::JSON < ::HTTP::MimeType::Adapter
  # Decodes JSON
  #
  # source://http//lib/http/mime_type/json.rb#18
  def decode(str); end

  # Encodes object to JSON
  #
  # source://http//lib/http/mime_type/json.rb#11
  def encode(obj); end
end

# source://http//lib/http/options.rb#9
class HTTP::Options
  # @return [Options] a new instance of Options
  #
  # source://http//lib/http/options.rb#50
  def initialize(options = T.unsafe(nil)); end

  # source://http//lib/http/options.rb#40
  def body; end

  # source://http//lib/http/options.rb#40
  def cookies; end

  # @yield [dupped]
  #
  # source://http//lib/http/options.rb#172
  def dup; end

  # source://http//lib/http/options.rb#40
  def encoding; end

  # source://http//lib/http/options.rb#178
  def feature(name); end

  # source://http//lib/http/options.rb#38
  def features; end

  # source://http//lib/http/options.rb#106
  def features=(features); end

  # source://http//lib/http/options.rb#38
  def follow; end

  # source://http//lib/http/options.rb#129
  def follow=(value); end

  # source://http//lib/http/options.rb#40
  def form; end

  # source://http//lib/http/options.rb#40
  def headers; end

  # source://http//lib/http/options.rb#40
  def json; end

  # source://http//lib/http/options.rb#40
  def keep_alive_timeout; end

  # source://http//lib/http/options.rb#149
  def merge(other); end

  # source://http//lib/http/options.rb#40
  def nodelay; end

  # source://http//lib/http/options.rb#40
  def params; end

  # source://http//lib/http/options.rb#38
  def persistent; end

  # source://http//lib/http/options.rb#141
  def persistent=(value); end

  # @return [Boolean]
  #
  # source://http//lib/http/options.rb#145
  def persistent?; end

  # source://http//lib/http/options.rb#40
  def proxy; end

  # source://http//lib/http/options.rb#40
  def response; end

  # source://http//lib/http/options.rb#40
  def socket_class; end

  # source://http//lib/http/options.rb#40
  def ssl; end

  # source://http//lib/http/options.rb#40
  def ssl_context; end

  # source://http//lib/http/options.rb#40
  def ssl_socket_class; end

  # source://http//lib/http/options.rb#40
  def timeout_class; end

  # source://http//lib/http/options.rb#40
  def timeout_options; end

  # source://http//lib/http/options.rb#165
  def to_hash; end

  # source://http//lib/http/options.rb#44
  def with_body(value); end

  # source://http//lib/http/options.rb#44
  def with_cookies(value); end

  # source://http//lib/http/options.rb#44
  def with_encoding(value); end

  # source://http//lib/http/options.rb#44
  def with_features(value); end

  # source://http//lib/http/options.rb#44
  def with_follow(value); end

  # source://http//lib/http/options.rb#44
  def with_form(value); end

  # source://http//lib/http/options.rb#44
  def with_headers(value); end

  # source://http//lib/http/options.rb#44
  def with_json(value); end

  # source://http//lib/http/options.rb#44
  def with_keep_alive_timeout(value); end

  # source://http//lib/http/options.rb#44
  def with_nodelay(value); end

  # source://http//lib/http/options.rb#44
  def with_params(value); end

  # source://http//lib/http/options.rb#44
  def with_persistent(value); end

  # source://http//lib/http/options.rb#44
  def with_proxy(value); end

  # source://http//lib/http/options.rb#44
  def with_response(value); end

  # source://http//lib/http/options.rb#44
  def with_socket_class(value); end

  # source://http//lib/http/options.rb#44
  def with_ssl(value); end

  # source://http//lib/http/options.rb#44
  def with_ssl_context(value); end

  # source://http//lib/http/options.rb#44
  def with_ssl_socket_class(value); end

  # source://http//lib/http/options.rb#44
  def with_timeout_class(value); end

  # source://http//lib/http/options.rb#44
  def with_timeout_options(value); end

  protected

  # source://http//lib/http/options.rb#184
  def []=(option, val); end

  # source://http//lib/http/options.rb#40
  def body=(_arg0); end

  # source://http//lib/http/options.rb#40
  def cookies=(_arg0); end

  # source://http//lib/http/options.rb#40
  def encoding=(_arg0); end

  # source://http//lib/http/options.rb#40
  def form=(_arg0); end

  # source://http//lib/http/options.rb#40
  def headers=(_arg0); end

  # source://http//lib/http/options.rb#40
  def json=(_arg0); end

  # source://http//lib/http/options.rb#40
  def keep_alive_timeout=(_arg0); end

  # source://http//lib/http/options.rb#40
  def nodelay=(_arg0); end

  # source://http//lib/http/options.rb#40
  def params=(_arg0); end

  # source://http//lib/http/options.rb#40
  def proxy=(_arg0); end

  # source://http//lib/http/options.rb#40
  def response=(_arg0); end

  # source://http//lib/http/options.rb#40
  def socket_class=(_arg0); end

  # source://http//lib/http/options.rb#40
  def ssl=(_arg0); end

  # source://http//lib/http/options.rb#40
  def ssl_context=(_arg0); end

  # source://http//lib/http/options.rb#40
  def ssl_socket_class=(_arg0); end

  # source://http//lib/http/options.rb#40
  def timeout_class=(_arg0); end

  # source://http//lib/http/options.rb#40
  def timeout_options=(_arg0); end

  private

  # @raise [Error]
  #
  # source://http//lib/http/options.rb#190
  def argument_error!(message); end

  class << self
    # Returns the value of attribute available_features.
    #
    # source://http//lib/http/options.rb#17
    def available_features; end

    # Returns the value of attribute default_socket_class.
    #
    # source://http//lib/http/options.rb#16
    def default_socket_class; end

    # Sets the attribute default_socket_class
    #
    # @param value the value to set the attribute default_socket_class to.
    #
    # source://http//lib/http/options.rb#16
    def default_socket_class=(_arg0); end

    # Returns the value of attribute default_ssl_socket_class.
    #
    # source://http//lib/http/options.rb#16
    def default_ssl_socket_class; end

    # Sets the attribute default_ssl_socket_class
    #
    # @param value the value to set the attribute default_ssl_socket_class to.
    #
    # source://http//lib/http/options.rb#16
    def default_ssl_socket_class=(_arg0); end

    # Returns the value of attribute default_timeout_class.
    #
    # source://http//lib/http/options.rb#16
    def default_timeout_class; end

    # Sets the attribute default_timeout_class
    #
    # @param value the value to set the attribute default_timeout_class to.
    #
    # source://http//lib/http/options.rb#16
    def default_timeout_class=(_arg0); end

    # source://http//lib/http/options.rb#23
    def defined_options; end

    # source://http//lib/http/options.rb#19
    def new(options = T.unsafe(nil)); end

    # source://http//lib/http/options.rb#27
    def register_feature(name, impl); end

    protected

    # source://http//lib/http/options.rb#33
    def def_option(name, reader_only: T.unsafe(nil), &interpreter); end
  end
end

# Retriable performance ran out of attempts
#
# source://http//lib/http/retriable/errors.rb#5
class HTTP::OutOfRetriesError < ::HTTP::Error
  # source://http//lib/http/retriable/errors.rb#10
  def cause; end

  # Sets the attribute cause
  #
  # @param value the value to set the attribute cause to.
  #
  # source://http//lib/http/retriable/errors.rb#8
  def cause=(_arg0); end

  # Returns the value of attribute response.
  #
  # source://http//lib/http/retriable/errors.rb#6
  def response; end

  # Sets the attribute response
  #
  # @param value the value to set the attribute response to.
  #
  # source://http//lib/http/retriable/errors.rb#6
  def response=(_arg0); end
end

# source://http//lib/http/redirector.rb#8
class HTTP::Redirector
  # @option opts
  # @option opts
  # @param opts [Hash]
  # @return [Redirector] a new instance of Redirector
  #
  # source://http//lib/http/redirector.rb#42
  def initialize(opts = T.unsafe(nil)); end

  # Returns the value of attribute max_hops.
  #
  # source://http//lib/http/redirector.rb#37
  def max_hops; end

  # Follows redirects until non-redirect response found
  #
  # source://http//lib/http/redirector.rb#49
  def perform(request, response); end

  # Returns the value of attribute strict.
  #
  # source://http//lib/http/redirector.rb#32
  def strict; end

  private

  # source://http//lib/http/redirector.rb#86
  def collect_cookies_from_request; end

  # Carry cookies from one response to the next. Carrying cookies to the next response ends up
  # carrying them to the next request as well.
  #
  # Note that this isn't part of the IETF standard, but all major browsers support setting cookies
  # on redirect: https://blog.dubbelboer.com/2012/11/25/302-cookie.html
  #
  # source://http//lib/http/redirector.rb#105
  def collect_cookies_from_response; end

  # All known cookies. On the original request, this is only the original cookies, but after that,
  # Set-Cookie headers can add, set or delete cookies.
  #
  # source://http//lib/http/redirector.rb#81
  def cookie_jar; end

  # Check if we got into an endless loop
  #
  # @return [Boolean]
  #
  # source://http//lib/http/redirector.rb#129
  def endless_loop?; end

  # Redirect policy for follow
  #
  # @raise [StateError]
  # @return [Request]
  #
  # source://http//lib/http/redirector.rb#135
  def redirect_to(uri); end

  # Check if we reached max amount of redirect hops
  #
  # @return [Boolean]
  #
  # source://http//lib/http/redirector.rb#123
  def too_many_hops?; end
end

# Notifies that following redirects got into an endless loop
#
# source://http//lib/http/redirector.rb#13
class HTTP::Redirector::EndlessRedirectError < ::HTTP::Redirector::TooManyRedirectsError; end

# HTTP status codes which indicate redirects
#
# source://http//lib/http/redirector.rb#16
HTTP::Redirector::REDIRECT_CODES = T.let(T.unsafe(nil), Set)

# Verbs which will remain unchanged upon See Other response.
#
# source://http//lib/http/redirector.rb#27
HTTP::Redirector::SEE_OTHER_ALLOWED_VERBS = T.let(T.unsafe(nil), Set)

# Codes which which should raise StateError in strict mode if original
# request was any of {UNSAFE_VERBS}
#
# source://http//lib/http/redirector.rb#20
HTTP::Redirector::STRICT_SENSITIVE_CODES = T.let(T.unsafe(nil), Set)

# Notifies that we reached max allowed redirect hops
#
# source://http//lib/http/redirector.rb#10
class HTTP::Redirector::TooManyRedirectsError < ::HTTP::ResponseError; end

# Insecure http verbs, which should trigger StateError in strict mode
# upon {STRICT_SENSITIVE_CODES}
#
# source://http//lib/http/redirector.rb#24
HTTP::Redirector::UNSAFE_VERBS = T.let(T.unsafe(nil), Set)

# source://http//lib/http/request/body.rb#4
class HTTP::Request
  include ::HTTP::Base64
  include ::HTTP::Headers::Mixin
  extend ::Forwardable

  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param opts [Hash] a customizable set of options
  # @raise [UnsupportedMethodError]
  # @return [Request] a new instance of Request
  #
  # source://http//lib/http/request.rb#90
  def initialize(opts); end

  # Returns the value of attribute body.
  #
  # source://http//lib/http/request.rb#81
  def body; end

  # Setup tunnel through proxy for SSL request
  #
  # source://http//lib/http/request.rb#168
  def connect_using_proxy(socket); end

  # Compute HTTP request header for direct or proxy request
  #
  # @raise [RequestError]
  #
  # source://http//lib/http/request.rb#173
  def headline; end

  # @return [String]
  #
  # source://http//lib/http/request.rb#229
  def host(*args, **_arg1, &block); end

  # Compute and add the Proxy-Authorization header
  #
  # source://http//lib/http/request.rb#158
  def include_proxy_authorization_header; end

  # source://http//lib/http/request.rb#152
  def include_proxy_headers; end

  # Human-readable representation of base request info.
  #
  # @example
  #
  #   req.inspect
  #   # => #<HTTP::Request/1.1 GET https://example.com>
  # @return [String]
  #
  # source://http//lib/http/request.rb#221
  def inspect; end

  # Returns the value of attribute proxy.
  #
  # source://http//lib/http/request.rb#81
  def proxy; end

  # source://http//lib/http/request.rb#162
  def proxy_authorization_header; end

  # Compute HTTP request header SSL proxy connection
  #
  # source://http//lib/http/request.rb#187
  def proxy_connect_header; end

  # Headers to send with proxy connect request
  #
  # source://http//lib/http/request.rb#192
  def proxy_connect_headers; end

  # Returns new Request with updated uri
  #
  # source://http//lib/http/request.rb#107
  def redirect(uri, verb = T.unsafe(nil)); end

  # Scheme is normalized to be a lowercase symbol e.g. :http, :https
  #
  # source://http//lib/http/request.rb#74
  def scheme; end

  # Host for tcp socket
  #
  # source://http//lib/http/request.rb#204
  def socket_host; end

  # Port for tcp socket
  #
  # source://http//lib/http/request.rb#209
  def socket_port; end

  # Stream the request to a socket
  #
  # source://http//lib/http/request.rb#137
  def stream(socket); end

  # "Request URI" as per RFC 2616
  # http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html
  #
  # source://http//lib/http/request.rb#80
  def uri; end

  # Returns the value of attribute uri_normalizer.
  #
  # source://http//lib/http/request.rb#76
  def uri_normalizer; end

  # Is this request using an authenticated proxy?
  #
  # @return [Boolean]
  #
  # source://http//lib/http/request.rb#148
  def using_authenticated_proxy?; end

  # Is this request using a proxy?
  #
  # @return [Boolean]
  #
  # source://http//lib/http/request.rb#143
  def using_proxy?; end

  # Method is given as a lowercase symbol e.g. :get, :post
  #
  # source://http//lib/http/request.rb#71
  def verb; end

  # Returns the value of attribute version.
  #
  # source://http//lib/http/request.rb#81
  def version; end

  private

  # @raise [RequestError]
  # @return [String] Default host (with port if needed) header value.
  #
  # source://http//lib/http/request.rb#238
  def default_host_header_value; end

  # source://http//lib/http/request.rb#233
  def port; end

  # source://http//lib/http/request.rb#246
  def prepare_body(body); end

  # source://http//lib/http/request.rb#250
  def prepare_headers(headers); end
end

# source://http//lib/http/request/body.rb#5
class HTTP::Request::Body
  # @return [Body] a new instance of Body
  #
  # source://http//lib/http/request/body.rb#8
  def initialize(source); end

  # Request bodies are equivalent when they have the same source.
  #
  # source://http//lib/http/request/body.rb#48
  def ==(other); end

  # Yields chunks of content to be streamed to the request body.
  #
  # @yieldparam [String]
  #
  # source://http//lib/http/request/body.rb#34
  def each(&block); end

  # Returns size which should be used for the "Content-Length" header.
  #
  # @return [Integer]
  #
  # source://http//lib/http/request/body.rb#17
  def size; end

  # Returns the value of attribute source.
  #
  # source://http//lib/http/request/body.rb#6
  def source; end

  private

  # source://http//lib/http/request/body.rb#54
  def rewind(io); end

  # @raise [RequestError]
  #
  # source://http//lib/http/request/body.rb#76
  def validate_source_type!; end
end

# This class provides a "writable IO" wrapper around a proc object, with
# #write simply calling the proc, which we can pass in as the
# "destination IO" in IO.copy_stream.
#
# source://http//lib/http/request/body.rb#88
class HTTP::Request::Body::ProcIO
  # @return [ProcIO] a new instance of ProcIO
  #
  # source://http//lib/http/request/body.rb#89
  def initialize(block); end

  # source://http//lib/http/request/body.rb#93
  def write(data); end
end

# source://http//lib/http/request.rb#30
HTTP::Request::METHODS = T.let(T.unsafe(nil), Array)

# Default ports of supported schemes
#
# source://http//lib/http/request.rb#63
HTTP::Request::PORTS = T.let(T.unsafe(nil), Hash)

# Allowed schemes
#
# source://http//lib/http/request.rb#60
HTTP::Request::SCHEMES = T.let(T.unsafe(nil), Array)

# Default User-Agent header value
#
# source://http//lib/http/request.rb#28
HTTP::Request::USER_AGENT = T.let(T.unsafe(nil), String)

# The method given was not understood
#
# source://http//lib/http/request.rb#22
class HTTP::Request::UnsupportedMethodError < ::HTTP::RequestError; end

# The scheme of given URI was not understood
#
# source://http//lib/http/request.rb#25
class HTTP::Request::UnsupportedSchemeError < ::HTTP::RequestError; end

# source://http//lib/http/request/writer.rb#7
class HTTP::Request::Writer
  # @return [Writer] a new instance of Writer
  #
  # source://http//lib/http/request/writer.rb#20
  def initialize(socket, body, headers, headline); end

  # Adds the headers to the header array for the given request body we are working
  # with
  #
  # source://http//lib/http/request/writer.rb#49
  def add_body_type_headers; end

  # Adds headers to the request header from the headers array
  #
  # source://http//lib/http/request/writer.rb#28
  def add_headers; end

  # Returns true if the request should be sent in chunked encoding.
  #
  # @return [Boolean]
  #
  # source://http//lib/http/request/writer.rb#105
  def chunked?; end

  # Send headers needed to connect through proxy
  #
  # source://http//lib/http/request/writer.rb#42
  def connect_through_proxy; end

  # Yields chunks of request data that should be sent to the socket.
  #
  # It's important to send the request in a single write call when possible
  # in order to play nicely with Nagle's algorithm. Making two writes in a
  # row triggers a pathological case where Nagle is expecting a third write
  # that never happens.
  #
  # @yield [data]
  #
  # source://http//lib/http/request/writer.rb#81
  def each_chunk; end

  # Returns the chunk encoded for to the specified "Transfer-Encoding" header.
  #
  # source://http//lib/http/request/writer.rb#96
  def encode_chunk(chunk); end

  # Joins the headers specified in the request into a correctly formatted
  # http request header string
  #
  # source://http//lib/http/request/writer.rb#61
  def join_headers; end

  # Writes HTTP request data into the socket.
  #
  # source://http//lib/http/request/writer.rb#68
  def send_request; end

  # Stream the request to a socket
  #
  # source://http//lib/http/request/writer.rb#35
  def stream; end

  private

  # @raise [SocketWriteError] when unable to write to socket
  #
  # source://http//lib/http/request/writer.rb#112
  def write(data); end
end

# Chunked transfer encoding
#
# source://http//lib/http/request/writer.rb#15
HTTP::Request::Writer::CHUNKED = T.let(T.unsafe(nil), String)

# End of a chunked transfer
#
# source://http//lib/http/request/writer.rb#18
HTTP::Request::Writer::CHUNKED_END = T.let(T.unsafe(nil), String)

# CRLF is the universal HTTP delimiter
#
# source://http//lib/http/request/writer.rb#9
HTTP::Request::Writer::CRLF = T.let(T.unsafe(nil), String)

# Chunked data termintaor.
#
# source://http//lib/http/request/writer.rb#12
HTTP::Request::Writer::ZERO = T.let(T.unsafe(nil), String)

# Generic Request error
#
# source://http//lib/http/errors.rb#16
class HTTP::RequestError < ::HTTP::Error; end

# source://http//lib/http/response/status/reasons.rb#8
class HTTP::Response
  include ::HTTP::Headers::Mixin
  extend ::Forwardable

  # Inits a new instance
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param opts [Hash] a customizable set of options
  # @return [Response] a new instance of Response
  #
  # source://http//lib/http/response.rb#45
  def initialize(opts); end

  # @return [Body]
  #
  # source://http//lib/http/response.rb#26
  def body; end

  # Charset of response (if any)
  #
  # @return [String, nil]
  #
  # source://http//lib/http/response.rb#138
  def charset(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://http//lib/http/response.rb#146
  def chunked?; end

  # @return [Fixnum] status code
  #
  # source://http//lib/http/response.rb#68
  def code(*args, **_arg1, &block); end

  # The connection object used to make the corresponding request.
  #
  # @return [HTTP::Connection]
  #
  # source://http//lib/http/response.rb#81
  def connection(*args, **_arg1, &block); end

  # Value of the Content-Length header.
  #
  # @return [nil] if Content-Length was not given, or it's value was invalid
  #   (not an integer, e.g. empty string or string with non-digits).
  # @return [Integer] otherwise
  #
  # source://http//lib/http/response.rb#107
  def content_length; end

  # Parsed Content-Type header
  #
  # @return [HTTP::ContentType]
  #
  # source://http//lib/http/response.rb#126
  def content_type; end

  # source://http//lib/http/response.rb#140
  def cookies; end

  # Flushes body and returns self-reference
  #
  # @return [Response]
  #
  # source://http//lib/http/response.rb#97
  def flush; end

  # Inspect a response
  #
  # source://http//lib/http/response.rb#165
  def inspect; end

  # MIME type of response (if any)
  #
  # @return [String, nil]
  #
  # source://http//lib/http/response.rb#133
  def mime_type(*args, **_arg1, &block); end

  # Parse response body with corresponding MIME type adapter.
  #
  # @param type [#to_s] Parse as given MIME type.
  # @raise [Error] if no adapter found
  # @return [Object]
  #
  # source://http//lib/http/response.rb#160
  def parse(type = T.unsafe(nil)); end

  # @return [Hash]
  #
  # source://http//lib/http/response.rb#32
  def proxy_headers; end

  # source://http//lib/http/response.rb#77
  def readpartial(*args, **_arg1, &block); end

  # @return [String, nil] status message
  #
  # source://http//lib/http/response.rb#64
  def reason(*args, **_arg1, &block); end

  # @return [Request]
  #
  # source://http//lib/http/response.rb#29
  def request; end

  # @return [Status]
  #
  # source://http//lib/http/response.rb#20
  def status; end

  # Returns an Array ala Rack: `[status, headers, body]`
  #
  # @return [Array(Fixnum, Hash, String)]
  #
  # source://http//lib/http/response.rb#90
  def to_a; end

  # @return [String] eagerly consume the entire body as a string
  #
  # source://http//lib/http/response.rb#72
  def to_s(*args, **_arg1, &block); end

  # @return [String] eagerly consume the entire body as a string
  #
  # source://http//lib/http/response.rb#73
  def to_str(*args, **_arg1, &block); end

  # source://http//lib/http/response.rb#85
  def uri(*args, **_arg1, &block); end

  # @return [String]
  #
  # source://http//lib/http/response.rb#23
  def version; end

  private

  # source://http//lib/http/response.rb#171
  def default_encoding; end

  # Initialize an HTTP::Request from options.
  #
  # @raise [ArgumentError]
  # @return [HTTP::Request]
  #
  # source://http//lib/http/response.rb#180
  def init_request(opts); end
end

# A streamable response body, also easily converted into a string
#
# source://http//lib/http/response/body.rb#9
class HTTP::Response::Body
  include ::Enumerable
  extend ::Forwardable

  # @return [Body] a new instance of Body
  #
  # source://http//lib/http/response/body.rb#19
  def initialize(stream, encoding: T.unsafe(nil)); end

  # The connection object used to make the corresponding request.
  #
  # @return [HTTP::Connection]
  #
  # source://http//lib/http/response/body.rb#17
  def connection; end

  # Iterate over the body, allowing it to be enumerable
  #
  # source://http//lib/http/response/body.rb#36
  def each; end

  # source://http//lib/http/response/body.rb#12
  def empty?(*args, **_arg1, &block); end

  # Easier to interpret string inspect
  #
  # source://http//lib/http/response/body.rb#73
  def inspect; end

  # source://http//lib/http/response/body.rb#28
  def readpartial(*args); end

  # Assert that the body is actively being streamed
  #
  # @raise [StateError]
  #
  # source://http//lib/http/response/body.rb#66
  def stream!; end

  # @raise [StateError]
  # @return [String] eagerly consume the entire body as a string
  #
  # source://http//lib/http/response/body.rb#43
  def to_s; end

  # @raise [StateError]
  # @return [String] eagerly consume the entire body as a string
  #
  # source://http//lib/http/response/body.rb#63
  def to_str; end

  private

  # Retrieve encoding by name. If encoding cannot be found, default to binary.
  #
  # source://http//lib/http/response/body.rb#80
  def find_encoding(encoding); end
end

# source://http//lib/http/response/inflater.rb#7
class HTTP::Response::Inflater
  # @return [Inflater] a new instance of Inflater
  #
  # source://http//lib/http/response/inflater.rb#10
  def initialize(connection); end

  # Returns the value of attribute connection.
  #
  # source://http//lib/http/response/inflater.rb#8
  def connection; end

  # source://http//lib/http/response/inflater.rb#14
  def readpartial(*args); end

  private

  # source://http//lib/http/response/inflater.rb#27
  def zstream; end
end

# @api private
#
# source://http//lib/http/response/parser.rb#8
class HTTP::Response::Parser
  # @api private
  # @return [Parser] a new instance of Parser
  #
  # source://http//lib/http/response/parser.rb#11
  def initialize; end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#36
  def <<(data); end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#28
  def add(data); end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#60
  def add_body(chunk); end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#48
  def add_header(name, value); end

  # @api private
  # @return [Boolean]
  #
  # source://http//lib/http/response/parser.rb#56
  def finished?; end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#9
  def headers; end

  # @api private
  # @return [Boolean]
  #
  # source://http//lib/http/response/parser.rb#44
  def headers?; end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#9
  def http_version; end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#38
  def mark_header_finished; end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#52
  def mark_message_finished; end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#9
  def parser; end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#68
  def read(size); end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#17
  def reset; end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#9
  def status_code; end
end

# @api private
#
# source://http//lib/http/response/parser.rb#82
class HTTP::Response::Parser::Handler < ::LLHttp::Delegate
  # @api private
  # @return [Handler] a new instance of Handler
  #
  # source://http//lib/http/response/parser.rb#83
  def initialize(target); end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#110
  def on_body(body); end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#95
  def on_header_field(field); end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#100
  def on_header_value(value); end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#105
  def on_headers_complete; end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#114
  def on_message_complete; end

  # @api private
  #
  # source://http//lib/http/response/parser.rb#89
  def reset; end

  private

  # @api private
  #
  # source://http//lib/http/response/parser.rb#120
  def append_header; end
end

# source://http//lib/http/response/status/reasons.rb#9
class HTTP::Response::Status
  # source://http//lib/http/response/status.rb#148
  def __getobj__; end

  # @raise [TypeError]
  #
  # source://http//lib/http/response/status.rb#142
  def __setobj__(obj); end

  # source://http//lib/http/response/status.rb#135
  def accepted?; end

  # source://http//lib/http/response/status.rb#135
  def already_reported?; end

  # source://http//lib/http/response/status.rb#135
  def bad_gateway?; end

  # source://http//lib/http/response/status.rb#135
  def bad_request?; end

  # Check if status code is client error (4XX)
  #
  # @return [Boolean]
  #
  # source://http//lib/http/response/status.rb#108
  def client_error?; end

  # @return [Fixnum] status code
  #
  # source://http//lib/http/response/status.rb#75
  def code; end

  # source://http//lib/http/response/status.rb#135
  def conflict?; end

  # source://http//lib/http/response/status.rb#135
  def continue?; end

  # source://http//lib/http/response/status.rb#135
  def created?; end

  # source://http//lib/http/response/status.rb#135
  def expectation_failed?; end

  # source://http//lib/http/response/status.rb#135
  def failed_dependency?; end

  # source://http//lib/http/response/status.rb#135
  def forbidden?; end

  # source://http//lib/http/response/status.rb#135
  def found?; end

  # source://http//lib/http/response/status.rb#135
  def gateway_timeout?; end

  # source://http//lib/http/response/status.rb#135
  def gone?; end

  # source://http//lib/http/response/status.rb#135
  def http_version_not_supported?; end

  # source://http//lib/http/response/status.rb#135
  def im_used?; end

  # Check if status code is informational (1XX)
  #
  # @return [Boolean]
  #
  # source://http//lib/http/response/status.rb#90
  def informational?; end

  # Printable version of HTTP Status, surrounded by quote marks,
  # with special characters escaped.
  #
  # (see String#inspect)
  #
  # source://http//lib/http/response/status.rb#130
  def inspect; end

  # source://http//lib/http/response/status.rb#135
  def insufficient_storage?; end

  # source://http//lib/http/response/status.rb#135
  def internal_server_error?; end

  # source://http//lib/http/response/status.rb#135
  def length_required?; end

  # source://http//lib/http/response/status.rb#135
  def locked?; end

  # source://http//lib/http/response/status.rb#135
  def loop_detected?; end

  # source://http//lib/http/response/status.rb#135
  def method_not_allowed?; end

  # source://http//lib/http/response/status.rb#135
  def misdirected_request?; end

  # source://http//lib/http/response/status.rb#135
  def moved_permanently?; end

  # source://http//lib/http/response/status.rb#135
  def multi_status?; end

  # source://http//lib/http/response/status.rb#135
  def multiple_choices?; end

  # source://http//lib/http/response/status.rb#135
  def network_authentication_required?; end

  # source://http//lib/http/response/status.rb#135
  def no_content?; end

  # source://http//lib/http/response/status.rb#135
  def non_authoritative_information?; end

  # source://http//lib/http/response/status.rb#135
  def not_acceptable?; end

  # source://http//lib/http/response/status.rb#135
  def not_extended?; end

  # source://http//lib/http/response/status.rb#135
  def not_found?; end

  # source://http//lib/http/response/status.rb#135
  def not_implemented?; end

  # source://http//lib/http/response/status.rb#135
  def not_modified?; end

  # source://http//lib/http/response/status.rb#135
  def ok?; end

  # source://http//lib/http/response/status.rb#135
  def partial_content?; end

  # source://http//lib/http/response/status.rb#135
  def payload_too_large?; end

  # source://http//lib/http/response/status.rb#135
  def payment_required?; end

  # source://http//lib/http/response/status.rb#135
  def permanent_redirect?; end

  # source://http//lib/http/response/status.rb#135
  def precondition_failed?; end

  # source://http//lib/http/response/status.rb#135
  def precondition_required?; end

  # source://http//lib/http/response/status.rb#135
  def processing?; end

  # source://http//lib/http/response/status.rb#135
  def proxy_authentication_required?; end

  # source://http//lib/http/response/status.rb#135
  def range_not_satisfiable?; end

  # @return [String, nil] status message
  # @see REASONS
  #
  # source://http//lib/http/response/status.rb#79
  def reason; end

  # Check if status code is redirection (3XX)
  #
  # @return [Boolean]
  #
  # source://http//lib/http/response/status.rb#102
  def redirect?; end

  # source://http//lib/http/response/status.rb#135
  def request_header_fields_too_large?; end

  # source://http//lib/http/response/status.rb#135
  def request_timeout?; end

  # source://http//lib/http/response/status.rb#135
  def reset_content?; end

  # source://http//lib/http/response/status.rb#135
  def see_other?; end

  # Check if status code is server error (5XX)
  #
  # @return [Boolean]
  #
  # source://http//lib/http/response/status.rb#114
  def server_error?; end

  # source://http//lib/http/response/status.rb#135
  def service_unavailable?; end

  # Check if status code is successful (2XX)
  #
  # @return [Boolean]
  #
  # source://http//lib/http/response/status.rb#96
  def success?; end

  # source://http//lib/http/response/status.rb#135
  def switching_protocols?; end

  # source://http//lib/http/response/status.rb#135
  def temporary_redirect?; end

  # @return [String] string representation of HTTP status
  #
  # source://http//lib/http/response/status.rb#84
  def to_s; end

  # Symbolized {#reason}
  #
  # @return [nil] unless code is well-known (see REASONS)
  # @return [Symbol]
  #
  # source://http//lib/http/response/status.rb#122
  def to_sym; end

  # source://http//lib/http/response/status.rb#135
  def too_many_requests?; end

  # source://http//lib/http/response/status.rb#135
  def unauthorized?; end

  # source://http//lib/http/response/status.rb#135
  def unavailable_for_legal_reasons?; end

  # source://http//lib/http/response/status.rb#135
  def unprocessable_entity?; end

  # source://http//lib/http/response/status.rb#135
  def unsupported_media_type?; end

  # source://http//lib/http/response/status.rb#135
  def upgrade_required?; end

  # source://http//lib/http/response/status.rb#135
  def uri_too_long?; end

  # source://http//lib/http/response/status.rb#135
  def use_proxy?; end

  # source://http//lib/http/response/status.rb#135
  def variant_also_negotiates?; end

  class << self
    # Coerces given value to Status.
    #
    # @example
    #   Status.coerce(:bad_request) # => Status.new(400)
    #   Status.coerce("400")        # => Status.new(400)
    #   Status.coerce(true)         # => raises HTTP::Error
    # @param object [Symbol, #to_i]
    # @raise [Error] if coercion is impossible
    # @return [Status]
    #
    # source://http//lib/http/response/status.rb#33
    def [](object); end

    # Coerces given value to Status.
    #
    # @example
    #
    #   Status.coerce(:bad_request) # => Status.new(400)
    #   Status.coerce("400")        # => Status.new(400)
    #   Status.coerce(true)         # => raises HTTP::Error
    # @param object [Symbol, #to_i]
    # @raise [Error] if coercion is impossible
    # @return [Status]
    #
    # source://http//lib/http/response/status.rb#22
    def coerce(object); end

    private

    # Symbolizes given string
    #
    # @example
    #
    #   symbolize "Bad Request"           # => :bad_request
    #   symbolize "Request-URI Too Long"  # => :request_uri_too_long
    #   symbolize "I'm a Teapot"          # => :im_a_teapot
    # @param str [#to_s]
    # @return [Symbol]
    #
    # source://http//lib/http/response/status.rb#47
    def symbolize(str); end
  end
end

# Code to Reason map
#
# @example Usage
#
#   REASONS[400] # => "Bad Request"
#   REASONS[414] # => "Request-URI Too Long"
# @return [Hash<Fixnum => String>]
#
# source://http//lib/http/response/status/reasons.rb#18
HTTP::Response::Status::REASONS = T.let(T.unsafe(nil), Hash)

# Code to Symbol map
#
# @example Usage
#
#   SYMBOLS[400] # => :bad_request
#   SYMBOLS[414] # => :request_uri_too_long
#   SYMBOLS[418] # => :im_a_teapot
# @return [Hash<Fixnum => Symbol>]
#
# source://http//lib/http/response/status.rb#61
HTTP::Response::Status::SYMBOLS = T.let(T.unsafe(nil), Hash)

# Reversed {SYMBOLS} map.
#
# @example Usage
#
#   SYMBOL_CODES[:bad_request]           # => 400
#   SYMBOL_CODES[:request_uri_too_long]  # => 414
#   SYMBOL_CODES[:im_a_teapot]           # => 418
# @return [Hash<Symbol => Fixnum>]
#
# source://http//lib/http/response/status.rb#72
HTTP::Response::Status::SYMBOL_CODES = T.let(T.unsafe(nil), Hash)

# Generic Response error
#
# source://http//lib/http/errors.rb#19
class HTTP::ResponseError < ::HTTP::Error; end

# Types of Connection errors
#
# source://http//lib/http/errors.rb#11
class HTTP::ResponseHeaderError < ::HTTP::ConnectionError; end

# source://http//lib/http/retriable/delay_calculator.rb#4
module HTTP::Retriable; end

# Retriable version of HTTP::Client.
#
# @see http://www.rubydoc.info/gems/http/HTTP/Client
#
# source://http//lib/http/retriable/client.rb#10
class HTTP::Retriable::Client < ::HTTP::Client
  # @param performer [Performer]
  # @param options [HTTP::Options, Hash]
  # @return [Client] a new instance of Client
  #
  # source://http//lib/http/retriable/client.rb#13
  def initialize(performer, options); end

  # Overriden version of `HTTP::Client#make_request`.
  #
  # Monitors request/response phase with performer.
  #
  # @see http://www.rubydoc.info/gems/http/HTTP/Client:perform
  #
  # source://http//lib/http/retriable/client.rb#23
  def perform(req, options); end

  private

  # Overriden version of `HTTP::Chainable#branch`.
  #
  # @return [HTTP::Retriable::Client]
  #
  # source://http//lib/http/retriable/client.rb#32
  def branch(options); end
end

# @api private
#
# source://http//lib/http/retriable/delay_calculator.rb#6
class HTTP::Retriable::DelayCalculator
  # @api private
  # @return [DelayCalculator] a new instance of DelayCalculator
  #
  # source://http//lib/http/retriable/delay_calculator.rb#7
  def initialize(opts); end

  # @api private
  #
  # source://http//lib/http/retriable/delay_calculator.rb#47
  def calculate_delay_from_iteration(iteration); end

  # @api private
  #
  # source://http//lib/http/retriable/delay_calculator.rb#16
  def call(iteration, response); end

  # Spec for Retry-After header
  # https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After
  #
  # @api private
  #
  # source://http//lib/http/retriable/delay_calculator.rb#37
  def delay_from_retry_header(value); end

  # @api private
  #
  # source://http//lib/http/retriable/delay_calculator.rb#59
  def ensure_dealy_in_bounds(delay); end
end

# @api private
#
# source://http//lib/http/retriable/delay_calculator.rb#26
HTTP::Retriable::DelayCalculator::RFC2822_DATE_REGEX = T.let(T.unsafe(nil), Regexp)

# Request performing watchdog.
#
# @api private
#
# source://http//lib/http/retriable/performer.rb#12
class HTTP::Retriable::Performer
  # @api private
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param opts [Hash]
  # @return [Performer] a new instance of Performer
  #
  # source://http//lib/http/retriable/performer.rb#34
  def initialize(opts); end

  # @api private
  #
  # source://http//lib/http/retriable/performer.rb#76
  def calculate_delay(iteration, response); end

  # Watches request/response execution.
  #
  # If any of {RETRIABLE_ERRORS} occur or response status is `5xx`, retries
  # up to `:tries` amount of times. Sleeps for amount of seconds calculated
  # with `:delay` proc before each retry.
  #
  # @api private
  # @see #initialize
  #
  # source://http//lib/http/retriable/performer.rb#51
  def perform(client, req, &block); end

  private

  # Builds OutOfRetriesError
  #
  # @api private
  # @param request [HTTP::Request]
  # @param status [HTTP::Response, nil]
  # @param exception [Exception, nil]
  #
  # source://http//lib/http/retriable/performer.rb#140
  def out_of_retries_error(request, response, exception); end

  # @api private
  # @return [Boolean]
  #
  # source://http//lib/http/retriable/performer.rb#106
  def retry_exception?(err); end

  # @api private
  # @return [Boolean]
  #
  # source://http//lib/http/retriable/performer.rb#96
  def retry_request?(req, err, res, attempt); end

  # @api private
  # @return [Boolean]
  #
  # source://http//lib/http/retriable/performer.rb#110
  def retry_response?(res); end

  # @api private
  #
  # source://http//lib/http/retriable/performer.rb#83
  def try_request; end

  # @api private
  #
  # source://http//lib/http/retriable/performer.rb#125
  def wait_for_retry_or_raise(req, err, res, attempt); end
end

# Exceptions we should retry
#
# @api private
#
# source://http//lib/http/retriable/performer.rb#14
HTTP::Retriable::Performer::RETRIABLE_ERRORS = T.let(T.unsafe(nil), Array)

# source://http//lib/http/errors.rb#12
class HTTP::SocketReadError < ::HTTP::ConnectionError; end

# source://http//lib/http/errors.rb#13
class HTTP::SocketWriteError < ::HTTP::ConnectionError; end

# Requested to do something when we're in the wrong state
#
# source://http//lib/http/errors.rb#22
class HTTP::StateError < ::HTTP::ResponseError; end

# When status code indicates an error
#
# source://http//lib/http/errors.rb#25
class HTTP::StatusError < ::HTTP::ResponseError
  # @return [StatusError] a new instance of StatusError
  #
  # source://http//lib/http/errors.rb#28
  def initialize(response); end

  # Returns the value of attribute response.
  #
  # source://http//lib/http/errors.rb#26
  def response; end
end

# source://http//lib/http/timeout/null.rb#6
module HTTP::Timeout; end

# source://http//lib/http/timeout/global.rb#10
class HTTP::Timeout::Global < ::HTTP::Timeout::Null
  # @return [Global] a new instance of Global
  #
  # source://http//lib/http/timeout/global.rb#11
  def initialize(*args); end

  # Write to the socket
  #
  # source://http//lib/http/timeout/global.rb#56
  def <<(data); end

  # source://http//lib/http/timeout/global.rb#22
  def connect(socket_class, host, port, nodelay = T.unsafe(nil)); end

  # source://http//lib/http/timeout/global.rb#32
  def connect_ssl; end

  # Read from the socket
  #
  # source://http//lib/http/timeout/global.rb#47
  def readpartial(size, buffer = T.unsafe(nil)); end

  # To future me: Don't remove this again, past you was smarter.
  #
  # source://http//lib/http/timeout/global.rb#18
  def reset_counter; end

  # Write to the socket
  #
  # source://http//lib/http/timeout/global.rb#52
  def write(data); end

  private

  # @raise [TimeoutError]
  #
  # source://http//lib/http/timeout/global.rb#108
  def log_time; end

  # Perform the given I/O operation with the given argument
  #
  # source://http//lib/http/timeout/global.rb#69
  def perform_io; end

  # source://http//lib/http/timeout/global.rb#60
  def read_nonblock(size, buffer = T.unsafe(nil)); end

  # Due to the run/retry nature of nonblocking I/O, it's easier to keep track of time
  # via method calls instead of a block to monitor.
  #
  # source://http//lib/http/timeout/global.rb#104
  def reset_timer; end

  # Wait for a socket to become readable
  #
  # source://http//lib/http/timeout/global.rb#91
  def wait_readable_or_timeout; end

  # Wait for a socket to become writable
  #
  # source://http//lib/http/timeout/global.rb#97
  def wait_writable_or_timeout; end

  # source://http//lib/http/timeout/global.rb#64
  def write_nonblock(data); end
end

# source://http//lib/http/timeout/null.rb#7
class HTTP::Timeout::Null
  # @return [Null] a new instance of Null
  #
  # source://http//lib/http/timeout/null.rb#10
  def initialize(options = T.unsafe(nil)); end

  # Write to the socket
  #
  # source://http//lib/http/timeout/null.rb#58
  def <<(data); end

  # source://http//lib/http/timeout/null.rb#25
  def close; end

  # @return [Boolean]
  #
  # source://http//lib/http/timeout/null.rb#29
  def closed?; end

  # Connects to a socket
  #
  # source://http//lib/http/timeout/null.rb#15
  def connect(socket_class, host, port, nodelay = T.unsafe(nil)); end

  # Starts a SSL connection on a socket
  #
  # source://http//lib/http/timeout/null.rb#21
  def connect_ssl; end

  # Returns the value of attribute options.
  #
  # source://http//lib/http/timeout/null.rb#8
  def options; end

  # Read from the socket
  #
  # source://http//lib/http/timeout/null.rb#48
  def readpartial(size, buffer = T.unsafe(nil)); end

  # Returns the value of attribute socket.
  #
  # source://http//lib/http/timeout/null.rb#8
  def socket; end

  # Configures the SSL connection and starts the connection
  #
  # source://http//lib/http/timeout/null.rb#34
  def start_tls(host, ssl_socket_class, ssl_context); end

  # Write to the socket
  #
  # source://http//lib/http/timeout/null.rb#55
  def write(data); end

  private

  # Retry reading
  #
  # source://http//lib/http/timeout/null.rb#63
  def rescue_readable(timeout = T.unsafe(nil)); end

  # Retry writing
  #
  # source://http//lib/http/timeout/null.rb#71
  def rescue_writable(timeout = T.unsafe(nil)); end
end

# source://http//lib/http/timeout/per_operation.rb#9
class HTTP::Timeout::PerOperation < ::HTTP::Timeout::Null
  # @return [PerOperation] a new instance of PerOperation
  #
  # source://http//lib/http/timeout/per_operation.rb#14
  def initialize(*args); end

  # source://http//lib/http/timeout/per_operation.rb#22
  def connect(socket_class, host, port, nodelay = T.unsafe(nil)); end

  # source://http//lib/http/timeout/per_operation.rb#29
  def connect_ssl; end

  # Read data from the socket
  #
  # source://http//lib/http/timeout/per_operation.rb#38
  def readpartial(size, buffer = T.unsafe(nil)); end

  # Write data to the socket
  #
  # source://http//lib/http/timeout/per_operation.rb#63
  def write(data); end
end

# source://http//lib/http/timeout/per_operation.rb#10
HTTP::Timeout::PerOperation::CONNECT_TIMEOUT = T.let(T.unsafe(nil), Float)

# source://http//lib/http/timeout/per_operation.rb#12
HTTP::Timeout::PerOperation::READ_TIMEOUT = T.let(T.unsafe(nil), Float)

# source://http//lib/http/timeout/per_operation.rb#11
HTTP::Timeout::PerOperation::WRITE_TIMEOUT = T.let(T.unsafe(nil), Float)

# Generic Timeout error
#
# source://http//lib/http/errors.rb#36
class HTTP::TimeoutError < ::HTTP::Error; end

# source://http//lib/http/uri.rb#6
class HTTP::URI
  extend ::Forwardable

  # Creates an HTTP::URI instance from the given options
  #
  # @option options_or_uri
  # @option options_or_uri
  # @option options_or_uri
  # @option options_or_uri
  # @option options_or_uri
  # @option options_or_uri
  # @option options_or_uri
  # @option options_or_uri
  # @param options_or_uri [Hash, Addressable::URI]
  # @return [HTTP::URI] new URI instance
  #
  # source://http//lib/http/uri.rb#104
  def initialize(options_or_uri = T.unsafe(nil)); end

  # Are these URI objects equal? Normalizes both URIs prior to comparison
  #
  # @param other [Object] URI to compare this one with
  # @return [TrueClass, FalseClass] are the URIs equivalent (after normalization)?
  #
  # source://http//lib/http/uri.rb#123
  def ==(other); end

  # source://http//lib/http/uri.rb#12
  def authority(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#12
  def authority=(*args, **_arg1, &block); end

  # @return [Object] duplicated URI
  #
  # source://http//lib/http/uri.rb#174
  def dup; end

  # Are these URI objects equal? Does NOT normalizes both URIs prior to comparison
  #
  # @param other [Object] URI to compare this one with
  # @return [TrueClass, FalseClass] are the URIs equivalent?
  #
  # source://http//lib/http/uri.rb#132
  def eql?(other); end

  # source://http//lib/http/uri.rb#19
  def fragment(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#19
  def fragment=(*args, **_arg1, &block); end

  # Hash value based off the normalized form of a URI
  #
  # @return [Integer] A hash of the URI
  #
  # source://http//lib/http/uri.rb#139
  def hash; end

  # Host, either a domain name or IP address. If the host is an IPv6 address, it will be returned
  # without brackets surrounding it.
  #
  # @return [String] The host of the URI
  #
  # source://http//lib/http/uri.rb#26
  def host; end

  # Sets the host component for the URI.
  #
  # @param new_host [String, #to_str] The new host component.
  # @return [void]
  #
  # source://http//lib/http/uri.rb#147
  def host=(new_host); end

  # @return [True] if URI is HTTP
  # @return [False] otherwise
  #
  # source://http//lib/http/uri.rb#163
  def http?; end

  # @return [True] if URI is HTTPS
  # @return [False] otherwise
  #
  # source://http//lib/http/uri.rb#169
  def https?; end

  # @return [String] human-readable representation of URI
  #
  # source://http//lib/http/uri.rb#187
  def inspect; end

  # source://http//lib/http/uri.rb#20
  def join(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#20
  def normalize(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#12
  def normalized_authority(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#19
  def normalized_fragment(*args, **_arg1, &block); end

  # Normalized host, either a domain name or IP address. If the host is an IPv6 address, it will
  # be returned without brackets surrounding it.
  #
  # @return [String] The normalized host of the URI
  #
  # source://http//lib/http/uri.rb#32
  def normalized_host; end

  # source://http//lib/http/uri.rb#11
  def normalized_password(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#15
  def normalized_path(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#14
  def normalized_port(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#16
  def normalized_query(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#9
  def normalized_scheme(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#10
  def normalized_user(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#20
  def omit(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#13
  def origin(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#13
  def origin=(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#11
  def password(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#11
  def password=(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#15
  def path(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#15
  def path=(*args, **_arg1, &block); end

  # Port number, either as specified or the default if unspecified
  #
  # @return [Integer] port number
  #
  # source://http//lib/http/uri.rb#157
  def port; end

  # source://http//lib/http/uri.rb#14
  def port=(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#16
  def query(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#16
  def query=(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#17
  def query_values(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#17
  def query_values=(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#18
  def request_uri(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#18
  def request_uri=(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#9
  def scheme(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#9
  def scheme=(*args, **_arg1, &block); end

  # Convert an HTTP::URI to a String
  #
  # @return [String] URI serialized as a String
  #
  # source://http//lib/http/uri.rb#181
  def to_s; end

  # Convert an HTTP::URI to a String
  #
  # @return [String] URI serialized as a String
  #
  # source://http//lib/http/uri.rb#184
  def to_str; end

  # source://http//lib/http/uri.rb#10
  def user(*args, **_arg1, &block); end

  # source://http//lib/http/uri.rb#10
  def user=(*args, **_arg1, &block); end

  private

  # Process a URI host, adding or removing surrounding brackets if the host is an IPv6 address.
  #
  # @param brackets [Boolean] When true, brackets will be added to IPv6 addresses if missing. When
  #   false, they will be removed if present.
  # @return [String] Host with IPv6 address brackets added or removed
  #
  # source://http//lib/http/uri.rb#199
  def process_ipv6_brackets(raw_host, brackets: T.unsafe(nil)); end

  class << self
    # Encodes key/value pairs as application/x-www-form-urlencoded
    #
    # @param form_values [#to_hash, #to_ary] to encode
    # @param sort [TrueClass, FalseClass] should key/value pairs be sorted first?
    # @return [String] encoded value
    #
    # source://http//lib/http/uri.rb#73
    def form_encode(form_values, sort = T.unsafe(nil)); end

    # Parse the given URI string, returning an HTTP::URI object
    #
    # @param uri [HTTP::URI, String, #to_str] to parse
    # @return [HTTP::URI] new URI instance
    #
    # source://http//lib/http/uri.rb#61
    def parse(uri); end

    # Percent-encode all characters matching a regular expression.
    #
    # @param string [String] raw string
    # @private
    # @return [String] encoded value
    #
    # source://http//lib/http/uri.rb#84
    def percent_encode(string); end
  end
end

# @private
#
# source://http//lib/http/uri.rb#38
HTTP::URI::HTTPS_SCHEME = T.let(T.unsafe(nil), String)

# @private
#
# source://http//lib/http/uri.rb#35
HTTP::URI::HTTP_SCHEME = T.let(T.unsafe(nil), String)

# @private
#
# source://http//lib/http/uri.rb#44
HTTP::URI::NORMALIZER = T.let(T.unsafe(nil), Proc)

# @private
#
# source://http//lib/http/uri.rb#41
HTTP::URI::PERCENT_ENCODE = T.let(T.unsafe(nil), Regexp)

# source://http//lib/http/version.rb#4
HTTP::VERSION = T.let(T.unsafe(nil), String)
