# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dry-types` gem.
# Please instead update this file by running `bin/tapioca gem dry-types`.

# Main library namespace
#
# @api public
#
# source://dry-types//lib/dry/types/constraints.rb#3
module Dry
  class << self
    # source://dry-configurable/1.1.0/lib/dry/configurable.rb#11
    def Configurable(**options); end

    # source://dry-core/1.0.1/lib/dry/core.rb#52
    def Equalizer(*keys, **options); end

    # Export registered types as a module with constants
    #
    # @api public
    # @example no options
    #
    #   module Types
    #   # imports all types as constants, uses modules for namespaces
    #   include Dry.Types()
    #   end
    #   # strict types are exported by default
    #   Types::Integer
    #   # => #<Dry::Types[Constrained<Nominal<Integer> rule=[type?(Integer)]>]>
    #   Types::Nominal::Integer
    #   # => #<Dry::Types[Nominal<Integer>]>
    # @example changing default types
    #
    #   module Types
    #   include Dry.Types(default: :nominal)
    #   end
    #   Types::Integer
    #   # => #<Dry::Types[Nominal<Integer>]>
    # @example cherry-picking namespaces
    #
    #   module Types
    #   include Dry.Types(:strict, :coercible)
    #   end
    #   # cherry-picking discards default types,
    #   # provide the :default option along with the list of
    #   # namespaces if you want the to be exported
    #   Types.constants # => [:Coercible, :Strict]
    # @example custom names
    #   module Types
    #   include Dry.Types(coercible: :Kernel)
    #   end
    #   Types::Kernel::Integer
    #   # => #<Dry::Types[Constructor<Nominal<Integer> fn=Kernel.Integer>]>
    # @param namespaces [Array<Symbol>] List of type namespaces to export
    # @param default [Symbol] Default namespace to export
    # @param aliases [Hash{Symbol => Symbol}] Optional renamings, like strict: :Draconian
    # @return [Dry::Types::Module]
    # @see Dry::Types::Module
    #
    # source://dry-types//lib/dry/types.rb#253
    def Types(*namespaces, default: T.unsafe(nil), **aliases); end
  end
end

# @api public
# @see Dry.Types
#
# source://dry-types//lib/dry/types/constraints.rb#7
module Dry::Types
  include ::Dry::Core::Constants
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes
  extend ::Dry::Core::Extensions
  extend ::Dry::Core::Deprecations::Interface

  class << self
    # @api public
    # @param options [Hash]
    # @return [Dry::Logic::Rule]
    #
    # source://dry-types//lib/dry/types/constraints.rb#13
    def Rule(options); end

    # Get a built-in type by its name
    #
    # @api public
    # @param name [String, Class]
    # @return [Type, Class]
    #
    # source://dry-types//lib/dry/types.rb#115
    def [](name); end

    # @api private
    #
    # source://dry-types//lib/dry/types.rb#163
    def const_missing(const); end

    # Return container with registered built-in type objects
    #
    # @api private
    # @return [Container{String => Nominal}]
    #
    # source://dry-types//lib/dry/types.rb#82
    def container; end

    # Add a new type builder method. This is a public API for defining custom
    # type constructors
    #
    # @api public
    # @example simple custom type constructor
    #   Dry::Types.define_builder(:or_nil) do |type|
    #   type.optional.fallback(nil)
    #   end
    #
    #   Dry::Types["integer"].or_nil.("foo") # => nil
    # @example fallback alias
    #   Dry::Types.define_builder(:or) do |type, fallback|
    #   type.fallback(fallback)
    #   end
    #
    #   Dry::Types["integer"].or(100).("foo") # => 100
    # @param method [Symbol]
    # @param block [#call]
    #
    # source://dry-types//lib/dry/types.rb#197
    def define_builder(method, &block); end

    # Infer a type identifier from the provided class
    #
    # @api public
    # @param klass [#to_s]
    # @return [String]
    #
    # source://dry-types//lib/dry/types.rb#149
    def identifier(klass); end

    # @api private
    # @private
    #
    # source://dry-types//lib/dry/types.rb#73
    def included(*_arg0); end

    # @api public
    #
    # source://dry-types//lib/dry/types.rb#33
    def loader; end

    # @api public
    #
    # source://dry-core/1.0.1/lib/dry/core/deprecations.rb#202
    def module(*args, &block); end

    # Register a new built-in type
    #
    # @api private
    # @param name [String]
    # @param type [Type]
    # @param block [#call, nil]
    # @return [Container{String => Nominal}]
    #
    # source://dry-types//lib/dry/types.rb#104
    def register(name, type = T.unsafe(nil), &block); end

    # Check if a give type is registered
    #
    # @api private
    # @return [Boolean]
    #
    # source://dry-types//lib/dry/types.rb#91
    def registered?(class_or_identifier); end

    # @api private
    # @return [Dry::Logic::RuleCompiler]
    #
    # source://dry-types//lib/dry/types/constraints.rb#26
    def rule_compiler; end

    # Cached type map
    #
    # @api private
    # @return [Concurrent::Map]
    #
    # source://dry-types//lib/dry/types.rb#158
    def type_map; end
  end
end

# All built-in primitives
#
# @api public
#
# source://dry-types//lib/dry/types/core.rb#38
Dry::Types::ALL_PRIMITIVES = T.let(T.unsafe(nil), Hash)

# source://dry-types//lib/dry/types/any.rb#45
Dry::Types::Any = T.let(T.unsafe(nil), Dry::Types::AnyClass)

# Any is a nominal type that defines Object as the primitive class
#
# This type is useful in places where you can't be specific about the type
# and anything is acceptable.
#
# @api public
#
# source://dry-types//lib/dry/types/any.rb#11
class Dry::Types::AnyClass < ::Dry::Types::Nominal
  # @api private
  # @return [AnyClass] a new instance of AnyClass
  #
  # source://dry-types//lib/dry/types/any.rb#17
  def initialize(**options); end

  # @api public
  # @return [String]
  #
  # source://dry-types//lib/dry/types/any.rb#24
  def name; end

  # @api public
  # @return [Array]
  #
  # source://dry-types//lib/dry/types/any.rb#40
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @param new_options [Hash]
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/any.rb#33
  def with(**new_options); end

  class << self
    # @api public
    #
    # source://dry-types//lib/dry/types/any.rb#12
    def name; end
  end
end

# Array type can be used to define an array with optional member type
#
# @api public
#
# source://dry-types//lib/dry/types/array.rb#15
class Dry::Types::Array < ::Dry::Types::Nominal
  # @api private
  #
  # source://dry-types//lib/dry/types/array.rb#27
  def constructor_type; end

  # Build an array type with a member type
  #
  # @api public
  # @param type [Type, #call]
  # @return [Array::Member]
  #
  # source://dry-types//lib/dry/types/array.rb#16
  def of(type); end
end

# @api private
#
# source://dry-types//lib/dry/types/array/constructor.rb#9
class Dry::Types::Array::Constructor < ::Dry::Types::Constructor
  # @api private
  #
  # source://dry-types//lib/dry/types/array/constructor.rb#10
  def constructor_type; end

  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/array/constructor.rb#17
  def lax; end

  # @api public
  # @see Dry::Types::Array#of
  #
  # source://dry-types//lib/dry/types/array/constructor.rb#24
  def of(member); end
end

# Member arrays define their member type that is applied to each element
#
# @api public
#
# source://dry-types//lib/dry/types/array/member.rb#10
class Dry::Types::Array::Member < ::Dry::Types::Array
  # @api private
  # @option options
  # @param primitive [Class]
  # @param options [Hash]
  # @return [Member] a new instance of Member
  #
  # source://dry-types//lib/dry/types/array/member.rb#19
  def initialize(primitive, **options); end

  # @api private
  # @param input [Object]
  # @return [Array]
  #
  # source://dry-types//lib/dry/types/array/member.rb#45
  def call_safe(input); end

  # @api private
  # @param input [Object]
  # @return [Array]
  #
  # source://dry-types//lib/dry/types/array/member.rb#29
  def call_unsafe(input); end

  # @api private
  #
  # source://dry-types//lib/dry/types/array/member.rb#116
  def constructor_type; end

  # Build a lax type
  #
  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/array/member.rb#100
  def lax; end

  # @api public
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/array/member.rb#11
  def member; end

  # @api public
  # @see Nominal#to_ast
  #
  # source://dry-types//lib/dry/types/array/member.rb#107
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @param input [Array, Object]
  # @param block [#call, nil]
  # @return [Result, Logic::Result]
  # @yieldparam failure [Failure]
  # @yieldreturn [Result]
  #
  # source://dry-types//lib/dry/types/array/member.rb#73
  def try(input, &block); end
end

# Common API for building types and composition
#
#
# @api public
#
# source://dry-types//lib/dry/types/builder.rb#9
module Dry::Types::Builder
  include ::Dry::Core::Constants

  # Compose two types into an Intersection type
  #
  # @api private
  # @param other [Type]
  # @return [Intersection, Intersection::Constrained]
  #
  # source://dry-types//lib/dry/types/builder.rb#44
  def &(other); end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#153
  def <<(constructor = T.unsafe(nil), **options, &block); end

  # Compose two types into an Implication type
  #
  # @api private
  # @param other [Type]
  # @return [Implication, Implication::Constrained]
  #
  # source://dry-types//lib/dry/types/builder.rb#55
  def >(other); end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#153
  def >>(constructor = T.unsafe(nil), **options, &block); end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#153
  def append(constructor = T.unsafe(nil), **options, &block); end

  # Turn a type into a constrained type
  #
  # @api public
  # @param options [Hash] constraining rule (see {Types.Rule})
  # @return [Constrained]
  #
  # source://dry-types//lib/dry/types/builder.rb#75
  def constrained(options); end

  # @api private
  # @return [Class]
  #
  # source://dry-types//lib/dry/types/builder.rb#15
  def constrained_type; end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#153
  def constructor(constructor = T.unsafe(nil), **options, &block); end

  # @api private
  # @return [Class]
  #
  # source://dry-types//lib/dry/types/builder.rb#22
  def constructor_type; end

  # Turn a type into a type with a default value
  #
  # @api public
  # @option [Boolean]
  # @param input [Object]
  # @param block [#call, nil]
  # @param [Boolean] [Hash] a customizable set of options
  # @raise [ConstraintError]
  # @return [Default]
  #
  # source://dry-types//lib/dry/types/builder.rb#90
  def default(input = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # Define an enum on top of the existing type
  #
  # @api public
  # @param values [Array]
  # @return [Enum]
  #
  # source://dry-types//lib/dry/types/builder.rb#123
  def enum(*values); end

  # Use the given value on type mismatch
  #
  # @api public
  # @option [Boolean]
  # @param value [Object]
  # @param fallback [#call, nil]
  # @param [Boolean] [Hash] a customizable set of options
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#170
  def fallback(value = T.unsafe(nil), shared: T.unsafe(nil), &_fallback); end

  # Turn a type into a lax type that will rescue from type-errors and
  # return the original input
  #
  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/builder.rb#140
  def lax; end

  # Turn a type into an optional type
  #
  # @api public
  # @return [Sum]
  #
  # source://dry-types//lib/dry/types/builder.rb#64
  def optional; end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#153
  def prepend(constructor = T.unsafe(nil), **options, &block); end

  # Compose two types into a Sum type
  #
  # @api private
  # @param other [Type]
  # @return [Sum, Sum::Constrained]
  #
  # source://dry-types//lib/dry/types/builder.rb#33
  def |(other); end

  private

  # @api private
  #
  # source://dry-types//lib/dry/types/builder.rb#208
  def compose(other, composition_class); end
end

# Common API for building type objects in a convenient way
#
# @api public
#
# source://dry-types//lib/dry/types/builder_methods.rb#9
module Dry::Types::BuilderMethods
  # Build an array type.
  #
  # Shortcut for Array#of.
  #
  # @api public
  # @example
  #   Types::Strings = Types.Array(Types::String)
  # @param type [Dry::Types::Type]
  # @return [Dry::Types::Array]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#26
  def Array(type); end

  # Build a type with a single value
  # The equality check done with `equal?`
  #
  # @api public
  # @param object [Object]
  # @return [Dry::Types::Type]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#71
  def Constant(object); end

  # Build a constructor type
  # If no constructor block given it uses .new method
  #
  # @api public
  # @param klass [Class]
  # @param cons [#call, nil] Value constructor
  # @param block [#call, nil] Value constructor
  # @return [Dry::Types::Type]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#83
  def Constructor(klass, cons = T.unsafe(nil), &block); end

  # Build a hash schema
  #
  # @api public
  # @param type_map [Hash{Symbol => Dry::Types::Type}]
  # @return [Dry::Types::Array]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#35
  def Hash(type_map); end

  # Build a type which values are instances of a given class
  # Values are checked using `is_a?` call
  #
  # @api public
  # @example
  #   Types::Error = Types.Instance(StandardError)
  #   Types::Error = Types.Strict(StandardError)
  #   Types.Strict(Integer) == Types::Strict::Int # => true
  # @param klass [Class, Module] Class or module
  # @return [Dry::Types::Type]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#50
  def Instance(klass); end

  # Builds a constrained nominal type accepting any value that
  # responds to given methods
  #
  # @api public
  # @example
  #   Types::Callable = Types.Interface(:call)
  #   Types::Contact = Types.Interface(:name, :address)
  # @param methods [Array<String, Symbol>] Method names
  # @return [Dry::Types::Contrained]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#134
  def Interface(*methods); end

  # Build a map type
  #
  # @api public
  # @example
  #   Types::IntMap = Types.Map(Types::Strict::Integer, 'any')
  #   Types::IntStringMap = Types.Map(Types::Strict::Integer, Types::Strict::String)
  # @param key_type [Type] Key type
  # @param value_type [Type] Value type
  # @return [Dry::Types::Map]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#120
  def Map(key_type, value_type); end

  # Build a nominal type
  #
  # @api public
  # @param klass [Class]
  # @return [Dry::Types::Type]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#100
  def Nominal(klass); end

  # Build a type which values are instances of a given class
  # Values are checked using `is_a?` call
  #
  # @api public
  # @example
  #   Types::Error = Types.Instance(StandardError)
  #   Types::Error = Types.Strict(StandardError)
  #   Types.Strict(Integer) == Types::Strict::Int # => true
  # @param klass [Class, Module] Class or module
  # @return [Dry::Types::Type]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#50
  def Strict(klass); end

  # Build a type with a single value
  # The equality check done with `eql?`
  #
  # @api public
  # @param value [Object]
  # @return [Dry::Types::Type]
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#61
  def Value(value); end

  # @api private
  #
  # source://dry-types//lib/dry/types/builder_methods.rb#11
  def included(base); end
end

# All coercible types
#
# @api public
#
# source://dry-types//lib/dry/types/core.rb#41
Dry::Types::COERCIBLE = T.let(T.unsafe(nil), Hash)

# Base class for coercion errors raise by dry-types
#
# @api public
#
# source://dry-types//lib/dry/types/errors.rb#16
class Dry::Types::CoercionError < ::StandardError
  # @api private
  # @return [CoercionError] a new instance of CoercionError
  #
  # source://dry-types//lib/dry/types/errors.rb#35
  def initialize(message, meta: T.unsafe(nil), backtrace: T.unsafe(nil)); end

  # Metadata associated with the error
  #
  # @api public
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/errors.rb#32
  def meta; end

  class << self
    # @api private
    #
    # source://dry-types//lib/dry/types/errors.rb#17
    def handle(exception, meta: T.unsafe(nil)); end
  end
end

# Common coercion functions used by the built-in `Params` and `JSON` types
#
# @api public
#
# source://dry-types//lib/dry/types/coercions.rb#8
module Dry::Types::Coercions
  include ::Dry::Core::Constants

  # @api public
  # @param input [#to_str, Object]
  # @return [Date, Object]
  # @see Date.parse
  #
  # source://dry-types//lib/dry/types/coercions.rb#18
  def to_date(input, &block); end

  # @api public
  # @param input [#to_str, Object]
  # @return [DateTime, Object]
  # @see DateTime.parse
  #
  # source://dry-types//lib/dry/types/coercions.rb#41
  def to_date_time(input, &block); end

  # @api public
  # @param input [#to_sym, Object]
  # @raise CoercionError
  # @return [Symbol, Object]
  #
  # source://dry-types//lib/dry/types/coercions.rb#87
  def to_symbol(input, &block); end

  # @api public
  # @param input [#to_str, Object]
  # @return [Time, Object]
  # @see Time.parse
  #
  # source://dry-types//lib/dry/types/coercions.rb#64
  def to_time(input, &block); end

  private

  # Checks whether String is empty
  #
  # @api private
  # @param value [String, Object]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/coercions.rb#102
  def empty_str?(value); end
end

# JSON-specific coercions
#
# @api public
#
# source://dry-types//lib/dry/types/coercions/json.rb#14
module Dry::Types::Coercions::JSON
  extend ::Dry::Core::Constants
  extend ::Dry::Types::Coercions

  class << self
    # @api public
    # @param input [#to_d, Object]
    # @raise CoercionError
    # @return [BigDecimal, nil]
    #
    # source://dry-types//lib/dry/types/coercions/json.rb#41
    def to_decimal(input, &_block); end

    # @api public
    # @param input [Object]
    # @raise CoercionError
    # @return [nil] if the input is nil
    #
    # source://dry-types//lib/dry/types/coercions/json.rb#24
    def to_nil(input, &_block); end
  end
end

# Params-specific coercions
#
# @api public
#
# source://dry-types//lib/dry/types/coercions/params.rb#12
module Dry::Types::Coercions::Params
  extend ::Dry::Core::Constants
  extend ::Dry::Types::Coercions

  class << self
    # @api public
    # @param input [Array, String, Object]
    # @raise CoercionError
    # @return [Array, Object]
    #
    # source://dry-types//lib/dry/types/coercions/params.rb#135
    def to_ary(input, &_block); end

    # @api public
    # @param input [#to_d, Object]
    # @raise CoercionError
    # @return [BigDecimal, nil, Object]
    #
    # source://dry-types//lib/dry/types/coercions/params.rb#116
    def to_decimal(input, &_block); end

    # @api public
    # @param input [String, Object]
    # @raise CoercionError
    # @return [Boolean, Object]
    # @see TRUE_VALUES
    # @see FALSE_VALUES
    #
    # source://dry-types//lib/dry/types/coercions/params.rb#69
    def to_false(input, &_block); end

    # @api public
    # @param input [#to_f, Object]
    # @raise CoercionError
    # @return [Float, nil, Object]
    #
    # source://dry-types//lib/dry/types/coercions/params.rb#103
    def to_float(input, &block); end

    # @api public
    # @param input [Hash, String, Object]
    # @raise CoercionError
    # @return [Hash, Object]
    #
    # source://dry-types//lib/dry/types/coercions/params.rb#154
    def to_hash(input, &_block); end

    # @api public
    # @param input [#to_int, #to_i, Object]
    # @raise CoercionError
    # @return [Integer, nil, Object]
    #
    # source://dry-types//lib/dry/types/coercions/params.rb#86
    def to_int(input, &block); end

    # @api public
    # @param input [Object]
    # @raise CoercionError
    # @return [nil] if the input is an empty string or nil
    #
    # source://dry-types//lib/dry/types/coercions/params.rb#29
    def to_nil(input, &_block); end

    # @api public
    # @param input [String, Object]
    # @raise CoercionError
    # @return [Boolean, Object]
    # @see TRUE_VALUES
    # @see FALSE_VALUES
    #
    # source://dry-types//lib/dry/types/coercions/params.rb#49
    def to_true(input, &_block); end
  end
end

# @api public
#
# source://dry-types//lib/dry/types/coercions/params.rb#15
Dry::Types::Coercions::Params::BOOLEAN_MAP = T.let(T.unsafe(nil), Hash)

# @api public
#
# source://dry-types//lib/dry/types/coercions/params.rb#14
Dry::Types::Coercions::Params::FALSE_VALUES = T.let(T.unsafe(nil), Array)

# @api public
#
# source://dry-types//lib/dry/types/coercions/params.rb#13
Dry::Types::Coercions::Params::TRUE_VALUES = T.let(T.unsafe(nil), Array)

# @api private
#
# source://dry-types//lib/dry/types/compiler.rb#6
class Dry::Types::Compiler
  extend ::Dry::Core::Deprecations::Interface

  # @api private
  # @return [Compiler] a new instance of Compiler
  #
  # source://dry-types//lib/dry/types/compiler.rb#11
  def initialize(registry); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#15
  def call(ast); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#116
  def compile_fn(fn); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#9
  def registry; end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#19
  def visit(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#112
  def visit_any(meta); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#61
  def visit_array(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#24
  def visit_constrained(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#30
  def visit_constructor(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#102
  def visit_enum(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#67
  def visit_hash(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#82
  def visit_json_array(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#77
  def visit_json_hash(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#97
  def visit_key(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#36
  def visit_lax(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#107
  def visit_map(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#41
  def visit_nominal(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#92
  def visit_params_array(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#87
  def visit_params_hash(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#52
  def visit_rule(node); end

  # source://dry-core/1.0.1/lib/dry/core/deprecations.rb#168
  def visit_safe(*args, &block); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#72
  def visit_schema(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/compiler.rb#56
  def visit_sum(node); end
end

# source://dry-types//lib/dry/types/composition.rb#9
module Dry::Types::Composition
  include ::Dry::Types::Type
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Options
  include ::Dry::Types::Meta
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Types::Composition::Constrained

  # @api private
  # @param left [Type]
  # @param right [Type]
  # @param options [Hash]
  #
  # source://dry-types//lib/dry/types/composition.rb#46
  def initialize(left, right, **options); end

  # @api private
  # @param input [Object]
  # @raise [NotImplementedError]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/composition.rb#94
  def call_safe(input, &block); end

  # @api private
  # @param input [Object]
  # @raise [NotImplementedError]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/composition.rb#85
  def call_unsafe(input); end

  # @api public
  # @return [false]
  #
  # source://dry-types//lib/dry/types/composition.rb#69
  def constrained?; end

  # @api public
  # @return [false]
  #
  # source://dry-types//lib/dry/types/composition.rb#62
  def default?; end

  # @api private
  #
  # source://dry-types//lib/dry/types/composition.rb#116
  def failure(input, _error = T.unsafe(nil)); end

  # @return [Type]
  #
  # source://dry-types//lib/dry/types/composition.rb#18
  def left; end

  # @api public
  # @return [String]
  #
  # source://dry-types//lib/dry/types/composition.rb#55
  def name; end

  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/composition.rb#76
  def optional?; end

  # @api private
  # @param value [Object]
  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/composition.rb#130
  def primitive?(value); end

  # @return [Type]
  #
  # source://dry-types//lib/dry/types/composition.rb#21
  def right; end

  # @api private
  #
  # source://dry-types//lib/dry/types/composition.rb#106
  def success(input); end

  # @api public
  # @see Nominal#to_ast
  #
  # source://dry-types//lib/dry/types/composition.rb#137
  def to_ast(meta: T.unsafe(nil)); end

  # Wrap the type with a proc
  #
  # @api public
  # @return [Proc]
  #
  # source://dry-types//lib/dry/types/composition.rb#147
  def to_proc; end

  # @api public
  # @param input [Object]
  # @raise [NotImplementedError]
  #
  # source://dry-types//lib/dry/types/composition.rb#101
  def try(input); end

  class << self
    # @private
    #
    # source://dry-types//lib/dry/types/composition.rb#33
    def included(base); end
  end
end

# source://dry-types//lib/dry/types/composition.rb#23
module Dry::Types::Composition::Constrained
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/composition.rb#28
  def constrained?; end

  # source://dry-types//lib/dry/types/composition.rb#24
  def rule; end
end

# Constrained types apply rules to the input
#
# @api public
#
# source://dry-types//lib/dry/types/constrained.rb#8
class Dry::Types::Constrained
  include ::Dry::Types::Type
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  # @api public
  # @param type [Type]
  # @param options [Hash]
  # @return [Constrained] a new instance of Constrained
  #
  # source://dry-types//lib/dry/types/constrained.rb#23
  def initialize(type, **options); end

  # @api public
  # @param value [Object]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/constrained.rb#103
  def ===(value); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constrained.rb#44
  def call_safe(input, &block); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constrained.rb#31
  def call_unsafe(input); end

  # @api public
  # @param options [Hash] The options hash provided to {Types.Rule} and combined
  #   using {&} with previous {#rule}
  # @return [Constrained]
  # @see Dry::Logic::Operators#and
  #
  # source://dry-types//lib/dry/types/constrained.rb#87
  def constrained(options); end

  # @api public
  # @return [true]
  #
  # source://dry-types//lib/dry/types/constrained.rb#94
  def constrained?; end

  # @api private
  #
  # source://dry-types//lib/dry/types/constrained.rb#122
  def constructor_type; end

  # Build lax type. Constraints are not applicable to lax types hence unwrapping
  #
  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/constrained.rb#111
  def lax; end

  # @api public
  # @return [Dry::Logic::Rule]
  #
  # source://dry-types//lib/dry/types/constrained.rb#16
  def rule; end

  # @api public
  # @see Nominal#to_ast
  #
  # source://dry-types//lib/dry/types/constrained.rb#117
  def to_ast(meta: T.unsafe(nil)); end

  # Safe coercion attempt. It is similar to #call with a
  # block given but returns a Result instance with metadata
  # about errors (if any).
  #
  # @api public
  # @overload try
  # @overload try
  #
  # source://dry-types//lib/dry/types/constrained.rb#67
  def try(input, &block); end

  private

  # @api private
  # @param response [Object]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/constrained.rb#133
  def decorate?(response); end
end

# Common coercion-related API for constrained types
#
# @api public
#
# source://dry-types//lib/dry/types/constrained/coercible.rb#12
class Dry::Types::Constrained::Coercible < ::Dry::Types::Constrained
  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constrained/coercible.rb#27
  def call_safe(input); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constrained/coercible.rb#13
  def call_unsafe(input); end

  # @api public
  # @see Dry::Types::Constrained#try
  #
  # source://dry-types//lib/dry/types/constrained/coercible.rb#40
  def try(input, &block); end
end

# @api public
#
# source://dry-types//lib/dry/types/errors.rb#117
class Dry::Types::ConstraintError < ::Dry::Types::CoercionError
  # @api public
  # @param result [String, #to_s]
  # @param input [Object]
  # @return [ConstraintError] a new instance of ConstraintError
  #
  # source://dry-types//lib/dry/types/errors.rb#124
  def initialize(result, input); end

  # @api public
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/errors.rb#120
  def input; end

  # @api public
  # @return [String]
  #
  # source://dry-types//lib/dry/types/errors.rb#136
  def message; end

  # @api public
  # @return [String, #to_s]
  #
  # source://dry-types//lib/dry/types/errors.rb#118
  def result; end

  # @api public
  # @return [String]
  #
  # source://dry-types//lib/dry/types/errors.rb#136
  def to_s; end
end

# Constructor types apply a function to the input that is supposed to return
# a new value. Coercion is a common use case for constructor types.
#
# @api public
#
# source://dry-types//lib/dry/types/constructor.rb#9
class Dry::Types::Constructor < ::Dry::Types::Nominal
  # Instantiate a new constructor type instance
  #
  # @api private
  # @param type [Type]
  # @param fn [Function]
  # @param options [Hash]
  # @return [Constructor] a new instance of Constructor
  #
  # source://dry-types//lib/dry/types/constructor.rb#62
  def initialize(type, fn: T.unsafe(nil), **options); end

  # Build a new constructor by prepending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/constructor.rb#144
  def <<(new_fn = T.unsafe(nil), **options, &block); end

  # Build a new constructor by appending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/constructor.rb#109
  def >>(new_fn = T.unsafe(nil), **options, &block); end

  # Build a new constructor by appending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/constructor.rb#109
  def append(new_fn = T.unsafe(nil), **options, &block); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constructor.rb#72
  def call_safe(input); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constructor.rb#80
  def call_unsafe(input); end

  # @api private
  # @return [Class]
  #
  # source://dry-types//lib/dry/types/constructor.rb#124
  def constrained_type; end

  # Build a new constructor by appending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/constructor.rb#109
  def constructor(new_fn = T.unsafe(nil), **options, &block); end

  # @api public
  # @return [#call]
  #
  # source://dry-types//lib/dry/types/constructor.rb#13
  def fn; end

  # Build a lax type
  #
  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/constructor.rb#153
  def lax; end

  # Build a new constructor by prepending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/constructor.rb#144
  def prepend(new_fn = T.unsafe(nil), **options, &block); end

  # @api public
  # @see Nominal#to_ast
  #
  # source://dry-types//lib/dry/types/constructor.rb#131
  def to_ast(meta: T.unsafe(nil)); end

  # Wrap the type with a proc
  #
  # @api public
  # @return [Proc]
  #
  # source://dry-types//lib/dry/types/constructor.rb#162
  def to_proc; end

  # @api public
  # @param input [Object]
  # @param block [#call, nil]
  # @return [Logic::Result, Types::Result]
  # @return [Object] if block given and try fails
  #
  # source://dry-types//lib/dry/types/constructor.rb#91
  def try(input, &block); end

  # @api public
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/constructor.rb#16
  def type; end

  private

  # Delegates missing methods to {#type}
  #
  # @api private
  # @param method [Symbol]
  # @param args [Array]
  # @param block [#call, nil]
  #
  # source://dry-types//lib/dry/types/constructor.rb#184
  def method_missing(method, *args, &block); end

  # @api private
  # @param meth [Symbol]
  # @param include_private [Boolean]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/constructor.rb#173
  def respond_to_missing?(meth, include_private = T.unsafe(nil)); end

  class << self
    # @api public
    # @param input [Builder, Object]
    # @param options [Hash]
    # @param block [#call, nil]
    #
    # source://dry-types//lib/dry/types/constructor.rb#35
    def [](type, fn:, **options); end

    # @api public
    # @param input [Builder, Object]
    # @param options [Hash]
    # @param block [#call, nil]
    #
    # source://dry-types//lib/dry/types/constructor.rb#25
    def new(input, fn: T.unsafe(nil), **options, &block); end

    # @api private
    #
    # source://dry-types//lib/dry/types/constructor.rb#46
    def wrapper_type; end
  end
end

# Function is used internally by Constructor types
#
# @api private
#
# source://dry-types//lib/dry/types/constructor/function.rb#11
class Dry::Types::Constructor::Function
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @return [Function] a new instance of Function
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#173
  def initialize(fn); end

  # @api private
  # @return [Function]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#208
  def <<(other); end

  # @api private
  # @return [Function]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#202
  def >>(other); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#178
  def [](input, &block); end

  # @api private
  # @return [Integer]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#184
  def arity; end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#178
  def call(input, &block); end

  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#171
  def fn; end

  # @api private
  # @return [Array]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#193
  def to_ast; end

  # @api private
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#188
  def wrapper?; end

  class << self
    # Choose or build specialized invokation code for a callable
    #
    # @api private
    # @param fn [#call]
    # @raise [::ArgumentError]
    # @return [Function]
    #
    # source://dry-types//lib/dry/types/constructor/function.rb#141
    def [](fn); end

    # @api private
    # @return [Boolean]
    #
    # source://dry-types//lib/dry/types/constructor/function.rb#158
    def yields_block?(fn); end
  end
end

# Coercion via a method call on a known object
#
# @api private
#
# source://dry-types//lib/dry/types/constructor/function.rb#26
class Dry::Types::Constructor::Function::MethodCall < ::Dry::Types::Constructor::Function
  # @api private
  # @return [MethodCall] a new instance of MethodCall
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#112
  def initialize(fn); end

  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#110
  def name; end

  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#110
  def target; end

  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#118
  def to_ast; end

  class << self
    # @api private
    # @return [MethodCall]
    #
    # source://dry-types//lib/dry/types/constructor/function.rb#105
    def [](fn, safe); end

    # Choose or build the base class
    #
    # @api private
    # @return [Function]
    #
    # source://dry-types//lib/dry/types/constructor/function.rb#32
    def call_class(method, public, safe); end
  end
end

# Coercion via a private method call
#
# @api private
#
# source://dry-types//lib/dry/types/constructor/function.rb#85
class Dry::Types::Constructor::Function::MethodCall::PrivateCall < ::Dry::Types::Constructor::Function::MethodCall
  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#86
  def call(input, &block); end
end

# Coercion via an unsafe private method call
#
# @api private
#
# source://dry-types//lib/dry/types/constructor/function.rb#94
class Dry::Types::Constructor::Function::MethodCall::PrivateSafeCall < ::Dry::Types::Constructor::Function::MethodCall::PrivateCall
  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#95
  def call(input, &block); end
end

# Coercion with a publicly accessible method call
#
# @api private
#
# source://dry-types//lib/dry/types/constructor/function.rb#53
class Dry::Types::Constructor::Function::MethodCall::PublicCall < ::Dry::Types::Constructor::Function::MethodCall
  class << self
    # Choose or build the interface
    #
    # @api private
    # @return [::Module]
    #
    # source://dry-types//lib/dry/types/constructor/function.rb#59
    def call_interface(method, safe); end
  end
end

# Wrapper for unsafe coercion functions
#
# @api private
#
# source://dry-types//lib/dry/types/constructor/function.rb#15
class Dry::Types::Constructor::Function::Safe < ::Dry::Types::Constructor::Function
  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#16
  def call(input, &block); end
end

# @api private
#
# source://dry-types//lib/dry/types/constructor/function.rb#124
class Dry::Types::Constructor::Function::Wrapper < ::Dry::Types::Constructor::Function
  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#125
  def [](input, type, &block); end

  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#132
  def arity; end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constructor/function.rb#125
  def call(input, type, &block); end
end

# @api public
#
# source://dry-types//lib/dry/types/constructor/wrapper.rb#7
module Dry::Types::Constructor::Wrapper
  # Build a new constructor by prepending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/constructor/wrapper.rb#60
  def <<(new_fn = T.unsafe(nil), **options, &block); end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#153
  def >>(constructor = T.unsafe(nil), **options, &block); end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#153
  def append(constructor = T.unsafe(nil), **options, &block); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constructor/wrapper.rb#11
  def call_safe(input, &block); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/constructor/wrapper.rb#18
  def call_unsafe(input); end

  # Define a constructor for the type
  #
  # @api public
  # @param constructor [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/builder.rb#153
  def constructor(constructor = T.unsafe(nil), **options, &block); end

  # @api public
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/constructor/wrapper.rb#77
  def lax; end

  # Build a new constructor by prepending a block to the coercion function
  #
  # @api public
  # @param new_fn [#call, nil]
  # @param options [Hash]
  # @param block [#call, nil]
  # @return [Constructor]
  #
  # source://dry-types//lib/dry/types/constructor/wrapper.rb#60
  def prepend(new_fn = T.unsafe(nil), **options, &block); end

  # @api public
  # @param input [Object]
  # @param block [#call, nil]
  # @return [Logic::Result, Types::Result]
  # @return [Object] if block given and try fails
  #
  # source://dry-types//lib/dry/types/constructor/wrapper.rb#29
  def try(input, &block); end

  private

  # Replace underlying type
  #
  # @api private
  #
  # source://dry-types//lib/dry/types/constructor/wrapper.rb#88
  def __new__(type); end
end

# Internal container for the built-in types
#
# @api private
#
# source://dry-types//lib/dry/types/container.rb#8
class Dry::Types::Container
  include ::Dry::Core::Container::Mixin::Initializer
  include ::Dry::Core::Container::Mixin
  extend ::Dry::Core::Container::Configuration
  extend ::Dry::Core::Constants
  extend ::Dry::Configurable
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods

  # source://dry-core/1.0.1/lib/dry/core/container/mixin.rb#83
  def config; end
end

# Common API for types
#
# @api public
#
# source://dry-types//lib/dry/types/decorator.rb#8
module Dry::Types::Decorator
  include ::Dry::Types::Options

  # @api public
  # @param type [Type]
  #
  # source://dry-types//lib/dry/types/decorator.rb#15
  def initialize(type, *_arg1, **_arg2); end

  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/decorator.rb#41
  def constrained?; end

  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/decorator.rb#34
  def default?; end

  # Wrap the type with a proc
  #
  # @api public
  # @return [Proc]
  #
  # source://dry-types//lib/dry/types/decorator.rb#60
  def to_proc; end

  # @api public
  # @param input [Object]
  # @param block [#call, nil]
  # @return [Result, Logic::Result]
  # @return [Object] if block given and try fails
  #
  # source://dry-types//lib/dry/types/decorator.rb#27
  def try(input, &block); end

  # @api public
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/decorator.rb#12
  def type; end

  private

  # Replace underlying type
  #
  # @api private
  #
  # source://dry-types//lib/dry/types/decorator.rb#100
  def __new__(type); end

  # @api private
  # @param response [Object]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/decorator.rb#71
  def decorate?(response); end

  # Delegates missing methods to {#type}
  #
  # @api private
  # @param meth [Symbol]
  # @param args [Array]
  # @param block [#call, nil]
  #
  # source://dry-types//lib/dry/types/decorator.rb#82
  def method_missing(meth, *args, **_arg2, &block); end

  # @api public
  # @param meth [Symbol]
  # @param include_private [Boolean]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/decorator.rb#51
  def respond_to_missing?(meth, include_private = T.unsafe(nil)); end
end

# Default types are useful when a missing value should be replaced by a default one
#
# @api public
#
# source://dry-types//lib/dry/types/default.rb#8
class Dry::Types::Default
  include ::Dry::Types::Type
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @param type [Type]
  # @param value [Object]
  # @return [Default] a new instance of Default
  #
  # source://dry-types//lib/dry/types/default.rb#53
  def initialize(type, value, **_arg2); end

  # @api private
  # @param input [Object]
  # @return [Object] value passed through {#type} or {#default} value
  #
  # source://dry-types//lib/dry/types/default.rb#110
  def call_safe(input = T.unsafe(nil), &block); end

  # @api private
  # @param input [Object]
  # @return [Object] value passed through {#type} or {#default} value
  #
  # source://dry-types//lib/dry/types/default.rb#97
  def call_unsafe(input = T.unsafe(nil)); end

  # @api private
  # @return [false]
  #
  # source://dry-types//lib/dry/types/default.rb#121
  def callable?; end

  # Build a constrained type
  #
  # @api public
  # @param args [Array] see {Dry::Types::Builder#constrained}
  # @return [Default]
  #
  # source://dry-types//lib/dry/types/default.rb#65
  def constrained(*_arg0, **_arg1, &_arg2); end

  # @api public
  # @return [true]
  #
  # source://dry-types//lib/dry/types/default.rb#72
  def default?; end

  # @api public
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/default.rb#32
  def evaluate; end

  # @api public
  # @param input [Object]
  # @return [Result::Success]
  #
  # source://dry-types//lib/dry/types/default.rb#81
  def try(input); end

  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/default.rb#88
  def valid?(value = T.unsafe(nil)); end

  # @api public
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/default.rb#32
  def value; end

  class << self
    # @api private
    # @param value [Object, #call]
    # @return [Class] {Default} or {Default::Callable}
    #
    # source://dry-types//lib/dry/types/default.rb#41
    def [](value); end
  end
end

# @api private
#
# source://dry-types//lib/dry/types/default.rb#10
class Dry::Types::Default::Callable < ::Dry::Types::Default
  # @api private
  # @return [true]
  #
  # source://dry-types//lib/dry/types/default.rb#20
  def callable?; end

  # Evaluates given callable
  #
  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/default.rb#15
  def evaluate; end
end

# @api public
Dry::Types::Definition = Dry::Types::Nominal

# Enum types can be used to define an enum on top of an existing type
#
# @api public
#
# source://dry-types//lib/dry/types/enum.rb#8
class Dry::Types::Enum
  include ::Dry::Types::Type
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder

  # @api private
  # @option options
  # @param type [Type]
  # @param options [Hash]
  # @return [Enum] a new instance of Enum
  #
  # source://dry-types//lib/dry/types/enum.rb#28
  def initialize(type, **options); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/enum.rb#46
  def call_safe(input, &block); end

  # @api private
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/enum.rb#39
  def call_unsafe(input); end

  # @api private
  #
  # source://dry-types//lib/dry/types/enum.rb#58
  def default(*_arg0); end

  # Check whether a value is in the enum
  #
  # @api public
  #
  # source://dry-types//lib/dry/types/type.rb#18
  def include?(input = T.unsafe(nil)); end

  # @api public
  # @return [String]
  #
  # source://dry-types//lib/dry/types/enum.rb#76
  def inspect; end

  # @api public
  # @return [Hash]
  #
  # source://dry-types//lib/dry/types/enum.rb#21
  def inverted_mapping; end

  # @api public
  # @return [Hash]
  #
  # source://dry-types//lib/dry/types/enum.rb#18
  def mapping; end

  # @api public
  # @see Nominal#to_ast
  #
  # source://dry-types//lib/dry/types/enum.rb#69
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @return [String]
  #
  # source://dry-types//lib/dry/types/enum.rb#76
  def to_s; end

  # @api public
  # @see Dry::Types::Constrained#try
  #
  # source://dry-types//lib/dry/types/enum.rb#53
  def try(input); end

  # @api public
  # @return [Array]
  #
  # source://dry-types//lib/dry/types/enum.rb#15
  def values; end

  private

  # Maps a value
  #
  # @api private
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/enum.rb#90
  def map_value(input); end
end

# Internal container for constructor functions used by the built-in types
#
# @api private
#
# source://dry-types//lib/dry/types/fn_container.rb#8
class Dry::Types::FnContainer
  class << self
    # @api private
    #
    # source://dry-types//lib/dry/types/fn_container.rb#23
    def [](fn_name); end

    # @api private
    #
    # source://dry-types//lib/dry/types/fn_container.rb#10
    def container; end

    # @api private
    #
    # source://dry-types//lib/dry/types/fn_container.rb#15
    def register(function = T.unsafe(nil), &block); end

    # @api private
    #
    # source://dry-types//lib/dry/types/fn_container.rb#32
    def register_name(function); end
  end
end

# Hash types can be used to define maps and schemas
#
# @api public
#
# source://dry-types//lib/dry/types/hash.rb#8
class Dry::Types::Hash < ::Dry::Types::Nominal
  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#77
  def constructor_type; end

  # Build a map type
  #
  # @api public
  # @param key_type [Type]
  # @param value_type [Type]
  # @return [Map]
  #
  # source://dry-types//lib/dry/types/hash.rb#40
  def map(key_type, value_type); end

  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#50
  def permissive(*_arg0); end

  # @api public
  # @overload schema
  # @overload schema
  #
  # source://dry-types//lib/dry/types/hash.rb#22
  def schema(keys_or_map, meta = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#50
  def strict(*_arg0); end

  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#50
  def strict_with_defaults(*_arg0); end

  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#50
  def symbolized(*_arg0); end

  # @api public
  # @param meta [Boolean] Whether to dump the meta to the AST
  # @return [Array] An AST representation
  #
  # source://dry-types//lib/dry/types/hash.rb#95
  def to_ast(meta: T.unsafe(nil)); end

  # Whether the type transforms types of schemas created by {Dry::Types::Hash#schema}
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/hash.rb#86
  def transform_types?; end

  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#50
  def weak(*_arg0); end

  # Injects a type transformation function for building schemas
  #
  # @api public
  # @param proc [#call, nil]
  # @param block [#call, nil]
  # @raise [ArgumentError]
  # @return [Hash]
  #
  # source://dry-types//lib/dry/types/hash.rb#67
  def with_type_transform(proc = T.unsafe(nil), &block); end

  private

  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#102
  def build_keys(type_map); end

  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#123
  def key_name(key); end

  # @api private
  #
  # source://dry-types//lib/dry/types/hash.rb#114
  def resolve_type(type); end
end

# @api public
#
# source://dry-types//lib/dry/types/hash/constructor.rb#10
class Dry::Types::Hash::Constructor < ::Dry::Types::Constructor
  # @api private
  #
  # source://dry-types//lib/dry/types/hash/constructor.rb#11
  def constructor_type; end

  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/hash/constructor.rb#18
  def lax; end

  # @api public
  # @see Dry::Types::Array#of
  #
  # source://dry-types//lib/dry/types/hash/constructor.rb#25
  def schema(*_arg0, **_arg1, &_arg2); end
end

# @api public
#
# source://dry-types//lib/dry/types/hash.rb#9
Dry::Types::Hash::NOT_REQUIRED = T.let(T.unsafe(nil), Hash)

# Implication type
#
# @api public
#
# source://dry-types//lib/dry/types/implication.rb#8
class Dry::Types::Implication
  include ::Dry::Types::Type
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Options
  include ::Dry::Types::Meta
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Types::Composition

  # @api private
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/implication.rb#33
  def call_safe(input, &block); end

  # @api private
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/implication.rb#20
  def call_unsafe(input); end

  # @api private
  # @param value [Object]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/implication.rb#57
  def primitive?(value); end

  # @api public
  # @param input [Object]
  #
  # source://dry-types//lib/dry/types/implication.rb#44
  def try(input); end

  class << self
    # source://dry-types//lib/dry/types/composition.rb#36
    def ast_type; end

    # source://dry-types//lib/dry/types/composition.rb#37
    def composition_name; end

    # @api public
    #
    # source://dry-types//lib/dry/types/implication.rb#11
    def operator; end
  end
end

# source://dry-types//lib/dry/types/implication.rb#0
class Dry::Types::Implication::Constrained < ::Dry::Types::Implication
  include ::Dry::Types::Composition::Constrained
end

# @api public
#
# source://dry-types//lib/dry/types/inflector.rb#7
Dry::Types::Inflector = T.let(T.unsafe(nil), Dry::Inflector)

# Intersection type
#
# @api public
#
# source://dry-types//lib/dry/types/intersection.rb#12
class Dry::Types::Intersection
  include ::Dry::Types::Type
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Options
  include ::Dry::Types::Meta
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Types::Composition

  # @api private
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/intersection.rb#33
  def call_safe(input, &block); end

  # @api private
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/intersection.rb#24
  def call_unsafe(input); end

  # @api private
  # @param value [Object]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/intersection.rb#55
  def primitive?(value); end

  # @api public
  # @param input [Object]
  #
  # source://dry-types//lib/dry/types/intersection.rb#40
  def try(input); end

  private

  # @api private
  #
  # source://dry-types//lib/dry/types/intersection.rb#94
  def merge_results(left_result, right_result); end

  # @api private
  #
  # source://dry-types//lib/dry/types/intersection.rb#76
  def try_side(side, input); end

  # @api private
  #
  # source://dry-types//lib/dry/types/intersection.rb#62
  def try_sides(input, &block); end

  class << self
    # source://dry-types//lib/dry/types/composition.rb#36
    def ast_type; end

    # source://dry-types//lib/dry/types/composition.rb#37
    def composition_name; end

    # @api public
    #
    # source://dry-types//lib/dry/types/intersection.rb#15
    def operator; end
  end
end

# source://dry-types//lib/dry/types/intersection.rb#0
class Dry::Types::Intersection::Constrained < ::Dry::Types::Intersection
  include ::Dry::Types::Composition::Constrained
end

# Primitives with {Kernel} coercion methods
#
# @api public
#
# source://dry-types//lib/dry/types/core.rb#6
Dry::Types::KERNEL_COERCIBLE = T.let(T.unsafe(nil), Hash)

# Lax types rescue from type-related errors when constructors fail
#
# @api public
#
# source://dry-types//lib/dry/types/lax.rb#8
class Dry::Types::Lax
  include ::Dry::Types::Type
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  # @api public
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/lax.rb#22
  def [](input); end

  # @api public
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/lax.rb#22
  def call(input); end

  # @api public
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/lax.rb#22
  def call_safe(input); end

  # @api public
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/lax.rb#22
  def call_unsafe(input); end

  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/lax.rb#52
  def lax; end

  # @api public
  # @see Nominal#to_ast
  #
  # source://dry-types//lib/dry/types/lax.rb#45
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @param input [Object]
  # @param block [#call, nil]
  # @return [Result, Logic::Result]
  # @yieldparam failure [Failure]
  # @yieldreturn [Result]
  #
  # source://dry-types//lib/dry/types/lax.rb#38
  def try(input, &block); end

  private

  # @api private
  # @param response [Object, Dry::Types::Constructor]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/lax.rb#63
  def decorate?(response); end
end

# Primitives with coercions through by convention `to_*` methods
#
# @api public
#
# source://dry-types//lib/dry/types/core.rb#16
Dry::Types::METHOD_COERCIBLE = T.let(T.unsafe(nil), Hash)

# By convention methods to coerce {METHOD_COERCIBLE} primitives
#
# @api public
#
# source://dry-types//lib/dry/types/core.rb#21
Dry::Types::METHOD_COERCIBLE_METHODS = T.let(T.unsafe(nil), Hash)

# Homogeneous mapping. It describes a hash with unknown keys that match a certain type.
#
# @api public
# @example
#   type = Dry::Types['hash'].map(
#   Dry::Types['integer'].constrained(gteq: 1, lteq: 10),
#   Dry::Types['string']
#   )
#
#   type.(1 => 'right')
#   # => {1 => 'right'}
#
#   type.('1' => 'wrong')
#   # Dry::Types::MapError: "1" violates constraints (type?(Integer, "1")
#   #                                                 AND gteq?(1, "1")
#   #                                                 AND lteq?(10, "1") failed)
#
#   type.(11 => 'wrong')
#   # Dry::Types::MapError: 11 violates constraints (lteq?(10, 11) failed)
#
# source://dry-types//lib/dry/types/map.rb#25
class Dry::Types::Map < ::Dry::Types::Nominal
  # @api public
  # @return [Map] a new instance of Map
  #
  # source://dry-types//lib/dry/types/map.rb#26
  def initialize(primitive, key_type: T.unsafe(nil), value_type: T.unsafe(nil), meta: T.unsafe(nil)); end

  # @api private
  # @param hash [Hash]
  # @return [Hash]
  #
  # source://dry-types//lib/dry/types/map.rb#67
  def call_safe(hash); end

  # @api private
  # @param hash [Hash]
  # @return [Hash]
  #
  # source://dry-types//lib/dry/types/map.rb#56
  def call_unsafe(hash); end

  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/map.rb#98
  def constrained?; end

  # @api public
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/map.rb#33
  def key_type; end

  # @api public
  # @return [String]
  #
  # source://dry-types//lib/dry/types/map.rb#47
  def name; end

  # @api public
  # @param meta [Boolean] Whether to dump the meta to the AST
  # @return [Array] An AST representation
  #
  # source://dry-types//lib/dry/types/map.rb#88
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @param hash [Hash]
  # @return [Result]
  # @yield [result]
  #
  # source://dry-types//lib/dry/types/map.rb#76
  def try(hash); end

  # @api public
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/map.rb#40
  def value_type; end

  private

  # @api private
  #
  # source://dry-types//lib/dry/types/map.rb#107
  def coerce(input); end
end

# @api public
#
# source://dry-types//lib/dry/types/errors.rb#89
class Dry::Types::MapError < ::Dry::Types::CoercionError; end

# Storage for meta-data
#
# @api public
#
# source://dry-types//lib/dry/types/meta.rb#8
module Dry::Types::Meta
  # @api public
  #
  # source://dry-types//lib/dry/types/meta.rb#9
  def initialize(*args, meta: T.unsafe(nil), **options); end

  # @api public
  # @overload meta
  # @overload meta
  #
  # source://dry-types//lib/dry/types/meta.rb#31
  def meta(data = T.unsafe(nil)); end

  # Resets meta
  #
  # @api public
  # @return [Dry::Types::Type]
  #
  # source://dry-types//lib/dry/types/meta.rb#46
  def pristine; end

  # @api public
  # @param options [Hash] new_options
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/meta.rb#19
  def with(**options); end
end

# @api public
#
# source://dry-types//lib/dry/types/errors.rb#95
class Dry::Types::MissingKeyError < ::Dry::Types::SchemaKeyError
  # @api public
  # @param key [String, Symbol]
  # @return [MissingKeyError] a new instance of MissingKeyError
  #
  # source://dry-types//lib/dry/types/errors.rb#99
  def initialize(key); end

  # @api public
  # @return [Symbol]
  #
  # source://dry-types//lib/dry/types/errors.rb#96
  def key; end
end

# Export types registered in a container as module constants.
#
# @api public
# @example
#   module Types
#   include Dry.Types(:strict, :coercible, :nominal, default: :strict)
#   end
#
#   Types.constants
#   # => [:Class, :Strict, :Symbol, :Integer, :Float, :String, :Array, :Hash,
#   #     :Decimal, :Nil, :True, :False, :Bool, :Date, :Nominal, :DateTime, :Range,
#   #     :Coercible, :Time]
#
# source://dry-types//lib/dry/types/module.rb#19
class Dry::Types::Module < ::Module
  # @api public
  # @return [Module] a new instance of Module
  #
  # source://dry-types//lib/dry/types/module.rb#20
  def initialize(registry, *args, **kwargs); end

  # @api private
  #
  # source://dry-types//lib/dry/types/module.rb#76
  def registry_tree; end

  # @api private
  #
  # source://dry-types//lib/dry/types/module.rb#43
  def type_constants(*namespaces, default: T.unsafe(nil), **aliases); end

  private

  # @api private
  #
  # source://dry-types//lib/dry/types/module.rb#91
  def check_parameters(*namespaces, default: T.unsafe(nil), **aliases); end

  # @api private
  #
  # source://dry-types//lib/dry/types/module.rb#111
  def define_constants(constants, mod = T.unsafe(nil)); end
end

# Collection of multiple errors
#
# @api public
#
# source://dry-types//lib/dry/types/errors.rb#49
class Dry::Types::MultipleError < ::Dry::Types::CoercionError
  # @api public
  # @param errors [Array<CoercionError>]
  # @return [MultipleError] a new instance of MultipleError
  #
  # source://dry-types//lib/dry/types/errors.rb#53
  def initialize(errors); end

  # @api public
  # @return [Array<CoercionError>]
  #
  # source://dry-types//lib/dry/types/errors.rb#50
  def errors; end

  # @api public
  # @return string
  #
  # source://dry-types//lib/dry/types/errors.rb#59
  def message; end

  # @api public
  # @return [Array]
  #
  # source://dry-types//lib/dry/types/errors.rb#64
  def meta; end
end

# Primitives that are non-coercible
#
# @api public
#
# source://dry-types//lib/dry/types/core.rb#26
Dry::Types::NON_COERCIBLE = T.let(T.unsafe(nil), Hash)

# All built-in primitives except {NilClass}
#
# @api public
#
# source://dry-types//lib/dry/types/core.rb#44
Dry::Types::NON_NIL = T.let(T.unsafe(nil), Hash)

# Nominal types define a primitive class and do not apply any constructors or constraints
#
# Use these types for annotations and the base for building more complex types on top of them.
#
# @api public
#
# source://dry-types//lib/dry/types/nominal.rb#10
class Dry::Types::Nominal
  include ::Dry::Types::Type
  include ::Dry::Types::Options
  include ::Dry::Types::Meta
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @param primitive [Type, Class]
  # @param options [Hash]
  # @return [Nominal] a new instance of Nominal
  #
  # source://dry-types//lib/dry/types/nominal.rb#42
  def initialize(primitive, **options); end

  # @api private
  # @param input [BasicObject]
  # @return [BasicObject]
  #
  # source://dry-types//lib/dry/types/nominal.rb#90
  def call_safe(input); end

  # @api private
  # @param input [BasicObject]
  # @return [BasicObject]
  #
  # source://dry-types//lib/dry/types/nominal.rb#81
  def call_unsafe(input); end

  # @api private
  #
  # source://dry-types//lib/dry/types/nominal.rb#139
  def coerce(input, &_block); end

  # @api public
  # @return [false]
  #
  # source://dry-types//lib/dry/types/nominal.rb#65
  def constrained?; end

  # @api public
  # @return [false]
  #
  # source://dry-types//lib/dry/types/nominal.rb#58
  def default?; end

  # @api public
  # @raise [ArgumentError]
  # @return [Result::Failure]
  #
  # source://dry-types//lib/dry/types/nominal.rb#121
  def failure(input, error); end

  # Return self. Nominal types are lax by definition
  #
  # @api public
  # @return [Nominal]
  #
  # source://dry-types//lib/dry/types/nominal.rb#181
  def lax; end

  # @api public
  # @return [String]
  #
  # source://dry-types//lib/dry/types/nominal.rb#51
  def name; end

  # @api public
  # @return [false]
  #
  # source://dry-types//lib/dry/types/nominal.rb#72
  def optional?; end

  # @api public
  # @return [Class]
  #
  # source://dry-types//lib/dry/types/nominal.rb#19
  def primitive; end

  # Checks whether value is of a #primitive class
  #
  # @api public
  # @param value [Object]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/nominal.rb#134
  def primitive?(value); end

  # @api public
  # @return [Result::Success]
  #
  # source://dry-types//lib/dry/types/nominal.rb#112
  def success(input); end

  # Return AST representation of a type nominal
  #
  # @api public
  # @return [Array]
  #
  # source://dry-types//lib/dry/types/nominal.rb#172
  def to_ast(meta: T.unsafe(nil)); end

  # Wrap the type with a proc
  #
  # @api public
  # @return [Proc]
  #
  # source://dry-types//lib/dry/types/nominal.rb#190
  def to_proc; end

  # @api public
  # @param input [Object]
  # @return [Result, Logic::Result] when a block is not provided
  # @return [nil] otherwise
  # @yieldparam failure [Failure]
  # @yieldreturn [Result]
  #
  # source://dry-types//lib/dry/types/nominal.rb#103
  def try(input); end

  # @api private
  #
  # source://dry-types//lib/dry/types/nominal.rb#150
  def try_coerce(input); end

  class << self
    # @api private
    # @param primitive [Class]
    # @return [Type]
    #
    # source://dry-types//lib/dry/types/nominal.rb#26
    def [](primitive); end
  end
end

# @api public
#
# source://dry-types//lib/dry/types/nominal.rb#36
Dry::Types::Nominal::ALWAYS = T.let(T.unsafe(nil), Proc)

# Common API for types with options
#
# @api private
#
# source://dry-types//lib/dry/types/options.rb#8
module Dry::Types::Options
  # @api private
  # @see Nominal#initialize
  #
  # source://dry-types//lib/dry/types/options.rb#15
  def initialize(*args, **options); end

  # @api private
  # @return [Hash]
  #
  # source://dry-types//lib/dry/types/options.rb#10
  def options; end

  # @api private
  # @param new_options [Hash]
  # @return [Type]
  #
  # source://dry-types//lib/dry/types/options.rb#25
  def with(**new_options); end
end

# source://dry-types//lib/dry/types/printer.rb#296
Dry::Types::PRINTER = T.let(T.unsafe(nil), Dry::Types::Printer)

# PredicateInferrer returns the list of predicates used by a type.
#
# @api public
#
# source://dry-types//lib/dry/types/predicate_inferrer.rb#8
class Dry::Types::PredicateInferrer
  include ::Dry::Core::Cache::Methods
  extend ::Dry::Core::Cache

  # @api private
  # @return [PredicateInferrer] a new instance of PredicateInferrer
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#214
  def initialize(registry = T.unsafe(nil)); end

  # Infer predicate identifier from the provided type
  #
  # @api private
  # @param type [Type]
  # @return [Symbol]
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#224
  def [](type); end

  # @api private
  # @return [Compiler]
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#211
  def compiler; end
end

# @api public
#
# source://dry-types//lib/dry/types/predicate_inferrer.rb#31
Dry::Types::PredicateInferrer::ARRAY = T.let(T.unsafe(nil), Array)

# Compiler reduces type AST into a list of predicates
#
# @api private
#
# source://dry-types//lib/dry/types/predicate_inferrer.rb#38
class Dry::Types::PredicateInferrer::Compiler
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes

  # @api private
  # @return [Compiler] a new instance of Compiler
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#49
  def initialize(registry); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#54
  def infer_predicate(type); end

  # @api private
  # @return [PredicateRegistry]
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#46
  def registry; end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#89
  def visit(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#165
  def visit_and(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#160
  def visit_any(_); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#113
  def visit_array(_); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#148
  def visit_constrained(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#123
  def visit_constructor(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#129
  def visit_enum(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#107
  def visit_hash(_); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#118
  def visit_lax(node); end

  # @api private
  # @raise [NotImplementedError]
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#189
  def visit_map(_node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#95
  def visit_nominal(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#171
  def visit_predicate(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#107
  def visit_schema(_); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#135
  def visit_sum(node); end

  private

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_inferrer.rb#196
  def merge_predicates(nodes); end
end

# @api public
#
# source://dry-types//lib/dry/types/predicate_inferrer.rb#29
Dry::Types::PredicateInferrer::HASH = T.let(T.unsafe(nil), Array)

# @api public
#
# source://dry-types//lib/dry/types/predicate_inferrer.rb#33
Dry::Types::PredicateInferrer::NIL = T.let(T.unsafe(nil), Array)

# @api public
#
# source://dry-types//lib/dry/types/predicate_inferrer.rb#25
Dry::Types::PredicateInferrer::REDUCED_TYPES = T.let(T.unsafe(nil), Hash)

# @api public
#
# source://dry-types//lib/dry/types/predicate_inferrer.rb#11
Dry::Types::PredicateInferrer::TYPE_TO_PREDICATE = T.let(T.unsafe(nil), Hash)

# A registry with predicate objects from `Dry::Logic::Predicates`
#
# @api private
#
# source://dry-types//lib/dry/types/predicate_registry.rb#8
class Dry::Types::PredicateRegistry
  # @api private
  # @return [PredicateRegistry] a new instance of PredicateRegistry
  #
  # source://dry-types//lib/dry/types/predicate_registry.rb#19
  def initialize(predicates = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_registry.rb#29
  def [](name); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_registry.rb#13
  def has_predicate; end

  # @api private
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/predicate_registry.rb#24
  def key?(name); end

  # @api private
  #
  # source://dry-types//lib/dry/types/predicate_registry.rb#10
  def predicates; end
end

# @api private
#
# source://dry-types//lib/dry/types/predicate_registry.rb#15
Dry::Types::PredicateRegistry::KERNEL_RESPOND_TO = T.let(T.unsafe(nil), UnboundMethod)

# PrimitiveInferrer returns the list of classes matching a type.
#
# @api public
#
# source://dry-types//lib/dry/types/primitive_inferrer.rb#8
class Dry::Types::PrimitiveInferrer
  include ::Dry::Core::Cache::Methods
  extend ::Dry::Core::Cache

  # @api private
  # @return [PrimitiveInferrer] a new instance of PrimitiveInferrer
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#79
  def initialize; end

  # Infer primitives from the provided type
  #
  # @api private
  # @return [Array[Class]]
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#88
  def [](type); end

  # @api private
  # @return [Compiler]
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#76
  def compiler; end
end

# Compiler reduces type AST into a list of primitives
#
# @api private
#
# source://dry-types//lib/dry/types/primitive_inferrer.rb#14
class Dry::Types::PrimitiveInferrer::Compiler
  # @api private
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#16
  def visit(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#69
  def visit_any(_); end

  # @api private
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#34
  def visit_array(_); end

  # @api private
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#63
  def visit_constrained(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#44
  def visit_constructor(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#50
  def visit_enum(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#28
  def visit_hash(_); end

  # @api private
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#39
  def visit_lax(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#22
  def visit_nominal(node); end

  # @api private
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#28
  def visit_schema(_); end

  # @api private
  #
  # source://dry-types//lib/dry/types/primitive_inferrer.rb#56
  def visit_sum(node); end
end

# @api private
#
# source://dry-types//lib/dry/types/printable.rb#6
module Dry::Types::Printable
  # @api private
  # @return [String]
  #
  # source://dry-types//lib/dry/types/printable.rb#10
  def inspect; end

  # @api private
  # @return [String]
  #
  # source://dry-types//lib/dry/types/printable.rb#10
  def to_s; end
end

# @api private
#
# source://dry-types//lib/dry/types/printer/composition.rb#6
class Dry::Types::Printer
  # @api private
  # @return [Printer] a new instance of Printer
  #
  # source://dry-types//lib/dry/types/printer.rb#38
  def initialize; end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#43
  def call(type); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#49
  def visit(type, &block); end

  # @api private
  # @yield ["Any"]
  #
  # source://dry-types//lib/dry/types/printer.rb#62
  def visit_any(_); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#66
  def visit_array(type); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#72
  def visit_array_member(array); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#155
  def visit_callable(callable); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#104
  def visit_composition(composition, &block); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#93
  def visit_constrained(constrained); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#80
  def visit_constructor(constructor); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#129
  def visit_default(default); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#110
  def visit_enum(enum); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#253
  def visit_hash(hash); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#243
  def visit_key(key); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#149
  def visit_lax(lax); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#229
  def visit_map(map); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#143
  def visit_nominal(type); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#272
  def visit_options(options, meta = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer.rb#190
  def visit_schema(schema); end
end

# @api private
#
# source://dry-types//lib/dry/types/printer/composition.rb#8
class Dry::Types::Printer::Composition
  # @api private
  # @return [Composition] a new instance of Composition
  #
  # source://dry-types//lib/dry/types/printer/composition.rb#9
  def initialize(printer, composition_class); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer/composition.rb#15
  def visit(composition); end

  private

  # @api private
  #
  # source://dry-types//lib/dry/types/printer/composition.rb#33
  def visit_constructor(type, &block); end

  # @api private
  #
  # source://dry-types//lib/dry/types/printer/composition.rb#25
  def visit_constructors(composition); end
end

# @api private
#
# source://dry-types//lib/dry/types/printer.rb#11
Dry::Types::Printer::MAPPING = T.let(T.unsafe(nil), Hash)

# Result class used by {Type#try}
#
# @api public
#
# source://dry-types//lib/dry/types/result.rb#8
class Dry::Types::Result
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @param input [Object]
  # @return [Result] a new instance of Result
  #
  # source://dry-types//lib/dry/types/result.rb#17
  def initialize(input); end

  # @api public
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/result.rb#12
  def input; end
end

# Failure result
#
# @api public
#
# source://dry-types//lib/dry/types/result.rb#43
class Dry::Types::Result::Failure < ::Dry::Types::Result
  # @api private
  # @param input [Object]
  # @param error [#to_s]
  # @return [Failure] a new instance of Failure
  #
  # source://dry-types//lib/dry/types/result.rb#54
  def initialize(input, error); end

  # @api public
  # @return [#to_s]
  #
  # source://dry-types//lib/dry/types/result.rb#47
  def error; end

  # @api public
  # @return [true]
  #
  # source://dry-types//lib/dry/types/result.rb#76
  def failure?; end

  # @api public
  # @return [false]
  #
  # source://dry-types//lib/dry/types/result.rb#69
  def success?; end

  # @api private
  # @return [String]
  #
  # source://dry-types//lib/dry/types/result.rb#62
  def to_s; end
end

# Success result
#
# @api public
#
# source://dry-types//lib/dry/types/result.rb#27
class Dry::Types::Result::Success < ::Dry::Types::Result
  # @api public
  # @return [false]
  #
  # source://dry-types//lib/dry/types/result.rb#35
  def failure?; end

  # @api public
  # @return [true]
  #
  # source://dry-types//lib/dry/types/result.rb#28
  def success?; end
end

# @api public
Dry::Types::Safe = Dry::Types::Lax

# The built-in Hash type can be defined in terms of keys and associated types
# its values can contain. Such definitions are named {Schema}s and defined
# as lists of {Key} types.
#
# {Schema} evaluates default values for keys missing in input hash
#
# {Schema} implements Enumerable using its keys as collection.
#
# @api public
# @see Dry::Types::Schema::Key
# @see Dry::Types::Default#evaluate
# @see Dry::Types::Default::Callable#evaluate
#
# source://dry-types//lib/dry/types/schema.rb#19
class Dry::Types::Schema < ::Dry::Types::Hash
  include ::Enumerable

  # @api private
  # @option options
  # @option options
  # @param _primitive [Class]
  # @param options [Hash]
  # @return [Schema] a new instance of Schema
  #
  # source://dry-types//lib/dry/types/schema.rb#41
  def initialize(_primitive, **options); end

  # @api public
  # @option options
  # @option options
  # @param hash [Hash]
  # @param options [Hash] a customizable set of options
  # @return [Hash{Symbol => Object}]
  #
  # source://dry-types//lib/dry/types/schema.rb#80
  def apply(hash, options = T.unsafe(nil)); end

  # @api private
  # @param hash [Hash]
  # @return [Hash{Symbol => Object}]
  #
  # source://dry-types//lib/dry/types/schema.rb#68
  def call_safe(hash, options = T.unsafe(nil)); end

  # @api private
  # @param hash [Hash]
  # @return [Hash{Symbol => Object}]
  #
  # source://dry-types//lib/dry/types/schema.rb#59
  def call_unsafe(hash, options = T.unsafe(nil)); end

  # Empty schema with the same options
  #
  # @api public
  # @return [Schema]
  #
  # source://dry-types//lib/dry/types/schema.rb#298
  def clear; end

  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/schema.rb#270
  def constrained?; end

  # Iterate over each key type
  #
  # @api public
  # @return [Array<Dry::Types::Schema::Key>, Enumerator]
  #
  # source://dry-types//lib/dry/types/schema.rb#229
  def each(&block); end

  # Fetch key type by a key name
  #
  # Behaves as ::Hash#fetch
  #
  # @api public
  # @overload key
  # @overload key
  #
  # source://dry-types//lib/dry/types/schema.rb#259
  def key(name, fallback = T.unsafe(nil), &block); end

  # Whether the schema has the given key
  #
  # @api public
  # @param name [Symbol] Key name
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/schema.rb#240
  def key?(name); end

  # @api public
  # @return [Array[Dry::Types::Schema::Key]]
  #
  # source://dry-types//lib/dry/types/schema.rb#26
  def keys; end

  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/schema.rb#277
  def lax; end

  # Merge given schema keys into current schema
  #
  # A new instance is returned.
  #
  # @api public
  # @param other [Schema] schema
  # @return [Schema]
  #
  # source://dry-types//lib/dry/types/schema.rb#289
  def merge(other); end

  # @api public
  # @return [Hash[Symbol, Dry::Types::Schema::Key]]
  #
  # source://dry-types//lib/dry/types/schema.rb#29
  def name_key_map; end

  # @api public
  # @overload schema
  # @overload schema
  #
  # source://dry-types//lib/dry/types/schema.rb#213
  def schema(keys_or_map); end

  # Make the schema intolerant to unknown keys
  #
  # @api public
  # @return [Schema]
  #
  # source://dry-types//lib/dry/types/schema.rb#172
  def strict(strict = T.unsafe(nil)); end

  # Whether the schema rejects unknown keys
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/schema.rb#163
  def strict?; end

  # @api public
  # @param meta [Boolean] Whether to dump the meta to the AST
  # @return [Array] An AST representation
  #
  # source://dry-types//lib/dry/types/schema.rb#149
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @return [#call]
  #
  # source://dry-types//lib/dry/types/schema.rb#32
  def transform_key; end

  # Whether the schema transforms input keys
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/schema.rb#198
  def transform_keys?; end

  # @api public
  # @param input [Hash] hash
  # @return [Logic::Result]
  # @return [Object] if coercion fails and a block is given
  # @yieldparam failure [Failure]
  # @yieldreturn [Result]
  #
  # source://dry-types//lib/dry/types/schema.rb#95
  def try(input); end

  # Inject a key transformation function
  #
  # @api public
  # @param proc [#call, nil]
  # @param block [#call, nil]
  # @raise [ArgumentError]
  # @return [Schema]
  #
  # source://dry-types//lib/dry/types/schema.rb#184
  def with_key_transform(proc = T.unsafe(nil), &block); end

  private

  # @api private
  # @param keys [Array<Dry::Types::Schema::Keys>]
  # @return [Dry::Types::Schema]
  #
  # source://dry-types//lib/dry/types/schema.rb#309
  def merge_keys(*keys); end

  # @api private
  # @return [MissingKeyError]
  #
  # source://dry-types//lib/dry/types/schema.rb#405
  def missing_key(key); end

  # Try to add missing keys to the hash
  #
  # @api private
  #
  # source://dry-types//lib/dry/types/schema.rb#373
  def resolve_missing_keys(hash, options); end

  # Validate and coerce a hash. Call a block and halt on any error
  #
  # @api private
  # @return [Hash]
  #
  # source://dry-types//lib/dry/types/schema.rb#351
  def resolve_safe(hash, options = T.unsafe(nil), &block); end

  # Validate and coerce a hash. Raise an exception on any error
  #
  # @api private
  # @return [Hash]
  #
  # source://dry-types//lib/dry/types/schema.rb#321
  def resolve_unsafe(hash, options = T.unsafe(nil)); end

  # @api private
  # @param hash_keys [Array<Symbol>]
  # @return [UnknownKeysError]
  #
  # source://dry-types//lib/dry/types/schema.rb#397
  def unexpected_keys(hash_keys); end
end

# Proxy type for schema keys. Contains only key name and
# whether it's required or not. All other calls deletaged
# to the wrapped type.
#
# @api public
# @see Dry::Types::Schema
#
# source://dry-types//lib/dry/types/schema/key.rb#14
class Dry::Types::Schema::Key
  include ::Dry::Types::Type
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Types::Options
  include ::Dry::Types::Decorator
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Printable
  extend ::Dry::Core::Deprecations::Interface

  # @api private
  # @return [Key] a new instance of Key
  #
  # source://dry-types//lib/dry/types/schema/key.rb#26
  def initialize(type, name, required: T.unsafe(nil), **options); end

  # @api private
  #
  # source://dry-types//lib/dry/types/schema/key.rb#40
  def call_safe(input, &block); end

  # @api private
  #
  # source://dry-types//lib/dry/types/schema/key.rb#45
  def call_unsafe(input); end

  # Turn key into a lax type. Lax types are not strict hence such keys are not required
  #
  # @api public
  # @return [Lax]
  #
  # source://dry-types//lib/dry/types/schema/key.rb#99
  def lax; end

  # @api public
  # @see Dry::Types::Meta#meta
  #
  # source://dry-types//lib/dry/types/schema/key.rb#131
  def meta(data = T.unsafe(nil)); end

  # @api public
  # @return [Symbol]
  #
  # source://dry-types//lib/dry/types/schema/key.rb#23
  def name; end

  # Make key not required
  #
  # @api public
  # @return [Dry::Types::Schema::Key]
  #
  # source://dry-types//lib/dry/types/schema/key.rb#90
  def omittable; end

  # Make wrapped type optional
  #
  # @api public
  # @return [Key]
  #
  # source://dry-types//lib/dry/types/schema/key.rb#108
  def optional; end

  # Control whether the key is required
  #
  # @api public
  # @overload required
  # @overload required
  #
  # source://dry-types//lib/dry/types/schema/key.rb#77
  def required(required = T.unsafe(nil)); end

  # Whether the key is required in schema input
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/schema/key.rb#61
  def required?; end

  # Dump to internal AST representation
  #
  # @api public
  # @return [Array]
  #
  # source://dry-types//lib/dry/types/schema/key.rb#117
  def to_ast(meta: T.unsafe(nil)); end

  # @api public
  # @see Dry::Types::Nominal#try
  #
  # source://dry-types//lib/dry/types/schema/key.rb#52
  def try(input, &block); end

  private

  # @api private
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/schema/key.rb#147
  def decorate?(response); end
end

# @api public
#
# source://dry-types//lib/dry/types/schema.rb#20
Dry::Types::Schema::NO_TRANSFORM = T.let(T.unsafe(nil), String)

# @api public
#
# source://dry-types//lib/dry/types/schema.rb#21
Dry::Types::Schema::SYMBOLIZE_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://dry-types//lib/dry/types/errors.rb#70
class Dry::Types::SchemaError < ::Dry::Types::CoercionError
  # @api public
  # @param key [String, Symbol]
  # @param value [Object]
  # @param result [String, #to_s]
  # @return [SchemaError] a new instance of SchemaError
  #
  # source://dry-types//lib/dry/types/errors.rb#79
  def initialize(key, value, result); end

  # @api public
  # @return [String, Symbol]
  #
  # source://dry-types//lib/dry/types/errors.rb#71
  def key; end

  # @api public
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/errors.rb#74
  def value; end
end

# @api public
#
# source://dry-types//lib/dry/types/errors.rb#91
class Dry::Types::SchemaKeyError < ::Dry::Types::CoercionError; end

# Sum type
#
# @api public
#
# source://dry-types//lib/dry/types/sum.rb#8
class Dry::Types::Sum
  include ::Dry::Types::Type
  include ::Dry::Core::Constants
  include ::Dry::Types::Builder
  include ::Dry::Types::Options
  include ::Dry::Types::Meta
  include ::Dry::Types::Printable
  include ::Dry::Core::Equalizer::Methods
  include ::Dry::Types::Composition

  # @api private
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/sum.rb#36
  def call_safe(input, &block); end

  # @api private
  # @param input [Object]
  # @return [Object]
  #
  # source://dry-types//lib/dry/types/sum.rb#27
  def call_unsafe(input); end

  # @api public
  # @param options [Hash]
  # @return [Constrained, Sum]
  # @see Builder#constrained
  #
  # source://dry-types//lib/dry/types/sum.rb#87
  def constrained(options); end

  # Manage metadata to the type. If the type is an optional, #meta delegates
  # to the right branch
  #
  # @api public
  # @see [Meta#meta]
  #
  # source://dry-types//lib/dry/types/sum.rb#70
  def meta(data = T.unsafe(nil)); end

  # @api public
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/sum.rb#18
  def optional?; end

  # @api private
  # @param value [Object]
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/sum.rb#60
  def primitive?(value); end

  # @api public
  # @param input [Object]
  #
  # source://dry-types//lib/dry/types/sum.rb#43
  def try(input); end

  class << self
    # source://dry-types//lib/dry/types/composition.rb#36
    def ast_type; end

    # source://dry-types//lib/dry/types/composition.rb#37
    def composition_name; end

    # @api public
    #
    # source://dry-types//lib/dry/types/sum.rb#11
    def operator; end
  end
end

# source://dry-types//lib/dry/types/sum.rb#0
class Dry::Types::Sum::Constrained < ::Dry::Types::Sum
  include ::Dry::Types::Composition::Constrained
end

# @api public
#
# source://dry-types//lib/dry/types.rb#31
Dry::Types::TYPE_SPEC_REGEX = T.let(T.unsafe(nil), Regexp)

# Common Type module denoting an object is a Type
#
# @api public
#
# source://dry-types//lib/dry/types/type.rb#8
module Dry::Types::Type
  extend ::Dry::Core::Deprecations::Interface

  # Whether a value is a valid member of the type
  # Anything can be coerced matches
  #
  # @api private
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/type.rb#18
  def ===(input = T.unsafe(nil)); end

  # Apply type to a value
  #
  # @api public
  # @overload call
  # @overload call
  #
  # source://dry-types//lib/dry/types/type.rb#43
  def [](input = T.unsafe(nil), &block); end

  # Apply type to a value
  #
  # @api public
  # @overload call
  # @overload call
  #
  # source://dry-types//lib/dry/types/type.rb#43
  def call(input = T.unsafe(nil), &block); end

  # source://dry-core/1.0.1/lib/dry/core/deprecations.rb#168
  def safe(*args, &block); end

  # Whether a value is a valid member of the type
  #
  # @api private
  # @return [Boolean]
  #
  # source://dry-types//lib/dry/types/type.rb#18
  def valid?(input = T.unsafe(nil)); end
end

# @api public
#
# source://dry-types//lib/dry/types/errors.rb#106
class Dry::Types::UnknownKeysError < ::Dry::Types::SchemaKeyError
  # @api public
  # @param keys [<String, Symbol>]
  # @return [UnknownKeysError] a new instance of UnknownKeysError
  #
  # source://dry-types//lib/dry/types/errors.rb#110
  def initialize(keys); end

  # @api public
  # @return [Array<Symbol>]
  #
  # source://dry-types//lib/dry/types/errors.rb#107
  def keys; end
end

# source://dry-types//lib/dry/types/version.rb#5
Dry::Types::VERSION = T.let(T.unsafe(nil), String)
