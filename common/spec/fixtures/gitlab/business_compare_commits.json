{
    "commit": {
        "author_email": "asklarsen@gmail.com",
        "author_name": "Ask Hjorth Larsen",
        "authored_date": "2017-09-28T18:12:19.000Z",
        "committed_date": "2017-09-28T18:12:19.000Z",
        "committer_email": "asklarsen@gmail.com",
        "committer_name": "Ask Hjorth Larsen",
        "created_at": "2017-09-28T18:12:19.000Z",
        "id": "36bd17dda869775b1aed91e39767bb4e7359a983",
        "message": "ASE version 3.15.0\n",
        "parent_ids": [
            "269044962b5b44763cdcddd38ce6b742b6977656"
        ],
        "short_id": "36bd17dd",
        "title": "ASE version 3.15.0"
    },
    "commits": [
        {
            "author_email": "jensj@fysik.dtu.dk",
            "author_name": "Jens Jørgen Mortensen",
            "authored_date": "2017-04-12T18:10:06.000Z",
            "committed_date": "2017-04-12T18:10:06.000Z",
            "committer_email": "jensj@fysik.dtu.dk",
            "committer_name": "Jens Jørgen Mortensen",
            "created_at": "2017-04-12T18:10:06.000Z",
            "id": "8d7d08fb9a7a439b3e6a1e6a1a34cbdb4273de87",
            "message": "Add find command\n",
            "parent_ids": [
                "687bf14aa3e7b85160da17b54de003f45bd33ea9"
            ],
            "short_id": "8d7d08fb",
            "title": "Add find command"
        },
        {
            "author_email": "jensj@fysik.dtu.dk",
            "author_name": "Jens Jørgen Mortensen",
            "authored_date": "2017-04-15T18:54:46.000Z",
            "committed_date": "2017-04-15T18:54:46.000Z",
            "committer_email": "jensj@fysik.dtu.dk",
            "committer_name": "Jens Jørgen Mortensen",
            "created_at": "2017-04-15T18:54:46.000Z",
            "id": "4ac81646582f254b3e86653b8fcd5eda6d8bb45d",
            "message": "...\n",
            "parent_ids": [
                "f09b98dd5144ddfe88ae0850b69d04a643137dac"
            ],
            "short_id": "4ac81646",
            "title": "..."
        },
        {
            "author_email": "jensj@fysik.dtu.dk",
            "author_name": "Jens Jørgen Mortensen",
            "authored_date": "2017-04-15T21:36:29.000Z",
            "committed_date": "2017-04-15T21:36:29.000Z",
            "committer_email": "jensj@fysik.dtu.dk",
            "committer_name": "Jens Jørgen Mortensen",
            "created_at": "2017-04-15T21:36:29.000Z",
            "id": "4e5081f867631f10d8a29dc6853a052f52241fab",
            "message": "MP version\n",
            "parent_ids": [
                "4ac81646582f254b3e86653b8fcd5eda6d8bb45d"
            ],
            "short_id": "4e5081f8",
            "title": "MP version"
        },
        {
            "author_email": "ivan.kondov@kit.edu",
            "author_name": "Ivan Kondov",
            "authored_date": "2017-04-17T16:24:56.000Z",
            "committed_date": "2017-04-17T16:24:56.000Z",
            "committer_email": "ivan.kondov@kit.edu",
            "committer_name": "Ivan Kondov",
            "created_at": "2017-04-17T16:24:56.000Z",
            "id": "e718899ddcdc666311d08497401199e126428163",
            "message": "BUG: added 'force_consistent' keyword argument with default True\n\nThe bug fix is necessayry to pass the test turbomole_h3o2m.py.\n",
            "parent_ids": [
                "1a77c48212a3b3186564115b85448ca002ef158a"
            ],
            "short_id": "e718899d",
            "title": "BUG: added 'force_consistent' keyword argument with default True"
        }
    ],
    "compare_same_ref": false,
    "compare_timeout": true,
    "diffs": [
        {
            "a_mode": "100644",
            "b_mode": "100644",
            "deleted_file": false,
            "diff": "--- a/ase/__init__.py\n+++ b/ase/__init__.py\n@@ -11,7 +11,7 @@ from ase.atom import Atom\n from ase.atoms import Atoms\n \n __all__ = ['Atoms', 'Atom']\n-__version__ = '3.14.1'\n+__version__ = '3.15.0'\n \n # import ase.parallel early to avoid circular import problems when\n # ase.parallel does \"from gpaw.mpi import world\":\n",
            "new_file": false,
            "new_path": "ase/__init__.py",
            "old_path": "ase/__init__.py",
            "renamed_file": false
        },
        {
            "a_mode": "100644",
            "b_mode": "100644",
            "deleted_file": false,
            "diff": "--- a/ase/atom.py\n+++ b/ase/atom.py\n@@ -11,8 +11,8 @@ names = {'position': ('positions', np.zeros(3)),\n          'tag': ('tags', 0),\n          'momentum': ('momenta', np.zeros(3)),\n          'mass': ('masses', None),\n-         'magmom': ('magmoms', 0.0),\n-         'charge': ('charges', 0.0)}\n+         'magmom': ('initial_magmoms', 0.0),\n+         'charge': ('initial_charges', 0.0)}\n \n \n def atomproperty(name, doc):\n@@ -65,7 +65,7 @@ class Atom(object):\n     symbol: str or int\n         Can be a chemical symbol (str) or an atomic number (int).\n     position: sequence of 3 floats\n-        Atomi position.\n+        Atomic position.\n     tag: int\n         Special purpose tag.\n     momentum: sequence of 3 floats\n@@ -192,7 +192,7 @@ class Atom(object):\n     momentum = atomproperty('momentum', 'XYZ-momentum')\n     mass = atomproperty('mass', 'Atomic mass')\n     magmom = atomproperty('magmom', 'Initial magnetic moment')\n-    charge = atomproperty('charge', 'Atomic charge')\n+    charge = atomproperty('charge', 'Initial atomic charge')\n     x = xyzproperty(0)\n     y = xyzproperty(1)\n     z = xyzproperty(2)\n",
            "new_file": false,
            "new_path": "ase/atom.py",
            "old_path": "ase/atom.py",
            "renamed_file": false
        },
        {
            "a_mode": "100644",
            "b_mode": "100644",
            "deleted_file": false,
            "diff": "--- a/ase/atoms.py\n+++ b/ase/atoms.py\n@@ -63,7 +63,7 @@ class Atoms(object):\n         for collinear calculations or three numbers for each atom for\n         non-collinear calculations.\n     charges: list of float\n-        Atomic charges.\n+        Initial atomic charges.\n     cell: 3x3 matrix or length 3 or 6 vector\n         Unit cell vectors.  Can also be given as just three\n         numbers for orthorhombic cells, or 6 numbers, where\n@@ -163,11 +163,11 @@ class Atoms(object):\n                 tags = atoms.get_tags()\n             if momenta is None and atoms.has('momenta'):\n                 momenta = atoms.get_momenta()\n-            if magmoms is None and atoms.has('magmoms'):\n+            if magmoms is None and atoms.has('initial_magmoms'):\n                 magmoms = atoms.get_initial_magnetic_moments()\n             if masses is None and atoms.has('masses'):\n                 masses = atoms.get_masses()\n-            if charges is None and atoms.has('charges'):\n+            if charges is None and atoms.has('initial_charges'):\n                 charges = atoms.get_initial_charges()\n             if cell is None:\n                 cell = atoms.get_cell()\n@@ -228,7 +228,8 @@ class Atoms(object):\n         if pbc is None:\n             pbc = False\n         self.set_pbc(pbc)\n-        self.set_momenta(default(momenta, (0.0, 0.0, 0.0)), apply_constraint=False)\n+        self.set_momenta(default(momenta, (0.0, 0.0, 0.0)),\n+                         apply_constraint=False)\n \n         if info is None:\n             self.info = {}\n@@ -448,8 +449,9 @@ class Atoms(object):\n     def has(self, name):\n         \"\"\"Check for existence of array.\n \n-        name must be one of: 'tags', 'momenta', 'masses', 'magmoms',\n-        'charges'.\"\"\"\n+        name must be one of: 'tags', 'momenta', 'masses', 'initial_magmoms',\n+        'initial_charges'.\"\"\"\n+        # XXX extend has to calculator properties\n         return name in self.arrays\n \n     def set_atomic_numbers(self, numbers):\n@@ -591,15 +593,16 @@ class Atoms(object):\n         or non-collinear spins).\"\"\"\n \n         if magmoms is None:\n-            self.set_array('magmoms', None)\n+            self.set_array('initial_magmoms', None)\n         else:\n             magmoms = np.asarray(magmoms)\n-            self.set_array('magmoms', magmoms, float, magmoms.shape[1:])\n+            self.set_array('initial_magmoms', magmoms, float,\n+                           magmoms.shape[1:])\n \n     def get_initial_magnetic_moments(self):\n         \"\"\"Get array of initial magnetic moments.\"\"\"\n-        if 'magmoms' in self.arrays:\n-            return self.arrays['magmoms'].copy()\n+        if 'initial_magmoms' in self.arrays:\n+            return self.arrays['initial_magmoms'].copy()\n         else:\n             return np.zeros(len(self))\n \n@@ -619,14 +622,14 @@ class Atoms(object):\n         \"\"\"Set the initial charges.\"\"\"\n \n         if charges is None:\n-            self.set_array('charges', None)\n+            self.set_array('initial_charges', None)\n         else:\n-            self.set_array('charges', charges, float, ())\n+            self.set_array('initial_charges', charges, float, ())\n \n     def get_initial_charges(self):\n         \"\"\"Get array of initial charges.\"\"\"\n-        if 'charges' in self.arrays:\n-            return self.arrays['charges'].copy()\n+        if 'initial_charges' in self.arrays:\n+            return self.arrays['initial_charges'].copy()\n         else:\n             return np.zeros(len(self))\n \n@@ -929,15 +932,17 @@ class Atoms(object):\n             # interpreted at 0 and 1 indices.\n             i = np.array(i)\n \n-        condel = []\n-        for con in self.constraints:\n+        import copy\n+\n+        conadd = []\n+        # Constraints need to be deepcopied, but only the relevant ones.\n+        for con in copy.deepcopy(self.constraints):\n             if isinstance(con, (FixConstraint, FixBondLengths)):\n                 try:\n                     con.index_shuffle(self, i)\n+                    conadd.append(con)\n                 except IndexError:\n-                    condel.append(con)\n-\n-        import copy\n+                    pass\n \n         atoms = self.__class__(cell=self._cell, pbc=self._pbc, info=self.info,\n                                # should be communicated to the slice as well\n@@ -948,9 +953,7 @@ class Atoms(object):\n         for name, a in self.arrays.items():\n             atoms.arrays[name] = a[i].copy()\n \n-        # Constraints need to be deepcopied, but only the relevant ones.\n-        atoms.constraints = copy.deepcopy([con for con in self.constraints if\n-                                            con not in condel])\n+        atoms.constraints = conadd\n         return atoms\n \n     def __delitem__(self, i):\n@@ -1808,6 +1811,9 @@ class Atoms(object):\n         from ase.io import write\n         write(filename, self, format, **kwargs)\n \n+    def _images_(self):\n+        yield self\n+\n     def edit(self):\n         \"\"\"Modify atoms interactively through ASE's GUI viewer.\n \n@@ -1823,20 +1829,6 @@ class Atoms(object):\n         images = Images([self])\n         gui = GUI(images)\n         gui.run()\n-        # use atoms returned from gui:\n-        # (1) delete all currently available atoms\n-        self.set_constraint()\n-        for z in range(len(self)):\n-            self.pop()\n-        edited_atoms = gui.images.get_atoms(0)\n-        # (2) extract atoms from edit session\n-        self.extend(edited_atoms)\n-        self.set_constraint(edited_atoms._get_constraints())\n-        self.set_cell(edited_atoms.get_cell())\n-        self.set_initial_magnetic_moments(\n-            edited_atoms.get_initial_magnetic_moments())\n-        self.set_tags(edited_atoms.get_tags())\n-        return\n \n \n def string2symbols(s):\n",
            "new_file": false,
            "new_path": "ase/atoms.py",
            "old_path": "ase/atoms.py",
            "renamed_file": false
        },
        {
            "a_mode": "100644",
            "b_mode": "100644",
            "deleted_file": false,
            "diff": "--- a/ase/autoneb.py\n+++ b/ase/autoneb.py\n@@ -94,9 +94,8 @@ class AutoNEB(object):\n     prefixXXXiter00i.traj exists with XXX ranging from 000 to the N images\n     currently in the NEB.\n \n-    The most recent NEB path can always be monitored by::\n-\n-        $ ase gui -n -1 iter prefix???.traj\n+    The most recent NEB path can always be monitored by:\n+        $ ase-gui -n -1 neb???.traj\n     \"\"\"\n \n     def __init__(self, attach_calculators, prefix, n_simul, n_max,\n@@ -105,7 +104,7 @@ class AutoNEB(object):\n                  optimizer='FIRE',\n                  remove_rotation_and_translation=False, space_energy_ratio=0.5,\n                  world=None,\n-                 parallel=True, smooth_curve=False, interpolate_method='IDPP'):\n+                 parallel=True, smooth_curve=False, interpolate_method='idpp'):\n         self.attach_calculators = attach_calculators\n         self.prefix = prefix\n         self.n_simul = n_simul\n@@ -120,8 +119,8 @@ class AutoNEB(object):\n         self.method = method\n         self.remove_rotation_and_translation = remove_rotation_and_translation\n         self.space_energy_ratio = space_energy_ratio\n-        if interpolate_method not in ['IDPP', 'linear']:\n-            self.interpolate_method = 'IDPP'\n+        if interpolate_method not in ['idpp', 'linear']:\n+            self.interpolate_method = 'idpp'\n             print('Interpolation method not implementet.',\n                   'Using the IDPP method.')\n         else:\n@@ -138,7 +137,7 @@ class AutoNEB(object):\n         else:\n             raise Exception('Optimizer needs to be BFGS or FIRE')\n         self.iter_folder = iter_folder\n-        if not os.path.exists(self.iter_folder):\n+        if not os.path.exists(self.iter_folder) and self.world.rank == 0:\n             os.makedirs(self.iter_folder)\n \n     def execute_one_neb(self, n_cur, to_run, climb=False, many_steps=False):\n@@ -150,7 +149,8 @@ class AutoNEB(object):\n             for i in range(n_cur):\n                 if i not in to_run[1: -1]:\n                     filename = '%s%03d.traj' % (self.prefix, i)\n-                    self.all_images[i].write(filename)\n+                    t = Trajectory(filename, mode='w', atoms=self.all_images[i])\n+                    t.write()\n                     filename_ref = self.iter_folder + \\\n                         '/%s%03diter%03d.traj' % (self.prefix, i,\n                                                   self.iteration)\n@@ -479,8 +479,7 @@ class AutoNEB(object):\n         # And now lets read in the configurations\n         for i in range(n_cur):\n             if i in index_exists:\n-                filename = self.iter_folder + \\\n-                    '/%s%03diter000.traj' % (self.prefix, i)\n+                filename = '%s%03d.traj' % (self.prefix, i)\n                 newim = read(filename)\n                 self.all_images.append(newim)\n             else:\n",
            "new_file": false,
            "new_path": "ase/autoneb.py",
            "old_path": "ase/autoneb.py",
            "renamed_file": false
        },
        {
            "a_mode": "100644",
            "b_mode": "100644",
            "deleted_file": false,
            "diff": "--- a/ase/build/bulk.py\n+++ b/ase/build/bulk.py\n@@ -3,6 +3,7 @@ from math import sqrt\n \n from ase.atoms import Atoms, string2symbols\n from ase.data import reference_states, atomic_numbers, chemical_symbols\n+from ase.utils import plural\n \n \n def bulk(name, crystalstructure=None, a=None, c=None, covera=None, u=None,\n@@ -44,8 +45,9 @@ def bulk(name, crystalstructure=None, a=None, c=None, covera=None, u=None,\n         if ref is not None:\n             xref = ref['symmetry']\n \n-    structures = set(['sc', 'fcc', 'bcc', 'hcp', 'diamond', 'zincblende',\n-                      'rocksalt', 'cesiumchloride', 'fluorite', 'wurtzite'])\n+    structures = {'sc': 1, 'fcc': 1, 'bcc': 1, 'hcp': 1, 'diamond': 1,\n+                  'zincblende': 2, 'rocksalt':2, 'cesiumchloride':2,\n+                  'fluorite': 3, 'wurtzite': 2}\n \n     if crystalstructure is None:\n         crystalstructure = xref\n@@ -58,14 +60,21 @@ def bulk(name, crystalstructure=None, a=None, c=None, covera=None, u=None,\n         raise ValueError('Unknown structure: {}.'\n                          .format(crystalstructure))\n \n+    # Check name:\n+    n = len(string2symbols(name))\n+    n0 = structures[crystalstructure]\n+    if n != n0:\n+        raise ValueError('Please specify {} for {} and not {}'\n+                         .format(plural(n0, 'atom'), crystalstructure, n))\n+\n     if a is None:\n         if xref != crystalstructure:\n             raise ValueError('You need to specify the lattice constant.')\n         try:\n             a = ref['a']\n         except KeyError:\n-            raise KeyError('No reference lattice parameter \"a\" for \"%s\"' %\n-                           name)\n+            raise KeyError('No reference lattice parameter \"a\" for \"{}\"'\n+                           .format(name))\n \n     if crystalstructure in ['hcp', 'wurtzite']:\n         cubic = False\n",
            "new_file": false,
            "new_path": "ase/build/bulk.py",
            "old_path": "ase/build/bulk.py",
            "renamed_file": false
        },
        {
            "a_mode": "100644",
            "b_mode": "100644",
            "deleted_file": false,
            "diff": "--- a/ase/build/molecule.py\n+++ b/ase/build/molecule.py\n@@ -2,16 +2,19 @@ from ase.atoms import Atoms\n from ase.collections import g2\n \n \n-def molecule(name, **kwargs):\n+def molecule(name, vacuum=None, **kwargs):\n     if name in extra:\n         kwargs.update(extra[name])\n-        return Atoms(**kwargs)\n-    mol = g2[name]\n-    if kwargs:\n-        mol = Atoms(mol, **kwargs)\n+        mol = Atoms(**kwargs)\n+    else:\n+        mol = g2[name]\n+        if kwargs:\n+            mol = Atoms(mol, **kwargs)\n+    if vacuum is not None:\n+        mol.center(vacuum=vacuum)\n     return mol\n \n-    \n+\n extra = {\n     'Be2': {\n         'symbols': 'BeBe',\n",
            "new_file": false,
            "new_path": "ase/build/molecule.py",
            "old_path": "ase/build/molecule.py",
            "renamed_file": false
        },
        {
            "a_mode": "100644",
            "b_mode": "100644",
            "deleted_file": false,
            "diff": "--- a/ase/build/tools.py\n+++ b/ase/build/tools.py\n@@ -328,7 +328,7 @@ def stack(atoms1, atoms2, axis=2, cell=None, fix=0.5,\n     else:\n         return atoms1\n \n-        \n+\n def rotation_matrix(a1, a2, b1, b2):\n     \"\"\"Returns a rotation matrix that rotates the vectors *a1* in the\n     direction of *a2* and *b1* in the direction of *b2*.\n@@ -420,121 +420,88 @@ def minimize_tilt(atoms, order=range(3), fold_atoms=True):\n             if pbc_c[c1] and pbc_c[c2]:\n                 minimize_tilt_ij(atoms, c1, c2, fold_atoms)\n \n-                \n-def niggli_reduce(atoms):\n-    \"\"\"Convert the supplied atoms object's unit cell into its\n-    maximally-reduced Niggli unit cell. Even if the unit cell is already\n-    maximally reduced, it will be converted into its unique Niggli unit cell.\n-    This will also wrap all atoms into the new unit cell.\n \n-    References:\n+class _gtensor(object):\n+    \"\"\"The G tensor as defined in Grosse-Kunstleve.\"\"\"\n+    def __init__(self, cell):\n \n-    Niggli, P. \"Krystallographische und strukturtheoretische Grundbegriffe.\n-    Handbuch der Experimentalphysik\", 1928, Vol. 7, Part 1, 108-176.\n+        self.cell = cell\n \n-    Krivy, I. and Gruber, B., \"A Unified Algorithm for Determining the\n-    Reduced (Niggli) Cell\", Acta Cryst. 1976, A32, 297-298.\n+        self.epsilon = 1e-5 * abs(np.linalg.det(cell))**(1. / 3.)\n \n-    Grosse-Kunstleve, R.W.; Sauter, N. K.; and Adams, P. D. \"Numerically\n-    stable algorithms for the computation of reduced unit cells\", Acta Cryst.\n-    2004, A60, 1-6.\n-    \"\"\"\n+        self.a = np.dot(cell[0], cell[0])\n+        self.b = np.dot(cell[1], cell[1])\n+        self.c = np.dot(cell[2], cell[2])\n \n-    assert all(atoms.pbc), 'Can only reduce 3d periodic unit cells!'\n+        self.x = 2 * np.dot(cell[1], cell[2])\n+        self.y = 2 * np.dot(cell[0], cell[2])\n+        self.z = 2 * np.dot(cell[0], cell[1])\n+\n+        self._G = np.array([[self.a, self.z / 2., self.y / 2.],\n+                            [self.z / 2., self.b, self.x / 2.],\n+                            [self.y / 2., self.x / 2., self.c]])\n+\n+    def update(self, C):\n+        \"\"\"Procedure A0 as defined in Krivy.\"\"\"\n+        self._G = np.dot(C.T, np.dot(self._G, C))\n+\n+        self.a = self._G[0][0]\n+        self.b = self._G[1][1]\n+        self.c = self._G[2][2]\n+\n+        self.x = 2 * self._G[1][2]\n+        self.y = 2 * self._G[0][2]\n+        self.z = 2 * self._G[0][1]\n+\n+    def get_new_cell(self):\n+        \"\"\"Returns new basis vectors\"\"\"\n+        a = np.sqrt(self.a)\n+        b = np.sqrt(self.b)\n+        c = np.sqrt(self.c)\n+\n+        ad = self.cell[0] / np.linalg.norm(self.cell[0])\n+\n+        Z = np.cross(self.cell[0], self.cell[1])\n+        Z /= np.linalg.norm(Z)\n+        X = ad - np.dot(ad, Z) * Z\n+        X /= np.linalg.norm(X)\n+        Y = np.cross(Z, X)\n+\n+        alpha = np.arccos(self.x / (2 * b * c))\n+        beta = np.arccos(self.y / (2 * a * c))\n+        gamma = np.arccos(self.z / (2 * a * b))\n+\n+        va = a * np.array([1, 0, 0])\n+        vb = b * np.array([np.cos(gamma), np.sin(gamma), 0])\n+        cx = np.cos(beta)\n+        cy = (np.cos(alpha) - np.cos(beta) * np.cos(gamma)) \\\n+            / np.sin(gamma)\n+        cz = np.sqrt(1. - cx * cx - cy * cy)\n+        vc = c * np.array([cx, cy, cz])\n+\n+        abc = np.vstack((va, vb, vc))\n+        T = np.vstack((X, Y, Z))\n+        return np.dot(abc, T)\n+\n+\n+def niggli_reduce_cell(cell):\n     C = np.eye(3, dtype=int)\n+    cell = np.asarray(cell, dtype=float)\n+    G = _gtensor(cell)\n \n-    class _gtensor(object):\n-        \"\"\"The G tensor as defined in Grosse-Kunstleve.\"\"\"\n-        def __init__(self, atoms):\n-\n-            self.atoms = atoms\n-\n-            self.epsilon = 1e-5 * atoms.get_volume()**(1. / 3.)\n-\n-            self.a = np.dot(atoms.cell[0], atoms.cell[0])\n-            self.b = np.dot(atoms.cell[1], atoms.cell[1])\n-            self.c = np.dot(atoms.cell[2], atoms.cell[2])\n-\n-            self.x = 2 * np.dot(atoms.cell[1], atoms.cell[2])\n-            self.y = 2 * np.dot(atoms.cell[0], atoms.cell[2])\n-            self.z = 2 * np.dot(atoms.cell[0], atoms.cell[1])\n-\n-            self._G = np.array([[self.a, self.z / 2., self.y / 2.],\n-                                [self.z / 2., self.b, self.x / 2.],\n-                                [self.y / 2., self.x / 2., self.c]])\n-\n-            self._lmn()\n-\n-        def update(self, C):\n-            \"\"\"Procedure A0 as defined in Krivy.\"\"\"\n-            self._G = np.dot(C.T, np.dot(self._G, C))\n-\n-            self.a = self._G[0][0]\n-            self.b = self._G[1][1]\n-            self.c = self._G[2][2]\n-\n-            self.x = 2 * self._G[1][2]\n-            self.y = 2 * self._G[0][2]\n-            self.z = 2 * self._G[0][1]\n-\n-            self._lmn()\n-\n-        def _lmn(self):\n-            \"\"\"Updates G-tensor l, m, n values\"\"\"\n-            self.l = 0\n-            self.m = 0\n-            self.n = 0\n-\n-            if self.x < -self.epsilon:\n-                self.l = -1\n-            elif self.x > self.epsilon:\n-                self.l = 1\n-            if self.y < -self.epsilon:\n-                self.m = -1\n-            elif self.y > self.epsilon:\n-                self.m = 1\n-            if self.z < -self.epsilon:\n-                self.n = -1\n-            elif self.z > self.epsilon:\n-                self.n = 1\n-\n-        def get_new_cell(self):\n-            \"\"\"Returns new basis vectors\"\"\"\n-            a = np.sqrt(self.a)\n-            b = np.sqrt(self.b)\n-            c = np.sqrt(self.c)\n-\n-            ad = self.atoms.cell[0] / np.linalg.norm(self.atoms.cell[0])\n-\n-            Z = np.cross(self.atoms.cell[0], self.atoms.cell[1])\n-            Z /= np.linalg.norm(Z)\n-            X = ad - np.dot(ad, Z) * Z\n-            X /= np.linalg.norm(X)\n-            Y = np.cross(Z, X)\n-\n-            alpha = np.arccos(self.x / (2 * b * c))\n-            beta = np.arccos(self.y / (2 * a * c))\n-            gamma = np.arccos(self.z / (2 * a * b))\n-\n-            va = a * np.array([1, 0, 0])\n-            vb = b * np.array([np.cos(gamma), np.sin(gamma), 0])\n-            cx = np.cos(beta)\n-            cy = (np.cos(alpha) - np.cos(beta) * np.cos(gamma)) \\\n-                / np.sin(gamma)\n-            cz = np.sqrt(1. - cx * cx - cy * cy)\n-            vc = c * np.array([cx, cy, cz])\n-\n-            abc = np.vstack((va, vb, vc))\n-            T = np.vstack((X, Y, Z))\n-            return np.dot(abc, T)\n-    G = _gtensor(atoms)\n+    def lt(x, y, epsilon=G.epsilon):\n+        return x < y - epsilon\n+\n+    def gt(x, y, epsilon=G.epsilon):\n+        return lt(y, x, epsilon)\n+\n+    def eq(x, y, epsilon=G.epsilon):\n+        return not (lt(x, y, epsilon) or gt(x, y, epsilon))\n \n     # Once A2 and A5-A8 all evaluate to False, the unit cell will have\n     # been fully reduced.\n     for count in range(10000):\n-        if (G.a > G.b + G.epsilon or\n-            (not np.abs(G.a - G.b) > G.epsilon and\n-             np.abs(G.x) > np.abs(G.y) + G.epsilon)):\n+        if gt(G.a, G.b) or (eq(G.a, G.b) and gt(np.abs(G.x), np.abs(G.y))):\n             # Procedure A1\n             A = np.array([[0, -1, 0],\n                           [-1, 0, 0],\n@@ -542,9 +509,7 @@ def niggli_reduce(atoms):\n             G.update(A)\n             C = np.dot(C, A)\n \n-        if (G.b > G.c + G.epsilon or\n-            (not np.abs(G.b - G.c) > G.epsilon and\n-             np.abs(G.y) > np.abs(G.z) + G.epsilon)):\n+        if gt(G.b, G.c) or (eq(G.b, G.c) and gt(np.abs(G.y), np.abs(G.z))):\n             # Procedure A2\n             A = np.array([[-1, 0, 0],\n                           [0, 0, -1],\n@@ -553,71 +518,63 @@ def niggli_reduce(atoms):\n             C = np.dot(C, A)\n             continue\n \n-        if G.l * G.m * G.n == 1:\n+        if gt(G.x * G.y * G.z, 0, G.epsilon**3):\n             # Procedure A3\n-            i = -1 if G.l == -1 else 1\n-            j = -1 if G.m == -1 else 1\n-            k = -1 if G.n == -1 else 1\n-            A = np.array([[i, 0, 0],\n-                          [0, j, 0],\n-                          [0, 0, k]])\n-            G.update(A)\n-            C = np.dot(C, A)\n+            i = -1 if lt(G.x, 0) else 1\n+            j = -1 if lt(G.y, 0) else 1\n+            k = -1 if lt(G.z, 0) else 1\n         else:\n             # Procedure A4\n-            i = -1 if G.l == 1 else 1\n-            j = -1 if G.m == 1 else 1\n-            k = -1 if G.n == 1 else 1\n+            i = -1 if gt(G.x, 0) else 1\n+            j = -1 if gt(G.y, 0) else 1\n+            k = -1 if gt(G.z, 0) else 1\n \n             if i * j * k == -1:\n-                if G.l == 0:\n-                    i = -1\n-                if G.m == 0:\n-                    j = -1\n-                if G.n == 0:\n+                if eq(G.z, 0):\n                     k = -1\n-            A = np.array([[i, 0, 0],\n-                          [0, j, 0],\n-                          [0, 0, k]])\n-            G.update(A)\n-            C = np.dot(C, A)\n-\n-        if (np.abs(G.x) > G.b + G.epsilon or\n-            (not np.abs(G.b - G.x) > G.epsilon and\n-             2 * G.y < G.z - G.epsilon) or\n-            (not np.abs(G.b + G.x) > G.epsilon and\n-             G.z < -G.epsilon)):\n+                elif eq(G.y, 0):\n+                    j = -1\n+                elif eq(G.x, 0):\n+                    i = -1\n+                else:\n+                    raise RuntimeError('p unassigned and i*j*k < 0!')\n+\n+        A = np.array([[i, 0, 0],\n+                      [0, j, 0],\n+                      [0, 0, k]])\n+        G.update(A)\n+        C = np.dot(C, A)\n+\n+        if (lt(G.b, np.abs(G.x)) or\n+            (eq(G.x, G.b) and lt(2 * G.y, G.z)) or\n+            (eq(G.x, -G.b) and lt(G.z, 0))):\n             # Procedure A5\n             A = np.array([[1, 0, 0],\n                           [0, 1, -np.sign(G.x)],\n                           [0, 0, 1]], dtype=int)\n             G.update(A)\n             C = np.dot(C, A)\n-        elif (np.abs(G.y) > G.a + G.epsilon or\n-              (not np.abs(G.a - G.y) > G.epsilon and\n-               2 * G.x < G.z - G.epsilon) or\n-              (not np.abs(G.a + G.y) > G.epsilon and\n-               G.z < -G.epsilon)):\n+        elif (lt(G.a, np.abs(G.y)) or\n+              (eq(G.y, G.a) and lt(2 * G.x, G.z)) or\n+              (eq(G.y, -G.a) and lt(G.z, 0))):\n             # Procedure A6\n             A = np.array([[1, 0, -np.sign(G.y)],\n                           [0, 1, 0],\n                           [0, 0, 1]], dtype=int)\n             G.update(A)\n             C = np.dot(C, A)\n-        elif (np.abs(G.z) > G.a + G.epsilon or\n-              (not np.abs(G.a - G.z) > G.epsilon and\n-               2 * G.x < G.y - G.epsilon) or\n-              (not np.abs(G.a + G.z) > G.epsilon and\n-               G.y < -G.epsilon)):\n+        elif (lt(G.a, np.abs(G.z)) or\n+              (eq(G.z, G.a) and lt(2 * G.x, G.y)) or\n+              (eq(G.z, -G.a) and lt(G.y, 0))):\n             # Procedure A7\n             A = np.array([[1, -np.sign(G.z), 0],\n                           [0, 1, 0],\n                           [0, 0, 1]], dtype=int)\n             G.update(A)\n             C = np.dot(C, A)\n-        elif (G.x + G.y + G.z + G.a + G.b < -G.epsilon or\n-              (not np.abs(G.x + G.y + G.z + G.a + G.b) > G.epsilon and\n-               2 * (G.a + G.y) + G.z > G.epsilon)):\n+        elif (lt(G.x + G.y + G.z + G.a + G.b, 0) or\n+              (eq(G.x + G.y + G.z + G.a + G.b, 0) and\n+               gt(2 * (G.a + G.y) + G.z, 0))):\n             # Procedure A8\n             A = np.array([[1, 0, 1],\n                           [0, 1, 1],\n@@ -629,14 +586,38 @@ def niggli_reduce(atoms):\n     else:\n         raise RuntimeError('Niggli did not converge \\\n                 in {n} iterations!'.format(n=count))\n+    return G.get_new_cell(), C\n+\n+\n+def niggli_reduce(atoms):\n+    \"\"\"Convert the supplied atoms object's unit cell into its\n+    maximally-reduced Niggli unit cell. Even if the unit cell is already\n+    maximally reduced, it will be converted into its unique Niggli unit cell.\n+    This will also wrap all atoms into the new unit cell.\n+\n+    References:\n+\n+    Niggli, P. \"Krystallographische und strukturtheoretische Grundbegriffe.\n+    Handbuch der Experimentalphysik\", 1928, Vol. 7, Part 1, 108-176.\n+\n+    Krivy, I. and Gruber, B., \"A Unified Algorithm for Determining the\n+    Reduced (Niggli) Cell\", Acta Cryst. 1976, A32, 297-298.\n+\n+    Grosse-Kunstleve, R.W.; Sauter, N. K.; and Adams, P. D. \"Numerically\n+    stable algorithms for the computation of reduced unit cells\", Acta Cryst.\n+    2004, A60, 1-6.\n+    \"\"\"\n+\n+    assert all(atoms.pbc), 'Can only reduce 3d periodic unit cells!'\n+    new_cell, C = niggli_reduce_cell(atoms.cell)\n     scpos = np.dot(atoms.get_scaled_positions(), np.linalg.inv(C).T)\n     scpos %= 1.0\n     scpos %= 1.0\n \n-    atoms.set_cell(G.get_new_cell())\n+    atoms.set_cell(new_cell)\n     atoms.set_scaled_positions(scpos)\n \n-    \n+\n def sort(atoms, tags=None):\n     \"\"\"Return a new Atoms object with sorted atomic order. The default\n     is to order according to chemical symbols, but if *tags* is not\n",
            "new_file": false,
            "new_path": "ase/build/tools.py",
            "old_path": "ase/build/tools.py",
            "renamed_file": false
        },
        {
            "a_mode": "100644",
            "b_mode": "100644",
            "deleted_file": false,
            "diff": "--- a/ase/calculators/abinit.py\n+++ b/ase/calculators/abinit.py\n@@ -217,6 +217,9 @@ class Abinit(FileIOCalculator):\n         fh.write('acell\\n')\n         fh.write('%.14f %.14f %.14f Angstrom\\n' % (1.0, 1.0, 1.0))\n         fh.write('rprim\\n')\n+        if atoms.number_of_lattice_vectors != 3:\n+            raise RuntimeError('Abinit requires a 3D cell, but cell is {}'\n+                               .format(atoms.cell))\n         for v in atoms.cell:\n             fh.write('%.14f %.14f %.14f\\n' %  tuple(v))\n \n",
            "new_file": false,
            "new_path": "ase/calculators/abinit.py",
            "old_path": "ase/calculators/abinit.py",
            "renamed_file": false
        },
        {
            "a_mode": "100644",
            "b_mode": "100644",
            "deleted_file": false,
            "diff": "--- a/ase/calculators/aims.py\n+++ b/ase/calculators/aims.py\n@@ -174,7 +174,7 @@ class Aims(FileIOCalculator):\n             self.reset()\n         return changed_parameters\n \n-    def write_input(self, atoms, properties=None, system_changes=None,\n+    def write_input(self, atoms, scaled = False, properties=None, system_changes=None,\n                     ghosts=None):\n         FileIOCalculator.write_input(self, atoms, properties, system_changes)\n \n@@ -185,7 +185,7 @@ class Aims(FileIOCalculator):\n             raise RuntimeError('Found lattice vectors but no k-grid!')\n         if not have_lattice_vectors and have_k_grid:\n             raise RuntimeError('Found k-grid but no lattice vectors!')\n-        write_aims(os.path.join(self.directory, 'geometry.in'), atoms, ghosts)\n+        write_aims(os.path.join(self.directory, 'geometry.in'), atoms, scaled, ghosts)\n         self.write_control(atoms, os.path.join(self.directory, 'control.in'))\n         self.write_species(atoms, os.path.join(self.directory, 'control.in'))\n         self.parameters.write(os.path.join(self.directory, 'parameters.ase'))\n",
            "new_file": false,
            "new_path": "ase/calculators/aims.py",
            "old_path": "ase/calculators/aims.py",
            "renamed_file": false
        },
        {
            "a_mode": "100644",
            "b_mode": "100644",
            "deleted_file": false,
            "diff": "--- a/ase/calculators/calculator.py\n+++ b/ase/calculators/calculator.py\n@@ -26,10 +26,10 @@ all_changes = ['positions', 'numbers', 'cell', 'pbc',\n \n # Recognized names of calculators sorted alphabetically:\n names = ['abinit', 'aims', 'amber', 'asap', 'castep', 'cp2k', 'demon', 'dftb',\n-         'dmol', 'eam', 'elk', 'emt', 'exciting', 'fleur', 'gaussian', 'gpaw',\n-         'gromacs', 'gulp','hotbit', 'jacapo', 'lammps', 'lammpslib', 'lj',\n-         'mopac', 'morse', 'nwchem', 'octopus', 'onetep', 'siesta', 'tip3p',\n-         'turbomole', 'vasp']\n+         'dmol', 'eam', 'elk', 'emt', 'espresso', 'exciting', 'fleur',\n+         'gaussian', 'gpaw', 'gromacs', 'gulp', 'hotbit', 'jacapo', 'lammps',\n+         'lammpslib', 'lj', 'mopac', 'morse', 'nwchem', 'octopus', 'onetep',\n+         'siesta', 'tip3p', 'turbomole', 'vasp']\n \n \n special = {'cp2k': 'CP2K',\n@@ -38,7 +38,7 @@ special = {'cp2k': 'CP2K',\n            'elk': 'ELK',\n            'emt': 'EMT',\n            'fleur': 'FLEUR',\n-           'gulp' : 'GULP',\n+           'gulp': 'GULP',\n            'lammps': 'LAMMPS',\n            'lammpslib': 'LAMMPSlib',\n            'lj': 'LennardJones',\n@@ -173,6 +173,33 @@ def kpts2ndarray(kpts, atoms=None):\n     return np.array(kpts)\n \n \n+class EigenvalOccupationMixin:\n+    \"\"\"Define 'eigenvalues' and 'occupations' properties on class.\n+\n+    eigenvalues and occupations will be arrays of shape (spin, kpts, nbands).\n+\n+    Classes must implement the old-fashioned get_eigenvalues and\n+    get_occupations methods.\"\"\"\n+\n+    @property\n+    def eigenvalues(self):\n+        return self.build_eig_occ_array(self.get_eigenvalues)\n+\n+    @property\n+    def occupations(self):\n+        return self.build_eig_occ_array(self.get_occupation_numbers)\n+\n+    def build_eig_occ_array(self, getter):\n+        nspins = self.get_number_of_spins()\n+        nkpts = len(self.get_ibz_k_points())\n+        nbands = self.get_number_of_bands()\n+        arr = np.zeros((nspins, nkpts, nbands))\n+        for s in range(nspins):\n+            for k in range(nkpts):\n+                arr[s, k, :] = getter(spin=s, kpt=k)\n+        return arr\n+\n+\n class Parameters(dict):\n     \"\"\"Dictionary for parameters.\n \n@@ -199,7 +226,7 @@ class Parameters(dict):\n     def tostring(self):\n         keys = sorted(self)\n         return 'dict(' + ',\\n     '.join(\n-            '%s=%r' % (key, self[key]) for key in keys) + ')\\n'\n+            '{}={!r}'.format(key, self[key]) for key in keys) + ')\\n'\n \n     def write(self, filename):\n         file = open(filename, 'w')\n@@ -610,20 +637,16 @@ class FileIOCalculator(Calculator):\n         Calculator.calculate(self, atoms, properties, system_changes)\n         self.write_input(self.atoms, properties, system_changes)\n         if self.command is None:\n-            raise RuntimeError('Please set $%s environment variable ' %\n-                               ('ASE_' + self.name.upper() + '_COMMAND') +\n-                               'or supply the command keyword')\n+            raise RuntimeError(\n+                'Please set ${} environment variable '\n+                .format('ASE_' + self.name.upper() + '_COMMAND') +\n+                'or supply the command keyword')\n         command = self.command.replace('PREFIX', self.prefix)\n-        olddir = os.getcwd()\n-        try:\n-            os.chdir(self.directory)\n-            errorcode = subprocess.call(command, shell=True)\n-        finally:\n-            os.chdir(olddir)\n+        errorcode = subprocess.call(command, shell=True, cwd=self.directory)\n \n         if errorcode:\n-            raise RuntimeError('%s in %s returned an error: %d' %\n-                               (self.name, self.directory, errorcode))\n+            raise RuntimeError('{} in {} returned an error: {}'\n+                               .format(self.name, self.directory, errorcode))\n         self.read_results()\n \n     def write_input(self, atoms, properties=None, system_changes=None):\n",
            "new_file": false,
            "new_path": "ase/calculators/calculator.py",
            "old_path": "ase/calculators/calculator.py",
            "renamed_file": false
        },
        {
            "a_mode": "100644",
            "b_mode": "100644",
            "deleted_file": false,
            "diff": "--- a/ase/calculators/cp2k.py\n+++ b/ase/calculators/cp2k.py\n@@ -119,7 +119,16 @@ class CP2K(Calculator):\n         Name of exchange and correlation functional.\n         Accepts all functions supported by CP2K itself or libxc.\n         Default is ``LDA``.\n-\n+    print_level: str\n+        PRINT_LEVEL of global output.\n+        Possible options are:\n+        DEBUG Everything is written out, useful for debugging purposes only \n+        HIGH Lots of output \n+        LOW Little output \n+        MEDIUM Quite some output \n+        SILENT Almost no output \n+        Default is 'LOW'\n+        \n     \"\"\"\n \n     implemented_properties = ['energy', 'free_energy', 'forces', 'stress']\n@@ -139,7 +148,8 @@ class CP2K(Calculator):\n         stress_tensor=True,\n         uks=False,\n         poisson_solver='auto',\n-        xc='LDA')\n+        xc='LDA',\n+        print_level='LOW')\n \n     def __init__(self, restart=None, ignore_bad_restart_file=False,\n                  label='cp2k', atoms=None, command=None,\n@@ -224,7 +234,7 @@ class CP2K(Calculator):\n \n         # enable eV and Angstrom as units\n         self._shell.send('UNITS_EV_A')\n-        assert self._shell.recv() == '* READY'\n+        self._shell.expect('* READY')\n \n         n_atoms = len(self.atoms)\n         if 'cell' in system_changes:\n@@ -232,7 +242,7 @@ class CP2K(Calculator):\n             self._shell.send('SET_CELL %d' % self._force_env_id)\n             for i in range(3):\n                 self._shell.send('%.18e %.18e %.18e' % tuple(cell[i, :]))\n-            assert self._shell.recv() == '* READY'\n+            self._shell.expect('* READY')\n \n         if 'positions' in system_changes:\n             self._shell.send('SET_POS %d' % self._force_env_id)\n@@ -240,30 +250,32 @@ class CP2K(Calculator):\n             for pos in self.atoms.get_positions():\n                 self._shell.send('%.18e %.18e %.18e' % tuple(pos))\n             self._shell.send('*END')\n-            assert float(self._shell.recv()) >= 0  # max change -> ignore\n-            assert self._shell.recv() == '* READY'\n+            max_change = float(self._shell.recv())\n+            assert max_change >= 0 # sanity check\n+            self._shell.expect('* READY')\n \n         self._shell.send('EVAL_EF %d' % self._force_env_id)\n-        assert self._shell.recv() == '* READY'\n+        self._shell.expect('* READY')\n \n         self._shell.send('GET_E %d' % self._force_env_id)\n         self.results['energy'] = float(self._shell.recv())\n         self.results['free_energy'] = self.results['energy']\n-        assert self._shell.recv() == '* READY'\n+        self._shell.expect('* READY')\n \n         forces = np.zeros(shape=(n_atoms, 3))\n         self._shell.send('GET_F %d' % self._force_env_id)\n-        assert int(self._shell.recv()) == 3 * n_atoms\n+        nvals = int(self._shell.recv())\n+        assert nvals == 3 * n_atoms # sanity check\n         for i in range(n_atoms):\n             line = self._shell.recv()\n             forces[i, :] = [float(x) for x in line.split()]\n-        assert self._shell.recv() == '* END'\n-        assert self._shell.recv() == '* READY'\n+        self._shell.expect('* END')\n+        self._shell.expect('* READY')\n         self.results['forces'] = forces\n \n         self._shell.send('GET_STRESS %d' % self._force_env_id)\n         line = self._shell.recv()\n-        assert self._shell.recv() == '* READY'\n+        self._shell.expect('* READY')\n \n         stress = np.array([float(x) for x in line.split()]).reshape(3, 3)\n         assert np.all(stress == np.transpose(stress))   # should be symmetric\n@@ -290,7 +302,7 @@ class CP2K(Calculator):\n         self._shell.send('LOAD %s %s' % (inp_fn, out_fn))\n         self._force_env_id = int(self._shell.recv())\n         assert self._force_env_id > 0\n-        assert self._shell.recv() == '* READY'\n+        self._shell.expect('* READY')\n \n     def _write_file(self, fn, content):\n         \"\"\"Write content to a file\"\"\"\n@@ -311,14 +323,14 @@ class CP2K(Calculator):\n             for line in lines:\n                 self._shell.send(line)\n             self._shell.send('*END')\n-            assert self._shell.recv() == '* READY'\n+            self._shell.expect('* READY')\n \n     def _release_force_env(self):\n         \"\"\"Destroys the current force-environment\"\"\"\n         if self._force_env_id:\n             if self._shell.isready:\n                 self._shell.send('DESTROY %d' % self._force_env_id)\n-                assert self._shell.recv() == '* READY'\n+                self._shell.expect('* READY')\n             else:\n                 msg = \"CP2K-shell not ready, could not release force_env.\"\n                 warn(msg, RuntimeWarning)\n@@ -329,6 +341,8 @@ class CP2K(Calculator):\n         p = self.parameters\n         root = parse_input(p.inp)\n         root.add_keyword('GLOBAL', 'PROJECT ' + self.label)\n+        if p.print_level:\n+            root.add_keyword('GLOBAL', 'PRINT_LEVEL ' + p.print_level)\n         if p.force_eval_method:\n             root.add_keyword('FORCE_EVAL', 'METHOD ' + p.force_eval_method)\n         if p.stress_tensor:\n@@ -428,25 +442,32 @@ class Cp2kShell(object):\n             print(command)\n         self._child = Popen(command, shell=True, universal_newlines=True,\n                             stdin=PIPE, stdout=PIPE, bufsize=1)\n-        assert self.recv() == '* READY'\n+        self.expect('* READY')\n \n         # check version of shell\n         self.send('VERSION')\n-        shell_version = self.recv().rsplit(\":\", 1)\n-        assert self.recv() == '* READY'\n-        assert shell_version[0] == \"CP2K Shell Version\"\n-        self.version = float(shell_version[1])\n+        line = self.recv()\n+        if not line.startswith('CP2K Shell Version:'):\n+            raise RuntimeError('Cannot determine version of CP2K shell.  '\n+                               'Probably the shell version is too old.  '\n+                               'Please update to CP2K 3.0 or newer.')\n+\n+        shell_version = line.rsplit(\":\", 1)[1]\n+        self.version = float(shell_version)\n         assert self.version >= 1.0\n \n+        self.expect('* READY')\n+\n         # enable harsh mode, stops on any error\n         self.send('HARSH')\n-        assert self.recv() == '* READY'\n+        self.expect('* READY')\n \n     def __del__(self):\n         \"\"\"Terminate cp2k_shell child process\"\"\"\n         if self.isready:\n             self.send('EXIT')\n-            assert self._child.wait() == 0  # child process exited properly?\n+            rtncode = self._child.wait()\n+            assert rtncode == 0  # child process exited properly?\n         else:\n             warn(\"CP2K-shell not ready, sending SIGTERM.\", RuntimeWarning)\n             self._child.terminate()\n@@ -474,6 +495,10 @@ class Cp2kShell(object):\n         self.isready = line == '* READY'\n         return line\n \n+    def expect(self, line):\n+        \"\"\"Receive a line and asserts that it matches the expected one\"\"\"\n+        received = self.recv()\n+        assert received == line\n \n class InputSection(object):\n     \"\"\"Represents a section of a CP2K input file\"\"\"\n",
            "new_file": false,
            "new_path": "ase/calculators/cp2k.py",
            "old_path": "ase/calculators/cp2k.py",
            "renamed_file": false
        },
        {
            "a_mode": "100644",
            "b_mode": "100644",
            "deleted_file": false,
            "diff": "--- a/ase/calculators/dftd3.py\n+++ b/ase/calculators/dftd3.py\n@@ -10,6 +10,7 @@ from ase.calculators.calculator import (Calculator,\n from ase.units import Bohr, Hartree\n from ase.io.xyz import write_xyz\n from ase.io.vasp import write_vasp\n+from ase.parallel import paropen, world, broadcast\n \n \n class DFTD3(FileIOCalculator):\n@@ -223,12 +224,21 @@ class DFTD3(FileIOCalculator):\n         command = self._generate_command()\n \n         # Finally, call dftd3 and parse results.\n-        with open(self.label + '.out', 'w') as f:\n-            errorcode = subprocess.call(command, cwd=self.directory, stdout=f)\n+        with paropen(self.label + '.out', 'w') as f:\n+            if world.rank == 0:\n+                # DFTD3 does not run in parallel\n+                # so we only need it to run on 1 core\n+                errorcode = subprocess.call(command,\n+                                            cwd=self.directory, stdout=f)\n+            else:\n+                errorcode = None\n+        world.barrier()  # Wait for the call() to complete on the master node\n+        errorcode = broadcast(errorcode, root=0)\n \n         if errorcode:\n             raise RuntimeError('%s returned an error: %d' %\n                                (self.name, errorcode))\n+\n         self.read_results()\n \n     def write_input(self, atoms, properties=None, system_changes=None):\n@@ -290,7 +300,7 @@ class DFTD3(FileIOCalculator):\n                 damppars.append('6')\n \n             damp_fname = os.path.join(self.directory, '.dftd3par.local')\n-            with open(damp_fname, 'w') as f:\n+            with paropen(damp_fname, 'w') as f:\n                 f.write(' '.join(damppars))\n \n     def read_results(self):\n@@ -332,7 +342,6 @@ class DFTD3(FileIOCalculator):\n                 self.results['free_energy'] += efree\n             except PropertyNotImplementedError:\n                 pass\n-\n         if self.parameters['grad']:\n             # parse the forces\n             forces = np.zeros((len(self.atoms), 3))\n",
            "new_file": false,
            "new_path": "ase/calculators/dftd3.py",
            "old_path": "ase/calculators/dftd3.py",
            "renamed_file": false
        },
        {
            "a_mode": "100644",
            "b_mode": "100644",
            "deleted_file": false,
            "diff": "--- a/ase/calculators/elk.py\n+++ b/ase/calculators/elk.py\n@@ -4,24 +4,25 @@ import numpy as np\n \n from ase.units import Bohr, Hartree\n from ase.io.elk import read_elk\n-from ase.calculators.calculator import FileIOCalculator, Parameters, kpts2mp, \\\n-    ReadError, PropertyNotImplementedError\n+from ase.calculators.calculator import (FileIOCalculator, Parameters, kpts2mp,\n+                                        ReadError, PropertyNotImplementedError,\n+                                        EigenvalOccupationMixin)\n \n elk_parameters = {'swidth': Hartree}\n \n-class ELK(FileIOCalculator):\n+class ELK(FileIOCalculator, EigenvalOccupationMixin):\n     command = 'elk > elk.out'\n     implemented_properties = ['energy', 'forces']\n \n     def __init__(self, restart=None, ignore_bad_restart_file=False,\n                  label=os.curdir, atoms=None, **kwargs):\n         \"\"\"Construct ELK calculator.\n-        \n+\n         The keyword arguments (kwargs) can be one of the ASE standard\n         keywords: 'xc', 'kpts' and 'smearing' or any of ELK'\n         native keywords.\n         \"\"\"\n-        \n+\n         FileIOCalculator.__init__(self, restart, ignore_bad_restart_file,\n                                   label, atoms, **kwargs)\n \n",
            "new_file": false,
            "new_path": "ase/calculators/elk.py",
            "old_path": "ase/calculators/elk.py",
            "renamed_file": false
        },
        {
            "a_mode": "0",
            "b_mode": "100644",
            "deleted_file": false,
            "diff": "--- /dev/null\n+++ b/ase/calculators/espresso.py\n@@ -0,0 +1,61 @@\n+\"\"\"Quantum ESPRESSO Calculator\n+\n+export ASE_ESPRESSO_COMMAND=\"/path/to/pw.x -in PREFIX.pwi > PREFIX.pwo\"\n+\n+Run pw.x jobs.\n+\"\"\"\n+\n+\n+from ase import io\n+from ase.calculators.calculator import FileIOCalculator\n+\n+\n+class Espresso(FileIOCalculator):\n+    \"\"\"\n+    \"\"\"\n+    implemented_properties = ['energy', 'forces', 'stress', 'magmoms']\n+    command = 'pw.x -in PREFIX.pwi > PREFIX.pwo'\n+\n+    def __init__(self, restart=None, ignore_bad_restart_file=False,\n+                 label='espresso', atoms=None, **kwargs):\n+        \"\"\"\n+        All options for pw.x are copied verbatim to the input file, and put\n+        into the correct section. Use ``input_data`` for parameters that are\n+        already in a dict, all other ``kwargs`` are passed as parameters.\n+\n+        Accepts all the options for pw.x as given in the QE docs, plus some\n+        additional options:\n+\n+        input_data: dict\n+            A flat or nested dictionary with input parameters for pw.x\n+        pseudopotentials: dict\n+            A filename for each atomic species, e.g.\n+            ``{'O': 'O.pbe-rrkjus.UPF', 'H': 'H.pbe-rrkjus.UPF'}``.\n+            A dummy name will be used if none are given.\n+        kspacing: float\n+            Generate a grid of k-points with this as the minimum distance,\n+            in A^-1 between them in reciprocal space. If set to None, kpts\n+            will be used instead.\n+        kpts:\n+            Number of kpoints in each dimension for automatic kpoint generation.\n+        koffset: (int, int, int)\n+            Offset of kpoints in each direction. Must be 0 (no offset) or\n+            1 (half grid offset). Setting to True is equivalent to (1, 1, 1).\n+\n+\n+        .. note::\n+           Set ``tprnfor=True`` and ``tstress=True`` to calculate forces and\n+           stresses.\n+\n+\n+        \"\"\"\n+        FileIOCalculator.__init__(self, restart, ignore_bad_restart_file,\n+                                  label, atoms, **kwargs)\n+\n+    def write_input(self, atoms, properties=None, system_changes=None):\n+        FileIOCalculator.write_input(self, atoms, properties, system_changes)\n+        io.write(self.label + '.pwi', atoms, **self.parameters)\n+\n+    def read_results(self):\n+        output = io.read(self.label + '.pwo')\n+        self.results = output.calc.results\n",
            "new_file": true,
            "new_path": "ase/calculators/espresso.py",
            "old_path": "ase/calculators/espresso.py",
            "renamed_file": false
        },
        {
            "a_mode": "100644",
            "b_mode": "100644",
            "deleted_file": false,
            "diff": "--- a/ase/calculators/exciting.py\n+++ b/ase/calculators/exciting.py\n@@ -2,18 +2,19 @@ from __future__ import print_function\n import os\n \n import numpy as np\n-\n+import xml.etree.ElementTree as ET\n from ase.io.exciting import atoms2etree\n from ase.units import Bohr, Hartree\n from ase.calculators.calculator import PropertyNotImplementedError\n from ase.utils import basestring\n+from xml.dom import  minidom\n \n \n class Exciting:\n     def __init__(self, dir='calc', paramdict=None,\n                  speciespath=None,\n                  bin='excitingser', kpts=(1, 1, 1),\n-                 autormt=False, **kwargs):\n+                 autormt=False, tshift=True, **kwargs):\n         \"\"\"Exciting calculator object constructor\n \n         dir: string\n@@ -46,6 +47,7 @@ class Exciting:\n         self.converged = False\n         self.excitingbinary = bin\n         self.autormt = autormt\n+        self.tshift = tshift\n         self.groundstate_attributes = kwargs\n         if ('ngridk' not in kwargs.keys() and (not (self.paramdict))):\n             self.groundstate_attributes['ngridk'] = ' '.join(map(str, kpts))\n@@ -69,8 +71,7 @@ class Exciting:\n         \"\"\"\n         returns potential Energy\n         \"\"\"\n-        if self.energy is None:\n-            self.update(atoms)\n+        self.update(atoms)\n         return self.energy\n \n     def get_forces(self, atoms):\n@@ -93,18 +94,22 @@ class Exciting:\n         self.read()\n \n     def write(self, atoms):\n-        from lxml import etree as ET\n         if not os.path.isdir(self.dir):\n             os.mkdir(self.dir)\n         root = atoms2etree(atoms)\n         root.find('structure').attrib['speciespath'] = self.speciespath\n         root.find('structure').attrib['autormt'] = str(self.autormt).lower()\n+        root.find('structure').attrib['tshift'] = str(self.tshift).lower()\n+\n+        def prettify(elem):\n+            rough_string = ET.tostring(elem, 'utf-8')\n+            reparsed = minidom.parseString(rough_string)\n+            return reparsed.toprettyxml(indent=\"\\t\")\n \n         if(self.paramdict):\n             self.dicttoxml(self.paramdict, root)\n             fd = open('%s/input.xml' % self.dir, 'w')\n-            fd.write(ET.tostring(root, method='xml', pretty_print=True,\n-                                 xml_declaration=True, encoding='UTF-8'))\n+            fd.write(prettify(root))\n             fd.close()\n         else:\n             groundstate = ET.SubElement(root, 'groundstate', tforce='true')\n@@ -114,12 +119,10 @@ class Exciting:\n                 else:\n                     groundstate.attrib[key] = str(value)\n             fd = open('%s/input.xml' % self.dir, 'w')\n-            fd.write(ET.tostring(root, method='xml', pretty_print=True,\n-                                 xml_declaration=True, encoding='UTF-8'))\n+            fd.write(prettify(root))\n             fd.close()\n \n     def dicttoxml(self, pdict, element):\n-        from lxml import etree as ET\n         for key, value in pdict.items():\n             if (isinstance(value, basestring) and key == 'text()'):\n                 element.text = value\n@@ -140,8 +143,6 @@ class Exciting:\n         \"\"\"\n         reads Total energy and forces from info.xml\n         \"\"\"\n-        from lxml import etree as ET\n-\n         INFO_file = '%s/info.xml' % self.dir\n \n         try:\n@@ -149,15 +150,16 @@ class Exciting:\n         except IOError:\n             raise RuntimeError(\"output doesn't exist\")\n         info = ET.parse(fd)\n-        self.energy = float(info.xpath('//@totalEnergy')[-1]) * Hartree\n+        self.energy = float(info.findall(\n+            'groundstate/scl/iter/energies')[-1].attrib['totalEnergy']) * Hartree\n         forces = []\n-        forcesnodes = info.xpath(\n-            '//structure[last()]/species/atom/forces/totalforce/@*')\n+        forcesnodes = info.findall(\n+            'groundstate/scl/structure')[-1].findall('species/atom/forces/totalforce')\n         for force in forcesnodes:\n-            forces.append(np.array(float(force)))\n+            forces.append(np.array(list(force.attrib.values())).astype(np.float))\n         self.forces = np.reshape(forces, (-1, 3)) * Hartree / Bohr\n \n-        if str(info.xpath('//groundstate/@status')[0]) == 'finished':\n+        if str(info.find('groundstate').attrib['status']) == 'finished':\n             self.converged = True\n         else:\n             raise RuntimeError('calculation did not finish correctly')\n",
            "new_file": false,
            "new_path": "ase/calculators/exciting.py",
            "old_path": "ase/calculators/exciting.py",
            "renamed_file": false
        }
    ]
}
